<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>美国虚拟号码google voice保号的几种方法</title>
    <url>/posts/17/</url>
    <content><![CDATA[<h3 id="美国虚拟号码google-voice保号的几种方法"><a href="#美国虚拟号码google-voice保号的几种方法" class="headerlink" title="美国虚拟号码google voice保号的几种方法"></a>美国虚拟号码google voice保号的几种方法</h3><h3 id="1-手动定闹钟，2个GV号码互发短信保号"><a href="#1-手动定闹钟，2个GV号码互发短信保号" class="headerlink" title="1. 手动定闹钟，2个GV号码互发短信保号"></a>1. 手动定闹钟，2个GV号码互发短信保号</h3><p>设置一个闹钟(推荐一个手机APP-<strong>时光序</strong>)</p>
<p>可以是一个月或三个月提醒自己登陆Google Voice，手动与自己的其它GV号码(或是朋友的GV号码)发送短信保号。</p>
<p>也可以加入TG上的一些Google Voice保号群组，到了时间就向别人的GV号码发送一条保号短信。</p>
<p>如果手上只有1个GV号码，需要再加多一个GV号码的朋友</p>
<p>又觉得自己申请麻烦的，可以去<a href="https://www.blogger.com/u/1/blog/post/edit/2450596201657692512/1822531296986319031#">海淘钱包自动发卡商城</a>买一个GV号码</p>
<p>手工注册，可以转移，只需要15块一个，长期持有也没有月租.</p>
<p>觉得自己和自己发短信无趣?也可以拨打如下美国的免费客服电话来保号</p>
<p>美国之声：(213)493-0288</p>
<p>Apple 客服： (800)275-2273</p>
<p>微软客服：(800) 642-7676</p>
<p>亚马逊客服：(206)266-2992</p>
<h3 id="2-使用IFTTT程序保号-已失效"><a href="#2-使用IFTTT程序保号-已失效" class="headerlink" title="2. 使用IFTTT程序保号(已失效)"></a>2. 使用IFTTT程序保号(已失效)</h3><p>打开<a href="https://www.blogger.com/u/1/blog/post/edit/2450596201657692512/1822531296986319031#">IFTTT网站</a>，点击右上方Get start</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-07-59-1024x533.png?v=1617288384" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-07-59-1024x533.png?v=1617288384"></p>
<p>选择Continue With Google，登陆自己的登陆账号</p>
<p>登入后点击Get More按钮</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-09-19.png" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-09-19.png"></p>
<p>搜索框输入 Keep Google Voice，找到如下图 Keep Google Voice Active</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-10-09-1024x686.png?v=1617288422" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-10-09-1024x686.png?v=1617288422"></p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-10-42-1024x718.png?v=1617288453" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-10-42-1024x718.png?v=1617288453"></p>
<p>点击Connect，将自己的GV账号连接到此程序</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-11-30.png" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-11-30.png"></p>
<p>在输入框中，输入自己要保号的google voice号码(输完点击 Send PIN 之前，须保证自己的google voice已登陆到网页或是手机上，保证能接到电话)</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-35-31-1024x354.png?v=1617288477" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_16-35-31-1024x354.png?v=1617288477"></p>
<p>点击Send PIN之后会有电话呼入到google voice号码，接听语音播报4位PIN码，听完后填入到此处。如果接通了电话但未听清，也可以在接听过程中按数字键盘2键，改为短信收PIN验证码，输完点击Connect</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-26-04.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-26-04.jpg"></p>
<p>下一步选择时区，这个可以选择美国当地时区，也可以随意设定一个。</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-32-28.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-32-28.jpg"></p>
<p>到这一步就是创建完成了，默认是会每隔一个月发送一条短信</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-33-23.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-33-23.jpg"></p>
<p>若想修改发送的频率，可以点击右上方的Settings</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-34-35.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-34-35.jpg"></p>
<p>依次点击Delete – Convert，就会出现 Edit，点击 Edit</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-35-51.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-35-51.jpg"></p>
<p>这里就可以指定在每月的第几天，几点几分来发送此保号短信了</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-37-55.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Snipaste_2021-04-01_17-37-55.jpg"></p>
<p>设定好后，更新定时器，然后保存</p>
<p>至此使用IFTTT每月定时自动发送短信的保号操作就成功了</p>
<h3 id="3-订阅广告收短信保号（已失效）"><a href="#3-订阅广告收短信保号（已失效）" class="headerlink" title="3. 订阅广告收短信保号（已失效）"></a>3. 订阅广告收短信保号（已失效）</h3><p>发送“auto”至“67135”，然后回复Y订阅广告推送短信，每周接收4条Autozone(一家汽车零件品牌)广告推送短信</p>
<p>发送“JOIN”到“22122”，每月接收2条Starbucks(星巴克)广告推送短信，如果要停止订阅，发送 “STOP”即可</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/starbucks.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/starbucks.jpg"></p>
<p>发送“code”到“25666”，再回复”PROMO” 每月接收Bloomingdale’s广告推送短信。如果要停止订阅，发送 “STOP”即可</p>
<p><img src="https://xunihao.net/wp-content/uploads/2021/04/Bloomingdales.jpg" alt="https://xunihao.net/wp-content/uploads/2021/04/Bloomingdales.jpg"></p>
<h3 id="4-购买永久号"><a href="#4-购买永久号" class="headerlink" title="4. 购买永久号"></a>4. 购买永久号</h3><p>如果你不喜欢订阅广告，又会忘记手动保号，那么最适合你的就是花费30刀买个永久的google voice号码。详细教程见<a href="https://www.blogger.com/u/1/blog/post/edit/2450596201657692512/1822531296986319031#">将你的google voice购买成永久号码</a></p>
<h3 id="5-实体号码转入"><a href="#5-实体号码转入" class="headerlink" title="5. 实体号码转入"></a>5. 实体号码转入</h3><p>如果手上有一些美国的实体电话卡(如<a href="https://www.blogger.com/u/1/blog/post/edit/2450596201657692512/1822531296986319031#">Lyca莱卡</a>、Google Fi电话卡)，觉得月租太贵不想续费了，可以将这些号码转入到Google voice。</p>
<p>一方面是可以保留原来的号码，已注册的网站账号基本可以不受影响</p>
<p>另一方面，号码转入到Google voice后，这个号码就是永久号了。也没有月租。</p>
<p>Google Fi的号码转入到google voice是免费的</p>
<p>Lyca莱卡转入到google vocie需要收取20美元一次性的转入费用</p>
<h3 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h3><p>如果GV号码几个月只接收消息，而不登陆或发送短信拨打电话，仍有机会收到下图的回收GV号码提示邮件</p>
<p><img src="https://xunihao.net/wp-content/uploads/2020/11/Snipaste_2020-11-25_23-14-47-1-1024x331.jpg" alt="https://xunihao.net/wp-content/uploads/2020/11/Snipaste_2020-11-25_23-14-47-1-1024x331.jpg"></p>
<p>所以推荐大家用手动方式登陆发短信打电话是最省钱有效的。</p>
]]></content>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title>收集一些免费的虚拟空间</title>
    <url>/posts/1/</url>
    <content><![CDATA[<h2 id="收集一些免费的虚拟空间"><a href="#收集一些免费的虚拟空间" class="headerlink" title="收集一些免费的虚拟空间"></a>收集一些免费的虚拟空间</h2><p><strong>🔗地址</strong>：<a href="http://www.000webhost.com/">http://www.000webhost.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p>1500M支持PHP可绑米免费虚拟主机</p>
<p>免费提供1500M空间，100G流量，FTP、Web方式上传管理文件，支持PHP5，提供2个MySQL数据库， cPanel管理面板，可一键安装WordPress、phpBB2、Drupal、Joomla等几种热门PHP程序，免费提供1个二级域名，可以绑定自己的域名，速度不错，无广告。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704134601.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704134601.png"></p>
<h2 id="GoogieHost"><a href="#GoogieHost" class="headerlink" title="GoogieHost"></a>GoogieHost</h2><p><strong>🔗地址</strong>：<a href="https://googiehost.com/freehosting.html">https://googiehost.com/freehosting.html</a></p>
<p><strong>📖简介</strong>：</p>
<p>免费网络托管与cpanel🔥PHP和mySQL SSL无限域名</p>
<p>对于免费的虚拟主机提供商，Googiehost仍然是更好的选择之一。它是cPanel和Cloudflare附带的唯一免费网站托管网站，尽管是免费形式。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141029.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141029.png"></p>
<h2 id="awardspace"><a href="#awardspace" class="headerlink" title="awardspace"></a>awardspace</h2><p><strong>🔗地址</strong>：<a href="https://www.awardspace.com/free-hosting/">https://www.awardspace.com/free-hosting/</a></p>
<p><strong>📖简介</strong>：</p>
<p>免费用户能使用1 GB的磁盘空间和5GB的带宽。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141319.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141319.png"></p>
<h2 id="UcoZ"><a href="#UcoZ" class="headerlink" title="UcoZ"></a>UcoZ</h2><p><strong>🔗地址</strong>：<a href="http://www.ucoz.com/">http://www.ucoz.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p>支持FTP且可绑米300M</p>
<p>Ucoz的免费自助建站系统功能非常强大，对中文支持也很好，但生成的网页却是英文，好在支持FTP、Web上传管理文件，你可以自己上传中文网页或其它文件，可以支持外链。UcoZ提供免费二级域名1个，还可以绑定你自己的域名。Ucoz不支持PHP、ASP等程序脚本，但免费提供了论坛、留言板、博客、网络相册、投票系统等常用程序，你可以自己选择安装。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135522.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135522.png"></p>
<h2 id="infinityfree"><a href="#infinityfree" class="headerlink" title="infinityfree"></a>infinityfree</h2><p><strong>🔗地址</strong>：<a href="https://infinityfree.net/">https://infinityfree.net/</a></p>
<p><strong>📖简介</strong>：</p>
<p>一个免费的网站托管平台。它提供了无限的磁盘空间和带宽。此外，您不会强制投放广告，并可以带上您的域名或从超过25个域名扩展中选择一个免费的子域名。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141543.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141543.png"></p>
<h2 id="FreeWebHostingArea"><a href="#FreeWebHostingArea" class="headerlink" title="FreeWebHostingArea"></a>FreeWebHostingArea</h2><p><strong>🔗地址</strong>：<a href="http://www.freewebhostingarea.com/">http://www.freewebhostingarea.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p>支持FTP且可绑米300M</p>
<p>FreeWebHostingArea免费PHP空间，500M存储空间，单个文件限10M以内，不限上传文件类型，每天5G流量，FTP、Web方式上传管理文件，支持PHP5、MySQL5、SSI，可自定义404、403错误，提供免费二级域名1个，或者绑定1个你自己的域名，无广告。FreeWebHostingArea免费空间旗下有多个网站，域名不一样、IP地址不一样，其它都一样，根据你的需要来选择。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135455.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135455.png"></p>
<h2 id="freehosting"><a href="#freehosting" class="headerlink" title="freehosting"></a>freehosting</h2><p><strong>🔗地址</strong>：<a href="https://www.freehosting.com/">https://www.freehosting.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p><a href="https://www.notion.so/6f19b8dd381247e3aa939f29d36ced0a">无标题</a></p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141721.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704141721.png"></p>
<h2 id="Freehostia"><a href="#Freehostia" class="headerlink" title="Freehostia"></a>Freehostia</h2><p><strong>🔗地址</strong>：<a href="http://www.freehostia.com/">http://www.freehostia.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p>250M可绑米免费PHP空间</p>
<p>Freehostia免费PHP空间，250M容量，每月6G流量，CPU使用不超过1.3%，FTP、Web方式上传管理文件，支持PHP、CGI，1个MySQL数据库（10M存储空间），提供免费二级域名，并可最多绑定5个自己的域名建立5个不同的网站，还提供3个支持POP3、IMAP的免费邮箱，Freehostia具有功能强大的简体中文管理面板，速度不错，无广告。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135557.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135557.png"></p>
<h2 id="0fees"><a href="#0fees" class="headerlink" title="0fees"></a>0fees</h2><p><strong>🔗地址</strong>：<a href="http://www.0fees.net/hosting.php">http://www.0fees.net/hosting.php</a></p>
<p><strong>📖简介</strong>：</p>
<p>提供300M国外高速免费php空间申请</p>
<p>ByetHost 和0fees系出同门的免费空间（000webhost），值得推荐。</p>
<p>0fees是美国的免费空间，速度不错，提供300M空间，每月10G流量，ftp、web方式上传管理文件，支持PHP5，提供3个MySQL数据库，无限个支持POP3的电子邮箱，可以添加6个二级域名，绑定6个域名，可建6个不同网站，VistaPanel管理面板。可一键安装WordPress、phpBB、PHPWind、Xoops、Drupal等30余种最新PHP程序。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135710.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135710.png"></p>
<h2 id="ByetHost"><a href="#ByetHost" class="headerlink" title="ByetHost"></a>ByetHost</h2><p><strong>🔗地址</strong>：<a href="http://www.byethost.com/">http://www.byethost.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p>250M可绑米国外免费PHP站</p>
<p>ByetHost提供250M空间，每月6G流量，ftp、web方式上传管理文件，支持PHP5，提供3个MySQL数据库，无限个支持POP3的电子邮箱，可以添加6个二级域名，绑定6个域名，可建6个不同网站，VistaPanel管理面板。可一键安装WordPress、phpBB、PHPWind、Xoops、Drupal等30余种最新PHP程序。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135807.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135807.png"></p>
<h2 id="MegaByet"><a href="#MegaByet" class="headerlink" title="MegaByet"></a>MegaByet</h2><p><strong>🔗地址</strong>：<a href="http://megabyet.com/">http://megabyet.com/</a></p>
<p><strong>📖简介</strong>：</p>
<p>免费1.6G可绑米国外空间</p>
<p>Megabyet免费PHP空间，cPanel面板，1600M容量，无流量，FTP、Web方式上传管理文件，支持PHP、CGI，3个MySQL数据库，2个FTP帐户，提供免费二级域名，并可最多绑定6个自己的域名建立6个不同的网站，还提供支持POP3、IMAP的免费邮箱，速度很好，无广告，推荐使用。</p>
<p><img src="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135839.png" alt="https://qiantigers.coding.net/p/pic/d/pic/git/raw/master/2021/7/4/20210704135839.png"></p>
]]></content>
      <tags>
        <tag>虚拟空间</tag>
        <tag>免费</tag>
      </tags>
  </entry>
  <entry>
    <title>AAD应用获得永久密码</title>
    <url>/posts/40759/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>在这里需要用到微软的在线测试API工具——Graph Explorer。  工具地址：<a href="https://developer.microsoft.com/zh-cn/graph/graph-explorer">https://developer.microsoft.com/zh-cn/graph/graph-explorer</a>  Micro Graph API文档：<a href="https://docs.microsoft.com/zh-CN/graph/api/overview?view=graph-rest-1.0">https://docs.microsoft.com/zh-CN/graph/api/overview?view=graph-rest-1.0</a></p>
<p>使用条件：  需要登录全局管理员账号</p>
<p>一、注册应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507210501.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507210501.png"></p>
<p>二、复制应用的对象ID</p>
<p>三、Graph Explorer 中调用API添加密码</p>
<ol>
<li><p>请求类型改为,请求地址<code>https://graph.microsoft.com/v1.0/applications/&#123;id&#125;/addPassword</code>其中改为应用的</p>
<p>POST</p>
<p>{id}</p>
<p>对象ID</p>
</li>
<li><p>添加请求正文：过期时间(utc格式)（必选）、密钥名称（可选）、开始时间（可选）在这里只选择前两个变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;passwordCredential&quot;: &#123;&quot;displayName&quot;:&quot;勿埋我心100年&quot;,&quot;endDateTime&quot;:&quot;2121-12-31T00:00:00Z&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>给Graph Explorer权限步骤：修改权限(预览版) – 同意许可</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507211434.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507211434.png"></p>
</li>
<li><p>运行查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507211626.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507211626.png"></p>
</li>
</ol>
<p>四、回到之前申请应用的地方，查看是否成功  出现如下图，则表示成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507211829.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210507211829.png"></p>
<h2 id="几点建议"><a href="#几点建议" class="headerlink" title="几点建议"></a>几点建议</h2><ol>
<li>不要在原来的应用上创建新密码，建议创建一个一模一样的应用，再创建永久密码。</li>
<li>其实两年也够用，且正规更稳定一些。</li>
</ol>
<p>具体的情况，自己斟酌，只是提供一个方法。</p>
<p><strong>转载至<a href="https://www.qian.blue/archives/aad-forever-secret.html">https://www.qian.blue/archives/aad-forever-secret.html</a></strong></p>
]]></content>
      <tags>
        <tag>AAD</tag>
      </tags>
  </entry>
  <entry>
    <title>申请永久免费的eu.org</title>
    <url>/posts/49370/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>明月不归沉碧海，白云愁色满苍梧。 ——勿埋我心</p>
</blockquote>
<p> <code>eu.org</code>是欧盟组织下面的域名，EU代表欧盟嘛，在1996年的9-10月份由Paul Mockapetris创建了这个域名的DNS服务器。目前个人和组织都是可以免费注册的。</p>
<p>优点：历史悠久、稳定性不错、几乎没有限制、支持NS修改。缺点：国内无法使用<code>http</code>，只有配<code>https</code>才可以正常使用。</p>
<h1 id="获取的步骤"><a href="#获取的步骤" class="headerlink" title="获取的步骤"></a>获取的步骤</h1><p>❄ 一、我猜你是没有账号的，先注册一个吧。  🔗地址：<a href="https://nic.eu.org/arf/">https://nic.eu.org/arf/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107181606.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107181606.png"></p>
<p>❄ 二、尽量如实地填写资料，可以参考一下我是怎么写的。  之后你会收到一条验证身份的邮件，正常验证即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107181750.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107181750.png"></p>
<p>❄ 三、登录，用户名在你的邮件里  ❄ 四、注册你想要的域名  ❄ 五、填入相关的域名信息  (1) 输入完整的域名，我输入的是<code>vvww.eu.org</code>，前缀<code>&gt;=4</code>。当然，域名不仅仅是<code>eu.org</code>，更多详情可以看这个链接 👉 <a href="https://www.blogger.com/u/1/blog/post/edit/1070520564074404192/5209754360659823584#">域名列表</a>  (2)需要进行DNS解析，在这里勿埋我心使用的是DNSPod。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107182311.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107182311.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107182530.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107182530.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107184308.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107184308.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107185405.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107185405.png"></p>
<p>❄ 六、信息检查，如果出现“Done”的字眼，则表明成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107184719.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107184719.png"></p>
<p>❄ 七、耐心等待审核通过，会有邮件通知。大概3–14天。</p>
<h1 id="成功之后"><a href="#成功之后" class="headerlink" title="成功之后"></a>成功之后</h1><p>❄ 查看相关设置是否生效  我等了5天时间，终于收到了他们的喜讯。详图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200149.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200149.png"></p>
<p>随即在DNSPod查看NS记录是否生效。详情如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200349.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200349.png"></p>
<p>❄ 如何管理自己的域名？  登录<a href="https://www.blogger.com/u/1/blog/post/edit/1070520564074404192/5209754360659823584#">Domain List</a>皆可查看。详情如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200706.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200706.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200745.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210112200745.png"></p>
<h1 id="如果想要修改NS该怎么处理？"><a href="#如果想要修改NS该怎么处理？" class="headerlink" title="如果想要修改NS该怎么处理？"></a>如果想要修改NS该怎么处理？</h1><p><img src="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107185205.png" alt="https://cdn.jsdelivr.net/gh/qiantigers/onetu/20210107185205.png"></p>
<p>须选择<code>server name</code>，否则无法审核通过。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>❄ 1. <code>http</code>无效，需配<code>ssl</code>。❄ 2. 据传腾讯防红效果颇为可观。❄ 3. 权重堪比顶级域名。</p>
<p><strong>转载至<a href="https://www.qian.blue/archives/eu-org.html">https://www.qian.blue/archives/eu-org.html</a></strong></p>
]]></content>
      <tags>
        <tag>免费</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌 gd-utils 百宝箱详细教程</title>
    <url>/posts/60039/</url>
    <content><![CDATA[<ul>
<li><h1 id="谷歌-gd-utils-百宝箱详细教程"><a href="#谷歌-gd-utils-百宝箱详细教程" class="headerlink" title="谷歌 gd-utils 百宝箱详细教程"></a>谷歌 gd-utils 百宝箱详细教程</h1><p>本文更新于2020年9月19日，由于近期 <code>Debian</code>、<code>Ubuntu</code> 系统出现某些依赖无法安装导致部署失败，所以推荐使用 <code>CentOS</code> 系统</p>
<p>注意：此工具很大的方便了我们的生活，请不要滥用</p>
<p><code>Google Drive</code> 百宝箱是 <code>iwestlin</code> 的一个项目，可以进行自动化转存谷歌云端硬盘的文件</p>
<p><strong>具体使用场景是什么？</strong></p>
<p>例如有的时候别人在谷歌云盘分享了一个资源，这个资源可以是文件，视频，压缩包，这个资源我想把它保存到我的谷歌网盘里，按照传统的思路，我们首先需要将别人网盘里的内容先下载下来，然后在上传到自己网盘，这是最传统的方法，也是最慢的。现在我们有了新的方法，那就是 <code>gd-utils</code> 百宝箱，在 <code>VPS</code> 上搭建一个百宝箱，配置好一个电报机器人，这样就可以实现别人网盘分享的链接，我们把链接发送给机器人，点一下复制，机器人会帮我们把别人网盘的内容存储到我们的网盘，非常便捷，因为每个谷歌账号每天只有 <code>750G</code> 的转存额度，所以还需要配置一些 <code>SA</code> 账号来提高额度</p>
<p>搭建之前</p>
<blockquote>
<p>一个没有限额项目的谷歌账号，而且这个谷歌账号有一个团队云盘</p>
</blockquote>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h64j.png" alt="img"></p>
<p>谷歌搜索 <code>google api</code> ,然后登陆自己搭建的谷歌账号，找到下图所示页面，先点击左上角选择项目，如果已经有项目就点击所在项目，然后点击全部，查看已有项目；点击新建项目，查看项目额度</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hgnv.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hmCc.png" alt="img"></p>
<p>还有项目额度的账号才可以使用，如果额度不够，需要自己申请，申请页面会在里新建项目时提示出现</p>
<h3 id="为什么需要一个没有限额的账号？"><a href="#为什么需要一个没有限额的账号？" class="headerlink" title="为什么需要一个没有限额的账号？"></a>为什么需要一个没有限额的账号？</h3><p><strong>因为我们搭建百宝箱需要用到 <code>google api</code> 项目</strong>，谷歌 <code>api</code> 项目一般默认只有 10 个，创建项目后即占用一个额度；而如果项目不够，就不能创建项目；只能删除原先的项目，但是删除项目需要 30 天才能删除，处于删除状态的还未删除的项目也占用你的项目额度；所以项目不能所以乱建，而如果额度不够，只能向谷歌申请，但是申请项目后，我发现在搭建过程中，<strong>可能会存在不能创建项目的情况！</strong></p>
<blockquote>
<p>一台纯净系统的服务器</p>
</blockquote>
<p>一台纯净系统的服务器，推荐 <code>CentOS 7</code> 系统，使用域名给这个服务器的 <code>IP</code> 做一下 <code>A</code> 解析；据说使用谷歌云虚拟机实例搭建，转存网盘内容不使用谷歌云的流量；本文以 <strong>CentOS 7 64</strong> 位系统做演示</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hO8F.png" alt="img"></p>
<blockquote>
<p>向电报申请机器人</p>
</blockquote>
<p>打开电报，搜索机器人 <code>**@BotFather**</code> ，并点击下方开始进行对话，寻找机器人的时候，<strong>一定要看清机器人的用户名</strong></p>
<p>点击图中所示点击创建机器人</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hYqV.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/haFO.png" alt="img"></p>
<p>记录机器人的 <code>token</code> 值，<strong>在后面的步骤要用到</strong></p>
<p>打开 <a href="https://developers.google.com/drive/api/v3/quickstart/python">这个网站</a> ，<strong>登陆你需要搭建的谷歌账号</strong>，然后按照图示操作点击创建</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hcOz.png" alt="img"></p>
<p>到了这里下载这个 <strong>credentials.json</strong> 的文件保存到本地，然后点击 <code>done</code> ，结束创建</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h7dR.png" alt="img"></p>
<p>谷歌搜索 <code>google API</code> ，打开后登陆自己的账号，按图示操作，点击左上角的项目，点击全部，最后点击我们刚才创建的新项目 <code>Quickstart</code> 进入到我们新建的项目</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h8iE.png" alt="img"></p>
<p>查看这个项目下开放了哪些 <code>API</code>，正常情况下需要创建开放 <strong>5个API</strong> ，如果你的项目没有或缺少某些 <code>API</code> ，请按照下面的 <code>API</code> 列表补齐，在<strong>上方搜索API和服务的地方搜索启用</strong></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hj4A.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Google Drive API</span><br><span class="line"></span><br><span class="line">Identity and Access Management (IAM) API</span><br><span class="line"></span><br><span class="line">Service Usage API</span><br><span class="line"></span><br><span class="line">Cloud Resource Manager API</span><br><span class="line"></span><br><span class="line">IAM Service Account Credentials API</span><br></pre></td></tr></table></figure>


<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h2x5.png" alt="img"></p>
<p>开始搭建</p>
<blockquote>
<p>使用 SSH 连接到 VPS ，配置 VPS 环境</p>
</blockquote>
<p>CentOS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br><span class="line"> </span><br><span class="line">yum install epel-release -y</span><br><span class="line"></span><br><span class="line">yum install wget curl python3 python3-pip git screen unzip sudo fuse fuse-devel -y </span><br></pre></td></tr></table></figure>

<p>Debian、Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">apt-get install wget curl python3 python3-pip git unzip screen sudo fuse -y</span><br></pre></td></tr></table></figure>


<p>安装完成后，试试输入 <code>python</code> 或者 <code>python3</code> 看看有没有反应，如果有说明 <code>python</code> 配置正确，请继续下一步；如果没有，请自行配置 <code>python</code> 环境</p>
<hr>
<p>安装 <strong>Node.js v12.x</strong></p>
<hr>
<p>CentOS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://rpm.nodesource.com/setup_lts.x | bash -</span><br><span class="line"></span><br><span class="line">yum install -y nodejs</span><br><span class="line"></span><br><span class="line">yum install gcc-c++ make</span><br><span class="line"></span><br><span class="line">curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo</span><br><span class="line"></span><br><span class="line">yum install yarn</span><br></pre></td></tr></table></figure>

<p>Debian</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | bash -</span><br><span class="line"></span><br><span class="line">apt-get install -y nodejs</span><br></pre></td></tr></table></figure>

<p>Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line"></span><br><span class="line">apt-get install -y nodejs</span><br></pre></td></tr></table></figure>


<p>安装好 <code>Node.js</code> 之后，检验一下，输入 <code>node -v</code> 代码，如果有输出且输出的是 <code>node</code> 的版本号，则表示 <code>node</code> 配置正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">v12.18.3</span><br></pre></td></tr></table></figure>


<p>安装 <code>Node</code> 参考：<a href="https://github.com/nodesource/distributions/blob/master/README.md#debinstall">https://github.com/nodesource/distributions/blob/master/README.md#debinstall</a></p>
<blockquote>
<p>安装 rclone 和 AutoRclone</p>
</blockquote>
<p>CentOS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; curl https://rclone.org/install.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo git clone https://github.com/xyou365/AutoRclone &amp;&amp; cd AutoRclone &amp;&amp; sudo pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>Debian、Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install screen git &amp;&amp; curl https://rclone.org/install.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo git clone https://github.com/xyou365/AutoRclone &amp;&amp; cd AutoRclone &amp;&amp; sudo pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>


<p>进入到 <code>AutoRclone</code> 目录，将我们在谷歌网页创建项目时下载的 <code>**credentials.json**</code> 文件上传到 <code>AutoRclone</code> 文件夹里面</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hIrD.png" alt="img"></p>
<blockquote>
<p>创建项目，在项目里创建服务账号 SA</p>
</blockquote>
<h3 id="为什么要创建SA？"><a href="#为什么要创建SA？" class="headerlink" title="为什么要创建SA？"></a>为什么要创建SA？</h3><p>单个谷歌账号在转存谷歌云盘内容时每天有 <code>750G</code> 的限制，解决这一限制要么自己有很多的谷歌账号要么就创建服务账号；拥有很多谷歌账号这是不现实的，所以我们需要创建服务账号，然后把这些服务账号添加到云盘，让他们成为云盘的管理员，在利用 <code>AutoRclone</code> 工具的自动切换功能实现一个账号限额后自动切换到下一个账号，这样就突破了每天<code>750G</code>的限制，可以转存大文件</p>
<p>服务账号就是 <code>service accounts</code>，简称 <code>SA</code>，每个谷歌项目最多可以创建 100 个 <code>SA</code></p>
<hr>
<p><strong>创建项目，在项目里创建 <code>SA</code>，这里又分为三种情况</strong></p>
<hr>
<p>如果你之前没创建过项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 gen_sa_accounts.py --quick-setup 1</span><br></pre></td></tr></table></figure>

<p>这个代码的意思是创建 <code>1</code> 个新项目、每个项目里面创建100个 <code>sa</code> 、开启相关的服务、将 100 个 <code>sa</code> 的授权文件下载到 <code>/root/AutoRclone/accounts</code> 文件夹内</p>
<p>已经存在项目，需要创建新的项目新的 sa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 gen_sa_accounts.py --quick-setup 1 --new-only</span><br></pre></td></tr></table></figure>

<p>创建 <code>1</code> 个新项目、每个项目创建 100 个 <code>sa</code>，开启相关的服务、将 100 个 <code>sa</code> 的授权文件下载到 <code>/root/AutoRclone/accounts</code> 文件夹内</p>
<p>提示：把代码里面的 1 改为 2 或 3；则会分别创建 1，2，3个项目；100，200，300个服务账号，以此类推</p>
<p>在已有的项目上来创建 sa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 gen_sa_accounts.py --quick-setup -1</span><br></pre></td></tr></table></figure>

<p>注意：这会创建新的 <code>sa</code> 并替换掉账户里已有的全部项目的 <code>sa</code></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>方法一，因为我们之前在创建 <code>credentials.json</code> 文件的时候，我们其实就已经创建了一个叫 <code>Quickstart</code> 的项目，所以不存在账号里没有项目的情况</p>
<p>方法三，在已有项目中创建新的 <code>SA</code> 替换掉原先的 <code>SA</code> ，但是我实践发现这样创建的 <code>SA</code> 存在不能自动下载到 <code>/root/AutoRclone/accounts</code> 文件夹的情况；并且这种方法会替换掉账户里所有项目的 <code>SA</code></p>
<p>建议使用方法二，创建新的项目新的 <code>sa</code> ，但是这种方法如果你的账号项目超出 10 个，并且你重新申请项目额度后也会出现不能创建新项目的情况，这跟程序有关；查看自己有多少项目就是进入到 <code>google api</code> 点击全部项目进行查看</p>
<p>这里以第二种方法为例，输入代码开始创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; cd /root/AutoRclone</span><br><span class="line"></span><br><span class="line">python3 gen_sa_accounts.py --quick-setup 1 --new-only</span><br></pre></td></tr></table></figure>

<p>复制网址粘贴到浏览器打开授权，将网页生成的代码粘贴到 <code>SSH</code> 中回车</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hMCr.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hxSI.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h5qC.png" alt="img"></p>
<p>出现这个页面，表示创建成功，进入 <code>/root/AutoRclone/accounts</code> 文件夹会发现这里面有 100 个服务账号，在回到 <code>google api</code> ，点击项目、点击全部，会发现账户里多了一个项目，这个项目就是我们刚才新建立的，进入这个项目，这时可以看到很多账号里面有 100 个服务账号</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/huFJ.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hHY8.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hRdK.png" alt="img"></p>
<p>创建不成功，请自己查看提示，在结合本文提示进行寻找原因</p>
<blockquote>
<p>安装 gd-utils</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; git clone https://github.com/iwestlin/gd-utils &amp;&amp; cd gd-utils</span><br><span class="line"></span><br><span class="line">npm install --unsafe-perm=true --allow-root</span><br></pre></td></tr></table></figure>

<p>运行中没有报错且 <code>/root/gd-utils</code> 文件内有内容，则为安装成功</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hdip.png" alt="img"></p>
<p>如果遇到这种情况，按照图示运行代码 <code>npm audit fix</code> 即可</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/20/4MEQ.png" alt="img"></p>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>把 <code>/root/AutoRclone/accounts</code> 文件夹下的 <code>100</code> 个<code>sa</code>账号，上传到 <code>/root/gd-utils</code> 文件的 <code>sa</code> 目录下</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hU6a.png" alt="img"></p>
<blockquote>
<p>给 sa 添加访问云盘的权限</p>
</blockquote>
<hr>
<p>**方法一：创建一个 Google Groups 群组，然后将这些 <code>sa</code> 添加为群组 *<em>成员*<em>，最后将群组的电子邮箱地址添加为云盘的成员，权限是内容管理员</em></em></p>
<hr>
<p>打开<a href="https://groups.google.com/">谷歌网上论坛</a>，登陆自己账号切换到新版网上论坛，点击左上角的 <strong>创建群组</strong> ，然后输入自己群组名称和电子邮件地址，创建群组，<strong>记下自己 <code>Google Groups</code> 群组的电子邮箱地址</strong></p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>不要把自己的谷歌邮箱添加到群组成员里，因为谷歌群组每 24 小时只能添加 100 个成员，添加自己邮箱会占用一个额度导致 100 个 <code>sa</code> 只能添加 99 个，在下面检测 <code>sa</code> 的可用性时，会出现一个 <code>sa</code> 为无效的情况</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hVxk.png" alt="img"></p>
<p>本地新建一个文件夹，将 <code>/root/AutoRclone/accounts</code> 文件内所有的服务账号下载到本地新建的文件夹内，你可以使用 <code>WinSCP</code> 或者 <code>FinalShel</code> ；注意下载不要下载 <code>.keep</code> 这个文件</p>
<p>点击下方本地下载下载 <strong>谷歌SA邮箱提取.exe</strong> ，这是批量提取谷歌服务账号的工具，方便我们把账号添加到 <code>Google Groups</code>；将下载的工具和下载的<code>sa</code>账号放在同一个文件夹内</p>
<p>运行<code>谷歌SA邮箱提取.exe</code>，然后这个工具会生成一个 <code>user.txt</code> 文件夹，打开这个文件夹将提取出来的账号分成 <code>10</code> 份</p>
<p>打开网上论坛，点击左边我的群组，点开我的群组，点击成员，添加成员，将分好的服务账号添加到群组成员里面，需要 10 次才能添加完成；添加完成后，论坛里应该有 101 位成员</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/herf.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意，谷歌网上论坛每次只能添加10个，每24小时，只能添加100个</span><br></pre></td></tr></table></figure>

<p><a href="https://yygt.lanzous.com/iI4qae85ure"> 本地下载</a></p>
<p>然后打开谷歌云盘，点击自己的共享盘，点击管理成员，添加用户和群组，将<code>Google Groups</code> 的群组电子邮箱地址添加为云盘成员，成员权限是内容管理员</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hpNm.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hvSi.png" alt="img"></p>
<p>这个时候，云盘应该是 <strong>1个群组.1人</strong></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/20/47K3.png" alt="img"></p>
<blockquote>
<p>检验这些 <code>sa</code> 是否有权限</p>
</blockquote>
<h3 id="为什么要检验服务账号-SA-的权限"><a href="#为什么要检验服务账号-SA-的权限" class="headerlink" title="为什么要检验服务账号 SA 的权限"></a>为什么要检验服务账号 SA 的权限</h3><p>通过上面的方法给 <code>sa</code> 添加访问云盘的权限后，如果不检测<code>sa</code>，不把无效 <code>SA</code> 剔除时，有时则会遇到任务异常中断、命令行日志无限循环输出但进度不变、复制完发现丢文件等情况；在进行复制时，需要向 <code>Google</code> 的服务器提交要复制的文件 <code>ID</code> 和复制的位置，也就是新创建的目录 <code>ID</code> ，由于在请求时是随机选取的 <code>sa</code> ，所以当选中没有权限的 <code>sa</code> 时，这次拷贝请求没有对应目录的权限，就会发生这些错误，所以需要检测</p>
<p>执行代码检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; cd /root/gd-utils</span><br><span class="line"></span><br><span class="line">./validate-sa.js 你的谷歌云盘ID</span><br></pre></td></tr></table></figure>


<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hJG4.png" alt="img"></p>
<p>谷歌云盘 <code>ID</code> 要选择你添加<code>sa</code>所在的云盘 <code>ID</code>，程序会读取 <code>sa</code> 目录下所有 <code>json</code> 文件，依次检查它们是否拥有对你的目录云盘 <code>ID</code> 的阅读权限；如果最后发现了无效的 <code>sa</code> ，程序会提供选项让用户选择，出现下面的提示则说明 <code>sa</code> 都有权限</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hXY9.png" alt="img"></p>
<hr>
<p><strong>方法二：直接将这些 <code>sa</code> 添加为谷歌云盘成员</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; cd /root/AutoRclone</span><br><span class="line"></span><br><span class="line">python3 add_to_team_drive.py -d 0AJuS7AAmub3BUk9PVA    0AJuS7AAmub3BUk9PVA 为自己云盘ID</span><br></pre></td></tr></table></figure>

<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hnfT.png" alt="img"></p>
<p><strong>此时我们打开谷歌云盘，找到这个页面，我一下云盘里面是不是多了我们刚才添加的 <code>SA</code></strong></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hriQ.png" alt="img"></p>
<p><strong>检验这些 <code>sa</code> 是否有权限，检验方法跟上面的检验方法是一样的</strong></p>
<blockquote>
<p>配置 rclone 挂载团队盘</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone config</span><br><span class="line"></span><br><span class="line">No remotes found - make a new one</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">n/s/q&gt; n</span><br><span class="line">name&gt; gd</span><br></pre></td></tr></table></figure>

<p>给你的团队盘起一个名字，英文字符，我这里以 <code>gd</code> 为例，然后下一步会让你选择云盘种类，选择谷歌云盘的代号回车，一般是 13 左右；接着输入 <strong>client_id</strong> 和<strong>client_secret</strong>,这分别是 <code>api</code> 的 <code>ID</code> 和密钥</p>
<p>打开 <code>google api</code> ，左上角选择最开始创建的项目，一般是 <code>Quickstart</code> ，按图示操作</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h96X.png" alt="img"></p>
<p>点开后，右边就是我们的 <strong>client_id</strong> 和 <strong>client_secret</strong></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hZ5j.png" alt="img"></p>
<p>根据提示，输入到 SSH 中，下一步选择 <strong>1</strong></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hAry.png" alt="img"></p>
<p><strong>root_folder_id</strong> 和 <strong>service_account_file</strong> 这两个可以直接回车，下面两个选择都选 <strong>N</strong>，之后会生成一个链接粘贴到浏览器中，登陆自己的谷歌账号授权，将生成的 <strong>代码</strong> 复制到 <code>SSH</code> 中回车，详细操作请看图</p>
<p><strong>这里有一点需要注意</strong>，配置到这一步时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configure this as a team drive?</span><br><span class="line">y) Yes</span><br><span class="line">n) No</span><br><span class="line">y/n&gt; n</span><br></pre></td></tr></table></figure>

<p>系统询问你是要挂载团队云盘还是挂载你个人的云盘，选 <code>y</code> 就是挂载团队云盘(前提你账户里面有团队云盘)，选 <code>n</code> 就是挂载个人云盘，但是不管是选 <code>y</code> 还是选 <code>n</code> ，我们在下面的步骤中运行 node check.js 代码检查服务器的联通情况时，返回的都是个人云盘内容</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hPNv.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hljc.png" alt="img"></p>
<p>然后将以下信息记录下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[gd]</span><br><span class="line">type = drive</span><br><span class="line">client_id = 959724asinf35vl.apps.googleusercontent.com</span><br><span class="line">client_secret = V7Rz-b6iZ7bUoXiF</span><br><span class="line">scope = drive</span><br><span class="line">token = &#123;&quot;access_token&quot;:&quot;ya29.a0AfH6SMDy-hDacbkL8w3DaT_dhrZeVjGEtfb8KmZ9Xg4S7ECLNKRJ_HYU0ndWngegJR7PcgktASdPaDsupEmqweDBoZXCtRmzIclB4EMxS5KAB99yHny_IeusrcaVVAgQG2v2R59CdWfnw&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;refresh_token&quot;:&quot;1//0dQ_xB5KS9KejCgYIARAAGA0SNwF-L9IruF5Fg4pB8vwF2UOFeIrq1AiBEs&quot;,&quot;expiry&quot;:&quot;2020-08-22T03:51:25.629822745-07:00&quot;&#125;</span><br><span class="line">team_drive = 0AL5v92JLPVA</span><br></pre></td></tr></table></figure>


<p>其中 <code>client_id</code> 和 <code>client_secret</code> 是客户端的 <code>ID</code> 和密钥</p>
<p><code>token</code> 是 <code>rclone</code> 连接云盘生成的值，这个值我们只取 <code>refresh_toke</code> 这一部分，即 <code>1//</code> 后面的内容，类似于这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1//0dQ_xB5KS9KejCgYIARAAGA0SNwF-L9IruF5Fg4pB8vwF2UOFeIrq1AiBEs</span><br><span class="line">team_drive` 是团队盘的 `ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置 config.js</p>
</blockquote>
<p>编辑 <code>/root/gd-utils/config.js</code> 文件，将刚才记录的 <code>client_id</code>、<code>client_secret</code>、<code>refresh_token</code>、<code>TARGET</code>、<code>tg_token</code> 、控制机器人的 <code>tg</code> 用户名填入到对应的位置</p>
<p>也可以运行命令 <code>rclone config file</code> 找到 <code>rcone</code> 的配置文件，在配置文件中找到信息</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/20/4Sb4.png" alt="img"></p>
<p>填写完成后保存，运行代码检查有没有连接上云盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; cd /root/gd-utils</span><br><span class="line"></span><br><span class="line">node check.js</span><br></pre></td></tr></table></figure>

<p>如果你的云盘内没有文件输出的是 <code>[]</code> ，有文件输出文件信息；如果你的云盘有文件还是输出 <code>[]</code> 或者有其它报错，则没有连接上云盘，需检查配置；建议个人云盘和团队云盘都放入内容测试</p>
<blockquote>
<p>使用宝塔安装 PM2 和 Nginx</p>
</blockquote>
<p>宝塔安装完成后，点击宝塔左边软件商店，搜索 <strong>PM2</strong> 和 <strong>Nginx</strong> 这两个软件安装，安装完成后，这个时候建议重启一下服务器，重启之后运行代码；而且每次重启后都要运行一次代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; cd /root/gd-utils</span><br><span class="line"></span><br><span class="line">pm2 start server.js --node-args=&quot;--max-old-space-size=1024&quot;</span><br></pre></td></tr></table></figure>


<p>然后进入宝塔在已安装的软件中找到 <code>PM2</code> 管理器，查看一下是否有任务运行；如果有任务运行直接添加站点，如果没有则手动添加任务，手动添加方法如下；最后记住一定要开放 23333 端口</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/20/42zT.png" alt="img"></p>
<p>手动添加 <code>PM2</code> 任务</p>
<p>项目所在根目录选择 <code>gd-utils</code> 所在路径，启动文件名称为 <code>server.js</code> ，项目名称随意，根据图示填写</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hBGV.png" alt="img"></p>
<p>然后点击宝塔安全，放行<strong>23333</strong>端口，注意放行 23333 端口后端口是否是正常状态，如果不是，则说明上一步配置的 <code>server.js</code> 运行失败；如果厂商自带的有防火墙或者自己服务器本地设置了防火墙，请自行排查 <code>23333</code> 端口是否开放</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/20/4jU9.png" alt="img"></p>
<p>在宝塔里添加站点，域名是解析到服务器的域名；添加成功后，给网站申请 <code>SSL</code> 证书，开启强制 <code>HTTPS</code></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hFfz.png" alt="img"></p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hGlR.png" alt="img"></p>
<p>打开自己的网站，如果出现下面的页面，说明网站设置正确</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hLEE.png" alt="img"></p>
<p>设置反向代理</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hy5A.png" alt="img"></p>
<p>再次打开网站，打开网站后如果网页只在左上角显示 <code>not found</code> 字样时，说明反代配置成功</p>
<p>回到SSH，执行下面代码以命令行的形式检查网站是否部署成功；代码一定要检查清楚，网址不能多 <code>/</code> ，字符不能少，请严格参考示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; cd /root/gd-utils</span><br><span class="line">curl &#x27;YOUR_WEBSITE_URL/api/gdurl/count?fid=124pjM5LggSuwI1n40bcD5tQ13wS0M6wg&#x27;</span><br><span class="line">示例</span><br><span class="line">curl &#x27;https://bot.54215.tk/api/gdurl/count?fid=124pjM5LggSuwI1n40bcD5tQ13wS0M6wg&#x27;</span><br><span class="line"></span><br><span class="line">如果返回了gd-utils 成功启动的消息，说明部署成功了</span><br></pre></td></tr></table></figure>


<p>在命令行执行（请将 <code>YOUR_WEBSITE</code> 和 <code>YOUR_BOT_TOKEN</code> 分别替换成你自己的网址和 <code>bot token</code>），将你的服务器连接上你的 <code>telegram bot</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -F &quot;url=YOUR_WEBSITE/api/gdurl/tgbot&quot; &#x27;https://api.telegram.org/botYOUR_BOT_TOKEN/setWebhook&#x27;</span><br><span class="line">示例</span><br><span class="line">curl -F &quot;url=https://bot.54215.tk/api/gdurl/tgbot&quot; &#x27;https://api.telegram.org/bot1240808718:AAHupIg5gpMrMiDmGSh5b5-nlqi5uRvXQTw/setWebhook&#x27;</span><br></pre></td></tr></table></figure>

<p>如果返回 <code>&#123;&quot;ok&quot;:true,&quot;result&quot;:true,&quot;description&quot;:&quot;Webhook was set&quot;&#125;</code> ，则说明你的服务器连接上你的 <code>telegram bot</code> 了，给自己的电报机器人发送 <code>/help</code>，如果它回复给你 <strong>使用帮助</strong>，那就配置成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：给机器人发送消息时，一般立刻就会回复信息，如果没有回复信息，可能会有延迟请稍等几分钟，或者重启一下服务器在试，如果还不行，请检查配置</span><br></pre></td></tr></table></figure>


<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/h0t5.png" alt="img"></p>
<p>这个时候，我们向机器人发送一条谷歌云盘的分享链接，机器人会识别这个链接，提示我们选择动作，点击复制它会立刻开始复制到我们设置的云盘里</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hQjr.png" alt="img"></p>
<p>当机器人提示复制成功后，我们打开我们的谷歌云盘，发现我们的云盘里已经有了一个同名的文件夹</p>
<p><img src="https://ttc.cxbc.xyz/images/2020/09/13/hswI.png" alt="img"></p>
<p>参考：</p>
<p><a href="https://github.com/iwestlin/gd-utils">https://github.com/iwestlin/gd-utils</a></p>
<p><a href="https://github.com/iwestlin/gd-utils/blob/master/changelog.md">https://github.com/iwestlin/gd-utils/blob/master/changelog.md</a></p>
<p><a href="https://kkdfxz.gitbook.io/fx/jiao-cheng-zhong-xin/drive750g">https://kkdfxz.gitbook.io/fx/jiao-cheng-zhong-xin/drive750g</a></p>
<p><a href="https://blog.jialezi.net/?post=153">https://blog.jialezi.net/?post=153</a></p>
<p><a href="https://pastebin.com/h89ZkD6t">https://pastebin.com/h89ZkD6t</a></p>
<p><a href="https://www.youtube.com/watch?v=EnNgRLQAaGU&amp;t=17s">https://www.youtube.com/watch?v=EnNgRLQAaGU&amp;t=17s</a></p>
<p><a href="https://www.youtube.com/watch?v=EJMZCnGIEVY&amp;t=1548s">https://www.youtube.com/watch?v=EJMZCnGIEVY&amp;t=1548s</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>google drive</tag>
        <tag>转存</tag>
      </tags>
  </entry>
  <entry>
    <title>Seafile免费同步云盘安装与使用-自建私有云盘 打造个人云存储系统</title>
    <url>/posts/60716/</url>
    <content><![CDATA[<p>打造个人云存储系统首选的就是<a href="https://wzfou.com/tag/nextcloud/">NextCloud</a>了，安装和配置都非常简单，同时有着非常丰富的插件，利用这些插件可以满足不同的人对网盘应用的需要，例如在线编辑Office文档、播放视频音乐、网络相册以及在不同的设备之间同步文件等等。</p>
<p>有人说NextCloud在加密传输方面有待改进，其中最新的<a href="https://wzfou.com/tag/nextcloud/">NextCloud</a>已经支持服务器端加密存储和设备之间端对端加密传输了，NextCloud在安全性与易用性这两块已经做到了同类产品的前沿了。今天要分享的Seafile，是一个与NextCloud类似的云存储系统。</p>
<p><a href="https://wzfou.com/tag/seafile/">Seafile</a>有一个大的优势在于采取的是文件分块机制，它将你的文件分成一定的大小，使大文件变成多个小文件进行储存。虽然不能直接读取服务器上的文件，但带来的新特性就是可以进行增量同步，加密文件的同步变得非常容易。Seafile对于上传大批量文件和超大文件是有优势的。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_00.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_00.png"></p>
<p>本文就来分享一下<a href="https://wzfou.com/tag/seafile-install/">Seafile安装</a>与使用图文教程，更多的自建存储服务以及网盘系统还有：</p>
<ol>
<li><a href="https://wzfou.com/nextcloud-install/">手动安装NextCloud教程-免费开源的私有云存储网盘可播放图片音乐</a></li>
<li><a href="https://wzfou.com/onelist/">简洁响应快的Onelist+Onedrive搭建免费在线图片视频网盘-配置CDN</a></li>
<li><a href="https://wzfou.com/bitwarden-rs/">放弃付费1Password改用免费开源的bitwarden_rs自建密码管理系统-安装,使用和备份</a></li>
<li><a href="https://wzfou.com/vestacp-whmcs/">VestaCP与WHMCS整合教程-实现自助开通虚拟主机销售主机空间产品</a></li>
<li><a href="https://wzfou.com/ispconfig-whmcs/">ISPConfig与WHMCS整合方法-自动激活开通虚拟主机和管理空间用户</a></li>
</ol>
<p><strong>PS：更新记录.</strong></p>
<blockquote>
<p>1、Cloudreve可快速对接七牛、又拍云、阿里云OSS、AWS S3、腾讯云COS、微软Onedrive等网盘，适合大容量存储需要的朋友：Cloudreve自建网盘系统-可预览Office文档对接七牛又拍云腾讯云COS。2021.1.6</p>
<p>2、最新的手动安装Nextcloud网盘的详细教程，请参考：<a href="https://wzfou.com/nextcloud-pan/">NextCloud安装和使用图文教程-同步网盘自动备份和在线播放视频</a>。2020.11.5</p>
</blockquote>
<h2 id="一、Seafile安装前准备"><a href="#一、Seafile安装前准备" class="headerlink" title="一、Seafile安装前准备"></a><strong>一、Seafile安装前准备</strong></h2><p>网站：</p>
<ol>
<li>官网：<a href="https://www.seafile.com/">https://www.seafile.com/</a></li>
<li>一键包：<a href="https://github.com/haiwen/seafile-server-installer-cn">https://github.com/haiwen/seafile-server-installer-cn</a></li>
</ol>
<h3 id="1-1-准备一台VPS"><a href="#1-1-准备一台VPS" class="headerlink" title="1.1 准备一台VPS"></a><strong>1.1 准备一台VPS</strong></h3><p>Seafile对VPS的配置要求稍微比NextCloud要高一些，建议1GB内存，一键安装包要求安装干净的 Ubuntu 16.04/18.04 或 CentOS 7/8 系统。关于VPS主机的选购参考：<a href="https://wzfou.com/vps-bangdan/">VPS主机排行榜单</a>。</p>
<h3 id="1-2-准备一个域名"><a href="#1-2-准备一个域名" class="headerlink" title="1.2 准备一个域名"></a><strong>1.2 准备一个域名</strong></h3><p>本步骤为可选项，不过如果打算长期使用Seafile的话，还是建议Seafile绑定域名，这样可以部署Https访问，提高安全性。关于域名的选购参考：<a href="https://wzfou.com/domain/">域名服务</a>。</p>
<h2 id="二、Seafile安装全过程"><a href="#二、Seafile安装全过程" class="headerlink" title="二、Seafile安装全过程"></a><strong>二、Seafile安装全过程</strong></h2><h3 id="2-1-一键快速安装"><a href="#2-1-一键快速安装" class="headerlink" title="2.1 一键快速安装"></a><strong>2.1 一键快速安装</strong></h3><p>本文使用的是Seafile官方提供的一键安装包，以帮助您快速的安装好 Seafile 服务器，并配置好 MariaDB, Memcached, WebDAV, Ngnix 和开机自动启动脚本。先安装干净的 Ubuntu 16.04/18.04 或 CentOS 7/8 系统，并<strong>做好镜像</strong> (如果安装失败需要还原到镜像)。</p>
<p>切换成 root 账号 (sudo -i)</p>
<p><strong>获取安装脚本：</strong></p>
<p>适用于 Seafile 7.1.x 及以上版本</p>
<p>Ubuntu 18.04 (64bit):</p>
<p>wget <a href="https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-7.1-ubuntu-amd64-http">https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-7.1-ubuntu-amd64-http</a></p>
<p>CentOS 8 (64bit):</p>
<p>wget <a href="https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-7.1-centos-amd64-http">https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-7.1-centos-amd64-http</a></p>
<p>适用于 Seafile 6.x.x 及以上版本</p>
<p>Ubuntu 16.04/18.04 (64bit):</p>
<p>wget <a href="https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-ubuntu-amd64-http">https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-ubuntu-amd64-http</a></p>
<p>CentOS 7 (64bit):</p>
<p>wget <a href="https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-centos-7-amd64-http">https://raw.githubusercontent.com/haiwen/seafile-server-installer-cn/master/seafile-server-centos-7-amd64-http</a></p>
<p>运行安装脚本并指定要安装的版本 (例如 7.1.5)</p>
<p>Ubuntu 18.04 (64bit):</p>
<p>bash seafile-server-7.1-ubuntu-amd64-http 7.1.5</p>
<p>CentOS 8 (64bit):</p>
<p>bash seafile-server-7.1-centos-amd64-http 7.1.5</p>
<p>脚本会让您选择要安装的版本, 按照提示进行选择即可:</p>
<blockquote>
<p>如果要安装专业版, 需要先将下载好的专业版的包 seafile-pro-server_6.0.13_x86-64.tar.gz 放到 /opt/ 目录下</p>
<p>如果是安装开源版，安装脚本在执行过程中会检查 <code>/opt</code>目录下是否有指定版本号的安装包，如果存在则会安装此包，否则会从 Seafile 网站下载。所以，为了避免因下载失败而导致安装中断，您可以提前下载好安装包放到<code>/opt/</code>目录下。</p>
</blockquote>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_01.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_01.png"></p>
<p>该脚本运行完后会在命令行中打印配置信息，请仔细阅读，MySQL 的 root 用户密码存储在 <code>/root/.my.cnf</code> 中；MySQL 的 seafile 用户密码存储在 <code>/opt/seafile.my.cnf</code> 中。</p>
<p>安装完成如下：</p>
<p>verifying password <strong>of</strong> user root …</p>
<p>verifying password <strong>of</strong> user root …  done</p>
<hr>
<p><strong>This</strong> is your configuration</p>
<hr>
<p>server name:            seafile</p>
<p>server ip/domain:       127.0.0.1</p>
<p>seafile data dir:       /opt/seafile/seafile-data</p>
<p>fileserver port:        8082</p>
<p>database:               create <strong>new</strong></p>
<p>ccnet database:         ccnet_db</p>
<p>seafile database:       seafile_db</p>
<p>seahub database:        seahub_db</p>
<p>database user:          seafile</p>
<p>Generating ccnet configuration …</p>
<p>done</p>
<p>Successly create configuration dir /opt/seafile/ccnet.</p>
<p>Generating seafile configuration …</p>
<p>Done.</p>
<p>done</p>
<p>Generating seahub configuration …</p>
<hr>
<p>Now creating ccnet database tables …</p>
<hr>
<hr>
<p>Now creating seafile database tables …</p>
<hr>
<hr>
<p>Now creating seahub database tables …</p>
<hr>
<p>creating seafile-server-latest symbolic link …  done</p>
<hr>
<p>Your seafile server configuration has been finished successfully.</p>
<hr>
<p>run seafile server:     ./seafile.sh { start | stop | restart }</p>
<p>run seahub  server:     ./seahub.sh  { start <port> | stop | restart <port> }</p>
<hr>
<p><strong>If</strong> you are behind a firewall, remember to allow input/output <strong>of</strong> these tcp ports:</p>
<hr>
<p>port <strong>of</strong> seafile fileserver:   8082</p>
<p>port <strong>of</strong> seahub:               8000</p>
<p>When problems occur, Refer to</p>
<p><a href="https://download.seafile.com/published/seafile-manual/home.md">https://download.seafile.com/published/seafile-manual/home.md</a></p>
<p><strong>for</strong> information.</p>
<p>[09/24/20 22:08:38] ../common/session.c(148): using config file /opt/seafile/conf/ccnet.conf</p>
<p>Starting seafile server, please wait …</p>
<ul>
<li><ul>
<li>Message: 22:08:38.053: seafile-controller.c(572): No seafevents.</li>
</ul>
</li>
</ul>
<p>Seafile server started</p>
<p>Done.</p>
<p>LC_ALL is not set <strong>in</strong> ENV, set to en_US.UTF-8</p>
<p>Starting seahub at port 8000 …</p>
<hr>
<p>Successfully created seafile admin</p>
<hr>
<p>Seahub is started</p>
<p>Done.</p>
<p>Stopping seahub …</p>
<p>Done.</p>
<p>Stopping seafile server …</p>
<p>Done.</p>
<h3 id="2-2-启动关闭服务"><a href="#2-2-启动关闭服务" class="headerlink" title="2.2 启动关闭服务"></a><strong>2.2 启动关闭服务</strong></h3><p>自动安装脚本会在系统中安装开机自动启动脚本。您也可以使用该脚本来关闭/启动 Seafile 服务，命令如下：</p>
<p>Ubuntu 16.04/18.04:</p>
<p>service seafile-server stop</p>
<p>service seafile-server start</p>
<p>CentOS 7/8:</p>
<p>systemctl stop seafile</p>
<p>systemctl stop seahub</p>
<p>systemctl start seafile</p>
<p>systemctl start seahub</p>
<h3 id="2-3-配置SMTP"><a href="#2-3-配置SMTP" class="headerlink" title="2.3 配置SMTP"></a><strong>2.3 配置SMTP</strong></h3><p>邮件提醒会使某些功能有更好的用户体验, 比如发送邮件提醒用户新消息到达. 请在<code>seahub_settings.py</code>中加入以下语句以开启邮件提醒功能 (同时需要对你的邮箱进行设置).</p>
<p>EMAIL_USE_TLS = <strong>False</strong></p>
<p>EMAIL_HOST = ‘<a href="http://smtp.domain.com/">smtp.domain.com</a>‘        # smpt 服务器</p>
<p>EMAIL_HOST_USER = ‘<a href="mailto:&#x75;&#x73;&#101;&#x72;&#110;&#x61;&#109;&#x65;&#64;&#x64;&#111;&#x6d;&#x61;&#105;&#110;&#x2e;&#99;&#111;&#109;">&#x75;&#x73;&#101;&#x72;&#110;&#x61;&#109;&#x65;&#64;&#x64;&#111;&#x6d;&#x61;&#105;&#110;&#x2e;&#99;&#111;&#109;</a>‘    # 用户名和域名</p>
<p>EMAIL_HOST_PASSWORD = ‘password’    # 密码</p>
<p>EMAIL_PORT = ‘25’</p>
<p>DEFAULT_FROM_EMAIL = EMAIL_HOST_USER</p>
<p>SERVER_EMAIL = EMAIL_HOST_USER</p>
<p>Gmail 邮箱示例:</p>
<p>EMAIL_USE_TLS = <strong>True</strong></p>
<p>EMAIL_HOST = ‘<a href="http://smtp.gmail.com/">smtp.gmail.com</a>‘</p>
<p>EMAIL_HOST_USER = ‘<a href="mailto:&#x75;&#x73;&#101;&#114;&#x6e;&#x61;&#x6d;&#x65;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x75;&#x73;&#101;&#114;&#x6e;&#x61;&#x6d;&#x65;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a>‘</p>
<p>EMAIL_HOST_PASSWORD = ‘password’</p>
<p>EMAIL_PORT = ‘587’</p>
<p>DEFAULT_FROM_EMAIL = EMAIL_HOST_USER</p>
<p>SERVER_EMAIL = EMAIL_HOST_USER</p>
<h2 id="三、Seafile配置与使用"><a href="#三、Seafile配置与使用" class="headerlink" title="三、Seafile配置与使用"></a><strong>三、Seafile配置与使用</strong></h2><h3 id="3-1-修改密码"><a href="#3-1-修改密码" class="headerlink" title="3.1 修改密码"></a><strong>3.1 修改密码</strong></h3><p>打开你的IP地址，现在你可以看到Seafile登录界面了。如果是502错误，说明你的Seafile没有启动，执行命令：<code>service seafile-server start</code></p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_02.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_02.png"></p>
<p>修改Seafile管理员账号和密码。执行以下命令：</p>
<p>cd /opt/seafile/seafile-server-7.1.5</p>
<p>./reset-admin.sh</p>
<p>然后输入邮箱和账号，添加一个管理员账号和密码。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_03.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_03.png"></p>
<h3 id="3-2-基本设置"><a href="#3-2-基本设置" class="headerlink" title="3.2 基本设置"></a><strong>3.2 基本设置</strong></h3><p>这个是Seafile的界面，比较干净简洁。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_04.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_04.png"></p>
<p>打开<strong>个人设置</strong>页面，可以设置头像、邮箱和密码等。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_05.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_05.png"></p>
<p>进入<strong>系统设置</strong>页面填写正确的服务器对外的 SERVICE_URL 和 FILE_SERVER_ROOT，比如</p>
<p>SERVICE_URL: <a href="http://www.myseafile.com/">http://www.myseafile.com</a></p>
<p>FILE_SERVER_ROOT: ‘<a href="http://www.myseafile.com/seafhttp&#39;">http://www.myseafile.com/seafhttp&#39;</a></p>
<p>现在您可以退出管理员界面，并进行基本的测试。关于服务器的配置选项介绍和日常运维可以参考 <a href="https://cloud.seafile.com/published/seafile-manual-cn/config/README.md">https://cloud.seafile.com/published/seafile-manual-cn/config/README.md</a></p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_06.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_06.png"></p>
<p>用户管理中可以开启注册</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_07.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_07.png"></p>
<p>以及删除原有的用户。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_08.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_08.png"></p>
<h3 id="3-3-图片相册"><a href="#3-3-图片相册" class="headerlink" title="3.3 图片相册"></a><strong>3.3 图片相册</strong></h3><p>Seafile新建资料库。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_09.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_09.png"></p>
<p>然后就是批量上传图片了。（点击放大）</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_10.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_10.png"></p>
<p>Seafile支持图片幻灯片浏览。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_11.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_11.png"></p>
<p>你也可以给文件设置共享权限。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_12.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_12.png"></p>
<h3 id="3-4-视频播放"><a href="#3-4-视频播放" class="headerlink" title="3.4 视频播放"></a><strong>3.4 视频播放</strong></h3><p>Seafile可以对视频进行在线播放。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_14.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_14.png"></p>
<h2 id="四、Seafile激活Https访问"><a href="#四、Seafile激活Https访问" class="headerlink" title="四、Seafile激活Https访问"></a><strong>四、Seafile激活Https访问</strong></h2><p>按照上面的方法，做好域名DNS解析，同时绑定好域名。打开Seafile的Nginx配置文件，如下图，将里面的网址替换为你的域名。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_15.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_15.png"></p>
<p>现在使用以下命令在Ubuntu安装Certbot ACME client：</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install software-properties-common</p>
<p>sudo add-apt-repository ppa:certbot/certbot</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install python-certbot-nginx</p>
<p>现在你可以给你的Nginx自动安装和配置<a href="https://wzfou.com/letsencrypt/">letsencrypt免费SSL证书</a>了：</p>
<p>sudo certbot –nginx</p>
<p>如果你只想申请SSL证书，使用以下命令：</p>
<p>sudo certbot –nginx certonly</p>
<p>Seafile激活Https访问如下图：</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_16.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_16.png"></p>
<h2 id="五、Seafile同步盘使用"><a href="#五、Seafile同步盘使用" class="headerlink" title="五、Seafile同步盘使用"></a><strong>五、Seafile同步盘使用</strong></h2><h3 id="5-1-PC电脑端同步"><a href="#5-1-PC电脑端同步" class="headerlink" title="5.1 PC电脑端同步"></a><strong>5.1 PC电脑端同步</strong></h3><p>下载安装Seafile的PC电脑端，先添加你的Seafile服务器址、账号和密码。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_18.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_18.png"></p>
<p>这是Seafile的电脑端界面。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_20.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_20.png"></p>
<p>你可以选择是否同步文件到本地。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_19.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_19.png"></p>
<p>Seafile用作同步网盘还是非常不错的，各种功能都非常地全。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_21.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_21.png"></p>
<h3 id="5-2-手机APP同步"><a href="#5-2-手机APP同步" class="headerlink" title="5.2 手机APP同步"></a><strong>5.2 手机APP同步</strong></h3><p>安装了Seafile手机APP后，先添加Seafile的服务器地址、账号和密码。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_24.jpg" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_24.jpg"></p>
<p>这个就是Seafile的手机APP界面了。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_25.jpg" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_25.jpg"></p>
<p>这是Seafile手机APP相关的设置选项。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_26.jpg" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_26.jpg"></p>
<h2 id="六、Seafile备份与恢复"><a href="#六、Seafile备份与恢复" class="headerlink" title="六、Seafile备份与恢复"></a><strong>六、Seafile备份与恢复</strong></h2><p>关于<a href="https://wzfou.com/tag/seafile-beifen/">Seafile备份</a>与恢复，官方的说明太麻烦了，其实Seafile所有的数据都放在了opt这个目录下了，你要做的就是备份这个文件夹就行了。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_13.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_13.png"></p>
<h3 id="6-1-定时打包备份"><a href="#6-1-定时打包备份" class="headerlink" title="6.1 定时打包备份"></a><strong>6.1 定时打包备份</strong></h3><p>关于在VPS主机上打包备份的教程，你可以参考：<a href="https://wzfou.com/vps-one-backup/">一个命令让Linux定时打包备份指定目录文件夹并同步备份到各大网盘</a>。</p>
<p>首先在根目录下新建back文件夹，然后使用以下命令将opt下的所有文件打包，放在back文件夹当中，同时添加好时间节，以便于区分。</p>
<p>tar -czvf /backup/backup$(date +%Y%m%d%H%M).tar.gz  /opt</p>
<p>测试没有问题的话，添加定时任务，以下为每天凌晨1：10执行一次打包备份任务。有关于定时任务更多的说明，请参考：<a href="https://wzfou.com/crontab/">Linux Crontab命令定时任务基本语法与操作教程-VPS/服务器自动化</a>。</p>
<p>10 1 * * * tar -czvf /backup/backup$(date +%Y%m%d%H%M).tar.gz  /opt</p>
<h3 id="6-2-同步到各大网盘"><a href="#6-2-同步到各大网盘" class="headerlink" title="6.2 同步到各大网盘"></a><strong>6.2 同步到各大网盘</strong></h3><p>将打包好的文件同步到各大网盘，例如onedrive、谷歌网盘、阿里云OSS、腾讯云COS、WebDAV、FTP等，推荐使用Rclone，使用方法参考：</p>
<blockquote>
<p>1.VPS挂载国内外网盘实现免费扩容工具:Rclone,COS-Fuse和OSSFS</p>
</blockquote>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a><strong>七、总结</strong></h2><p>打开Seafile的存储目录，你可以看到你上传的文件已经被Seafile切割成块来存储了，所以你不用担心数据的安全性，即使服务器被人入侵也不用担心数据被人窃取。</p>
<p><img src="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_23.png" alt="https://wzfou.cdn.bcebos.com/wp-content/uploads/2020/09/Seafile_23.png"></p>
<p>Seafile是一个非常优秀的国产网盘程序，也特别适合给人搭建私有云存储系统，但是Seafile相对于NextCloud来说，文档说明不全，教程不完整，插件几乎没有，比较适合有能力折腾的用户。</p>
<p>文章出自：<a href="https://wzfou.com/">挖站否</a> <a href="https://wzfou.com/seafile-yunpan/%EF%BC%8C%E7%89%88%E6%9D%83%E6%89%80%E6%9C%89%E3%80%82%E6%9C%AC%E7%AB%99%E6%96%87%E7%AB%A0%E9%99%A4%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E5%A4%96%EF%BC%8C%E7%9A%86%E4%B8%BA%E4%BD%9C%E8%80%85%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8F%AF%E8%87%AA%E7%94%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BD%86%E8%AF%B7%E6%B3%A8%E6%98%8E%E6%9D%A5%E6%BA%90%E3%80%82">https://wzfou.com/seafile-yunpan/，版权所有。本站文章除注明出处外，皆为作者原创文章，可自由引用，但请注明来源。</a></p>
]]></content>
      <tags>
        <tag>免费</tag>
        <tag>自建网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Heroku搭建V2ray教程</title>
    <url>/posts/60038/</url>
    <content><![CDATA[<h1 id="注意：不要瞎搞！不要瞎搞！不要瞎搞！！！玩死了对大家都不好。"><a href="#注意：不要瞎搞！不要瞎搞！不要瞎搞！！！玩死了对大家都不好。" class="headerlink" title="注意：不要瞎搞！不要瞎搞！不要瞎搞！！！玩死了对大家都不好。"></a>注意：不要瞎搞！不要瞎搞！不要瞎搞！！！玩死了对大家都不好。</h1><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a><strong>必要条件</strong></h2><ol>
<li><a href="https://www.heroku.com/">Heruku</a> 账号</li>
<li>科学上网环境</li>
<li><a href="https://www.cloudflare.com/zh-cn/">Cloudflare</a> 账号 <strong>注意：所有教程类的文章，阅读的同时都需要考虑它的时效性。如果你部署过程遇到问题或者方法失效可留言讨论</strong>。</li>
</ol>
<p><strong>免费且高速！  最近速度只有1m/s左右，但也能满足日常需求，毕竟自行车还要啥轮子。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704133351.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704133351.png"></p>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a><strong>开始部署</strong></h2><blockquote>
<p>科学上网环境也许不是必要条件，主要是因为国内网络打开Heroku有点慢，所以有科学上网环境会使整个过程更加顺利一些。注册账号的过程不予截图展示，先去注册好账号再来操作。</p>
</blockquote>
<h3 id="打开项目"><a href="#打开项目" class="headerlink" title="打开项目"></a><strong>打开项目</strong></h3><p>首先，打开 <a href="https://github.com/w-gx/hkfqok">Github项目</a> 地址</p>
<p>将项目 fork 到自己的账号下。</p>
<p>修改<code>README.md</code> 文件，将部署链接修改为自己的项目。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/heroku/20210828132802.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/heroku/20210828132802.png"></p>
<p>修改后提交即可。</p>
<p>接下来，点击部署按钮即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704134010.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704134010.png"></p>
<p>对于刚注册的Heroku账户，会弹出服务协议页面，点击接受就好了。<strong>正确的页面如下图所示，如果点击接受之后没有出现下面这个界面，可以重新打开GitHub项目点击部署按钮进行尝试。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140120.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140120.png"></p>
<p><strong>此处的 APP name 在 Cloudflare 代理中还会用到，小白应该记住这个名字。当然了，这些信息其实都是可以查看的，熟练使用的话不需要刻意记。</strong></p>
<h3 id="生成UUID"><a href="#生成UUID" class="headerlink" title="生成UUID"></a><strong>生成UUID</strong></h3><ol>
<li><p>打开 V2rayN 客户端，点击<code>服务器</code>&gt;<code>添加VMess服务器</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140339.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140339.png"></p>
</li>
<li><p>点击<code>生成</code>按钮，记录用户ID并填入部署界面AUUID中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140610.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140610.png"></p>
</li>
</ol>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a><strong>部署</strong></h3><p>点击<code>Deploy app</code>按钮，如下显示即为部署成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140829.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704140829.png"></p>
<p>点击<code>Manage APP</code>，进入管理页面，点击<code>Setting</code>,可以查看APP的详细信息，在域名栏中可以看到自己的项目地址，点击这个地址跳转到部署的伪装网站中，伪装网站默认为 Caddy works！</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141229.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141229.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141310.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141310.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141344.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141344.png"></p>
<h2 id="Cloudflare-代理"><a href="#Cloudflare-代理" class="headerlink" title="Cloudflare 代理"></a><strong>Cloudflare 代理</strong></h2><ol>
<li><p>登录后点击 <code>Workers</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141830.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141830.png"></p>
</li>
<li><p>点击<code>创建Worker</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141927.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704141927.png"></p>
</li>
<li><p>在弹出页面中的脚本填入下面的代码，并按图示步骤操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const SingleDay = &#x27;应用程序名1.herokuapp.com&#x27;</span><br><span class="line">const DoubleDay = &#x27;应用程序名2.herokuapp.com&#x27;</span><br><span class="line">addEventListener(</span><br><span class="line">    &quot;fetch&quot;,event =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        let nd = new Date();</span><br><span class="line">        if (nd.getDate()%2) &#123;</span><br><span class="line">            host = SingleDay</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            host = DoubleDay</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let url=new URL(event.request.url);</span><br><span class="line">        url.hostname=host;</span><br><span class="line">        let request=new Request(url,event.request);</span><br><span class="line">        event. respondWith(</span><br><span class="line">            fetch(request)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704142810.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704142810.png"></p>
</li>
<li><p>获取新的代理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704143014.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704143014.png"></p>
</li>
</ol>
<p>上述代码实际上是对两个应用程序之间做了一个简单的负载均衡处理，单双号使用不同的应用程序上网。 <strong>截图中并没有这样处理。</strong> 建议使用这种负载均衡的方式运行程序，避免过度使用而造成封号。 具体方式为：</p>
<ol>
<li>按上述步骤再部署一个应用程序，需要注意使用相同的<strong>UUID</strong>和<strong>path</strong>！！！</li>
<li>代码中的 应用程序名1 和 应用程序名2 分别替换成两个不同的名称，点击部署即可。 下面提供一种多个程序做负载均衡的代码。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Day0 = &#x27;app0.herokuapp.com&#x27;</span><br><span class="line">const Day1 = &#x27;app1.herokuapp.com&#x27;</span><br><span class="line">const Day2 = &#x27;app2.herokuapp.com&#x27;</span><br><span class="line">const Day3 = &#x27;app3.herokuapp.com&#x27;</span><br><span class="line">const Day4 = &#x27;app4.herokuapp.com&#x27;</span><br><span class="line">addEventListener(</span><br><span class="line">    &quot;fetch&quot;,event =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        let nd = new Date();</span><br><span class="line">        let day = nd.getDate() % 5;</span><br><span class="line">        if (day === 0) &#123;</span><br><span class="line">            host = Day0</span><br><span class="line">        &#125; else if (day === 1) &#123;</span><br><span class="line">            host = Day1</span><br><span class="line">        &#125; else if (day === 2) &#123;</span><br><span class="line">            host = Day2</span><br><span class="line">        &#125; else if (day === 3)&#123;</span><br><span class="line">            host = Day3</span><br><span class="line">        &#125; else if (day === 4)&#123;</span><br><span class="line">            host = Day4</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            host = Day1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let url=new URL(event.request.url);</span><br><span class="line">        url.hostname=host;</span><br><span class="line">        let request=new Request(url,event.request);</span><br><span class="line">        event. respondWith(</span><br><span class="line">            fetch(request)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="客户端节点添加"><a href="#客户端节点添加" class="headerlink" title="客户端节点添加"></a><strong>客户端节点添加</strong></h2><p>以v2rayN客户端为例，添加VMess服务器， 信息填写如下图所示。 信息有所更改，注意下方的更正信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704144034.png" alt="https://cdn.jsdelivr.net/gh/wgx-dh/FAMED-Net/v2ray/20210704144034.png"></p>
<p>更正：</p>
<ol>
<li>上图中的 9 （path）填写 / 即可。</li>
<li>上图中的 4 （alterId）填写 64.</li>
</ol>
<p>速度挺快的，Youtube 1080p 轻松。缺点是不能上 Google 学术。流媒体我没测试，大概率应该也上不去。 建议作为备用节点，别把🐏薅死了，可能像 IBM Cloud 一样<strong>核平解决</strong>此事。</p>
]]></content>
      <tags>
        <tag>富强</tag>
        <tag>heroku</tag>
      </tags>
  </entry>
  <entry>
    <title>hostloc每日签到代码</title>
    <url>/posts/42327/</url>
    <content><![CDATA[<p>function load(i){var img=new Image();img.onerror=function(){img.onerror=null;console.log(“已访问”,i,”个MJJ的空间”);if(i&lt;10){load(i+1)}else{alert(“签到完毕”);return}};setTimeout(function(){img.src=”<a href="https://hostloc.com/space-uid-&quot;+(2000+i)+&quot;.html&quot;%7D,3000)%7Dload(1)">https://hostloc.com/space-uid-&quot;+(2000+i)+&quot;.html&quot;},3000)}load(1)</a>;</p>
]]></content>
      <tags>
        <tag>hostloc</tag>
      </tags>
  </entry>
  <entry>
    <title>OneDrive同域一键转存机器人源码及搭建教程</title>
    <url>/posts/45698/</url>
    <content><![CDATA[<p>感谢 Chao 佬开源，请参阅原贴 OneDrive同域一键复制转存机器人已上线 查看机器人使用说明。由 Chao 佬授权，本贴将开放机器人源代码、描述较为详细的搭建教程，请从本贴附件下载源码、配置文件。我搭建的机器人使用自建 API 已通过表演域的审核： @CRODsaveBot 。</p>
<p><a href="https://shields.io/badge/python-pip-yellow?logo=python&style=flat">https://shields.io/badge/python-pip-yellow?logo=python&amp;style=flat</a></p>
<p>搭建机器人需要会基本的Linux操作，我这里以 Ubuntu20 为例，其他系统请灵活变通。需要 python 环境，一般的 Linux 系统都自带。</p>
<h1 id="1-上传源码"><a href="#1-上传源码" class="headerlink" title="1. 上传源码"></a><strong>1. 上传源码</strong></h1><p>新建bot文件夹并进入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir bot &amp;&amp; cd bot</span><br></pre></td></tr></table></figure>

<p>上传源码 <code>main.py</code> 、配置文件 <code>config.json</code>至 <code>bot</code>目录，需要修改源码第10行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bot_api = &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>私信 <a href="https://bbs.1ove.club/gowild.htm?url=https_3A_2F_2Ft_2eme_2Fbotfather&u=657&fr=https_3A_2F_2Fbbs_2e1ove_2eclub_2Fthread_2d6282_2ehtm">BotFather</a> 创建一个新的 bot 获取 token 填入双引号之中。</p>
<p>源码第18、19行为 Chao 佬原本 API 的 id 、 secret ，登陆 1ove 的账号无需再审核，若需使用自建 API 登陆 1ove 账号需向管理员提出申请。自建 API 你需要关注以下事项：</p>
<ul>
<li>重定向 URI （redirect URL） ： <code>http://localhost:53682</code></li>
<li>AAD应用获得永久密码：<a href="https://bbs.1ove.club/gowild.htm?url=https_3A_2F_2Fwww_2eqian_2eblue_2Farchives_2Faad_2dforever_2dsecret_2ehtml&u=657&fr=https_3A_2F_2Fbbs_2e1ove_2eclub_2Fthread_2d6282_2ehtm">https://www.qian.blue/archives/aad-forever-secret.html</a></li>
</ul>
<h1 id="2-安装-python-依赖库"><a href="#2-安装-python-依赖库" class="headerlink" title="2. 安装 python 依赖库"></a><strong>2. 安装 python 依赖库</strong></h1><p>提示 <code>command not found</code> 请切换 python 版本或安装 pip3 。</p>
<p>python2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests pyTelegramBotAPI</span><br></pre></td></tr></table></figure>

<p>或 pyhon3 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install python3-pip</span><br><span class="line">pip3 install requests pyTelegramBotAPI</span><br></pre></td></tr></table></figure>

<h1 id="3-运行-bot"><a href="#3-运行-bot" class="headerlink" title="3. 运行 bot"></a><strong>3. 运行 bot</strong></h1><p>安装 screen 来让 bot 实现后台运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install screen</span><br></pre></td></tr></table></figure>

<p>新建一个 screen 会话，名称自定，以 bot 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -S bot</span><br></pre></td></tr></table></figure>

<p>启动bot：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>

<p>或python3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 main.py</span><br></pre></td></tr></table></figure>

<p>退出会话：<code>快捷键 Ctrl + A + D</code></p>
<p>进入会话： <code>screen -r bot</code></p>
<p>终止会话：<code>pkill screen</code></p>
<p>最后给机器人发送命令 <code>/start</code> 得到回应即为搭建成功。</p>
<ul>
<li>代码main.py  import telebot<br>  import time<br>  from telebot import types<br>  import os<br>  import json<br>  import requests<br>  import re<br>  import base64  bot_api = “”<br>  bot = telebot.TeleBot(bot_api, parse_mode=None)  redirect_uri = “<a href="http://localhost:53682/">http://localhost:53682</a>“<br>  scope = “offline_access user.read Files.Read Files.ReadWrite Files.Read.All Files.ReadWrite.All Sites.Read.All “ <br>  “Sites.ReadWrite.All “  client_id = “352ce6ec-85b0-4b0b-b1e2-fe6cadc23c64”<br>  client_secret = “HLTSIBS5.9PK13m8pPs_gSk6_hN~4.oaNl”<br>  login_url = f”<a href="https://login.microsoftonline.com/common/oauth2/v2.0/authorize?%22">https://login.microsoftonline.com/common/oauth2/v2.0/authorize?”</a> <br>  f”client_id={client_id}” <br>  “&amp;response_type=code” <br>  f”&amp;redirect_uri={redirect_uri}” <br>  “&amp;response_mode=query” <br>  f”&amp;scope={scope}”  def small_copy(driveid, itemid, dir_drive, dir_item,refresh_token,call):<br>  try:<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<br>  ‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’<br>  }<pre><code>  copy_url = f&quot;&lt;https://graph.microsoft.com/v1.0/drives/&#123;driveid&#125;/items/&#123;itemid&#125;/copy&gt;&quot;
  copy_body = &#123;
      &quot;parentReference&quot;: &#123;
          &quot;driveId&quot;: dir_drive,
          &quot;id&quot;: dir_item
      &#125;
  &#125;
  try:
      html = requests.post(url=copy_url, headers=temp_headers, json=copy_body,timeout=10)
  except Exception as e:
      print(f&quot;复制失败，跳过&#123;e&#125;&quot;)
      bot.edit_message_text(text=f&quot;复制失败，跳过:`&#123;e&#125;`&quot;, chat_id=call.message.chat.id, parse_mode=&#39;Markdown&#39;,
                            message_id=call.message.message_id)
      return
  # 大文件夹
  if html.status_code == 413:
      print(&quot;文件超出大小,启用分步复制&quot;)
      bot.edit_message_text(text=f&quot;文件超出大小,启用分步复制&quot;, chat_id=call.message.chat.id,
                            message_id=call.message.message_id)
  
      # 获取文件夹名称
      temp_json = old_get_info(driveid, itemid,refresh_token)
      print(temp_json)
      new_folder_name = temp_json[&#39;name&#39;]
      print(new_folder_name)
  
      # 新建文件夹
      temp_json = creat_folder(drive_id=dir_drive, parent_item_id=dir_item, name=new_folder_name,refresh_token=refresh_token)
      # 获取新建文件夹信息
      temp_drive = temp_json[&#39;parentReference&#39;][&#39;driveId&#39;]
      temp_item = temp_json[&#39;id&#39;]
      # 获取分享内容文件夹内子文件列表信息
      share_list = get_folder_list(driveid=driveid, itemid=itemid,refresh_token=refresh_token)
      # print(share_list)
      # 遍历分享文件夹内容
      for a in share_list:
          share_driveid = a[&#39;parentReference&#39;][&#39;driveId&#39;]
          share_id = a[&#39;id&#39;]
          small_copy(driveid=share_driveid, itemid=share_id, dir_drive=temp_drive, dir_item=temp_item,refresh_token=refresh_token,call=call)
  
      return
  # print(f&quot;&#123;new_folder_name&#125; 全部复制完成&quot;)
  
  else:
  
      temp_json = old_get_info(driveid, itemid,refresh_token)
      print(temp_json)
      folder_name = temp_json[&#39;name&#39;]
      print(f&quot;添加成功:&#123;folder_name&#125;&quot;)
      bot.edit_message_text(text=f&quot;添加成功:`&#123;folder_name&#125;`&quot;, chat_id=call.message.chat.id, parse_mode=&#39;Markdown&#39;,
                            message_id=call.message.message_id)
  
      return
</code></pre>
  except Exception as e:<pre><code>  try:
      print(f&quot;复制失败，跳过&#123;e&#125;&quot;)
      bot.edit_message_text(text=f&quot;复制失败，跳过:`&#123;e&#125;`&quot;, chat_id=call.message.chat.id, parse_mode=&#39;Markdown&#39;,
                            message_id=call.message.message_id)
  except:
      return
  return
</code></pre>
  def get_folder_list(driveid, itemid, refresh_token):  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<pre><code>  &#39;Authorization&#39;: access_token,
  &#39;Content-Type&#39;: &#39;application/json&#39;
</code></pre>
  }  html = requests.get(f’<a href="https://graph.microsoft.com/v1.0/drives/%7Bdriveid%7D/items/%7Bitemid%7D/children">https://graph.microsoft.com/v1.0/drives/{driveid}/items/{itemid}/children</a>‘,<pre><code>                  headers=temp_headers,timeout=10)
</code></pre>
  print(f”获取子文件夹{itemid}”)<h1 id="print-html-json"><a href="#print-html-json" class="headerlink" title="print(html.json())"></a>print(html.json())</h1>  copy_list = []<br>  while True:<pre><code>  for a in html.json()[&#39;value&#39;]:
      copy_list.append(a)
  if &quot;@odata.nextLink&quot; in html.json():
      print(&quot;该资源子文件超过200&quot;)
      new_url = html.json()[&#39;@odata.nextLink&#39;]
      html = requests.get(url=new_url, headers=temp_headers,timeout=10)
  else:
      break
</code></pre>
<h1 id="print-copy-list"><a href="#print-copy-list" class="headerlink" title="print(copy_list)"></a>print(copy_list)</h1>  print(f”子文件数为：{len(copy_list)}”)<br>  return copy_list  def old_get_info(drive_id, item_id,refresh_token):<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<br>  ‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’<br>  }<br>  info_url = f”<a href="https://graph.microsoft.com/v1.0/drives/%7Bdrive_id%7D/items/%7Bitem_id%7D">https://graph.microsoft.com/v1.0/drives/{drive_id}/items/{item_id}</a>“  html = requests.get(url=info_url, headers=temp_headers)<br>  return html.json()  def creat_folder(drive_id, parent_item_id, name, refresh_token):<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<br>  ‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’<br>  }<br>  creat_url = f”<a href="https://graph.microsoft.com/v1.0/drives/%7Bdrive_id%7D/items/%7Bparent_item_id%7D/children">https://graph.microsoft.com/v1.0/drives/{drive_id}/items/{parent_item_id}/children</a>“<br>  creat_body = {<br>  “name”: name,<br>  “folder”: {}<br>  }<br>  html = requests.post(url=creat_url, headers=temp_headers, json=creat_body,timeout=10)<h1 id="print-html-json-1"><a href="#print-html-json-1" class="headerlink" title="print(html.json())"></a>print(html.json())</h1>  return html.json()  def start_copy(driveid, itemid,root_driveid,root_itemid,refresh_token,call):  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<pre><code>  &#39;Authorization&#39;: access_token,
  &#39;Content-Type&#39;: &#39;application/json&#39;
</code></pre>
  }<br>  copy_url = f”<a href="https://graph.microsoft.com/v1.0/drives/%7Bdriveid%7D/items/%7Bitemid%7D/copy">https://graph.microsoft.com/v1.0/drives/{driveid}/items/{itemid}/copy</a>“<br>  copy_body = {<pre><code>  &quot;parentReference&quot;: &#123;
      &quot;driveId&quot;: root_driveid,
      &quot;id&quot;: root_itemid
  &#125;
</code></pre>
  }<br>  print(“调用复制”)<br>  bot.edit_message_text(text=”调用复制”, chat_id=call.message.chat.id,<pre><code>                    message_id=call.message.message_id)
</code></pre>
  html = requests.post(url=copy_url, headers=temp_headers, json=copy_body,timeout=10)<h1 id="大文件夹"><a href="#大文件夹" class="headerlink" title="大文件夹"></a>大文件夹</h1>  if html.status_code == 413:<pre><code>  print(&quot;文件超出大小,启用分步复制&quot;)
  bot.edit_message_text(text=&quot;文件超出大小,启用分步复制&quot;, chat_id=call.message.chat.id,
                        message_id=call.message.message_id)

  # 获取文件夹名称
  temp_json = old_get_info(driveid, itemid,refresh_token)
  print(temp_json)
  new_folder_name = temp_json[&#39;name&#39;]
  print(new_folder_name)
  
  # 新建文件夹
  temp_json = creat_folder(drive_id=root_driveid, parent_item_id=root_itemid, name=new_folder_name,
                           refresh_token=refresh_token)
  # 获取新建文件夹信息
  temp_drive = temp_json[&#39;parentReference&#39;][&#39;driveId&#39;]
  temp_item = temp_json[&#39;id&#39;]
  
  # 获取分享内容文件夹内子文件列表信息
  share_list = get_folder_list(driveid=driveid, itemid=itemid,refresh_token=refresh_token)
  
  # 遍历分享文件夹内容
  for a in share_list:
      share_driveid = a[&#39;parentReference&#39;][&#39;driveId&#39;]
      share_id = a[&#39;id&#39;]
      small_copy(driveid=share_driveid, itemid=share_id, dir_drive=temp_drive, dir_item=temp_item,refresh_token=refresh_token,call=call)
  
  print(&quot;添加云端复制完成&quot;)
  bot.edit_message_text(text=&quot;添加云端复制完成&quot;, chat_id=call.message.chat.id,
                        message_id=call.message.message_id)
  return
</code></pre>
<h1 id="print-f”-new-folder-name-全部复制完成”"><a href="#print-f”-new-folder-name-全部复制完成”" class="headerlink" title="print(f”{new_folder_name} 全部复制完成”)"></a>print(f”{new_folder_name} 全部复制完成”)</h1>  else:<pre><code>  temp_json =old_get_info(driveid, itemid,refresh_token)
  print(temp_json)
  folder_name = temp_json[&#39;name&#39;]
  print(f&quot;添加任务成功:&#123;folder_name&#125;&quot;)
  bot.edit_message_text(text=f&quot;添加任务成功:`&#123;folder_name&#125;`&quot;, chat_id=call.message.chat.id,parse_mode=&#39;Markdown&#39;,
                        message_id=call.message.message_id)
  time.sleep(1)
  bot.edit_message_text(text=f&quot;所有任务完成&quot;, chat_id=call.message.chat.id, parse_mode=&#39;Markdown&#39;,
                        message_id=call.message.message_id)
  
  return
</code></pre>
  def gettoken(id, secret, refresh_token):<br>  headers = {‘Content-Type’: ‘application/x-www-form-urlencoded’<br>  }<br>  data = {‘grant_type’: ‘refresh_token’,<br>  ‘refresh_token’: refresh_token,<br>  ‘client_id’: id,<br>  ‘client_secret’: secret,<br>  ‘redirect_uri’: ‘<a href="http://localhost:53682/">http://localhost:53682/</a>‘<br>  }<br>  html = requests.post(‘<a href="https://login.microsoftonline.com/common/oauth2/v2.0/token">https://login.microsoftonline.com/common/oauth2/v2.0/token</a>‘,<br>  data=data, headers=headers,timeout=10)<br>  jsontxt = json.loads(html.text)<br>  refresh_token = jsontxt[‘refresh_token’]<br>  access_token = jsontxt[‘access_token’]<br>  return access_token  def get_folder_par(drive_id, item_id, refresh_token):<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<br>  ‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’<br>  }<br>  info_url = f”<a href="https://graph.microsoft.com/v1.0/drives/%7Bdrive_id%7D/items/%7Bitem_id%7D">https://graph.microsoft.com/v1.0/drives/{drive_id}/items/{item_id}</a>“  html = requests.get(url=info_url, headers=temp_headers,timeout=10)<br>  return html.json()  def my_file(refresh_token):<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<br>  ‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’<br>  }  html = requests.get(r’<a href="https://graph.microsoft.com/v1.0/me/drive/root/children">https://graph.microsoft.com/v1.0/me/drive/root/children</a>‘, headers=temp_headers,timeout=10)  return html.json()  def get_config(user_id,od_name):<br>  with open(“config.json”, “r”, encoding=’utf-8’) as jsonFile:<br>  data = json.load(jsonFile)<br>  jsonFile.close()<br>  Telegram_list = data[‘Telegram list’]<br>  for a in Telegram_list:<br>  if str(a[‘id’]) == str(user_id):<pre><code>      account_list = list(a[&quot;account list&quot;])
</code></pre>
  for a in account_list:<pre><code>  if str(a[&#39;name&#39;]) == str(od_name):

      od_config = a
</code></pre>
  return od_config  def get_info(drive_id, item_id, refresh_token):<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {<br>  ‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’<br>  }<br>  info_url = f”<a href="https://graph.microsoft.com/v1.0/drives/%7Bdrive_id%7D/items/%7Bitem_id%7D/children">https://graph.microsoft.com/v1.0/drives/{drive_id}/items/{item_id}/children</a>“  html = requests.get(url=info_url, headers=temp_headers,timeout=10)<br>  return html.json()  def create_onedrive_directdownload(onedrive_link):<br>  data_bytes64 = base64.b64encode(bytes(onedrive_link, ‘utf-8’))<br>  data_bytes64_String = data_bytes64.decode(‘utf-8’).replace(‘/‘, ‘_’).replace(‘+’, ‘-‘).rstrip(“=”)<br>  data_bytes64_String = “u!” + data_bytes64_String<h1 id="print-data-bytes64-String"><a href="#print-data-bytes64-String" class="headerlink" title="print(data_bytes64_String)"></a>print(data_bytes64_String)</h1>  return data_bytes64_String  def visit_url(link,config,call):<br>  refresh_token=config[‘refresh_token’]<br>  print(refresh_token)<br>  access_token = gettoken(client_id, client_secret, refresh_token)<br>  temp_headers = {‘Authorization’: access_token,<br>  ‘Content-Type’: ‘application/json’,<br>  ‘Prefer’: “redeemSharingLink”}  shareIdOrEncodedSharingUrl = create_onedrive_directdownload(onedrive_link=link)<br>  print(shareIdOrEncodedSharingUrl)<br>  html = requests.get(<pre><code>  rf&#39;&lt;https://graph.microsoft.com/v1.0/shares/&#123;shareIdOrEncodedSharingUrl&#125;/driveItem&gt;&#39;,
  headers=temp_headers,timeout=10)
</code></pre>
  print(html.json())<br>  if “error” in str(html.json()):<pre><code>  print(&quot;获取分享链接失败&quot;)
  bot.edit_message_text(text=&quot;获取分享链接失败&quot;, chat_id=call.message.chat.id,
                        message_id=call.message.message_id)
  return
</code></pre>
  else:<pre><code>  print(&quot;获取分享信息成功&quot;)
  bot.edit_message_text(text=&quot;获取分享信息成功&quot;, chat_id=call.message.chat.id,
                        message_id=call.message.message_id)

  driveid = html.json()[&#39;parentReference&#39;][&#39;driveId&#39;]
  itemid = html.json()[&#39;id&#39;]
  
  try:
      temp=config[&#39;save_folder&#39;]
  except:
      bot.edit_message_text(text=&quot;未设置保存文件夹&quot;, chat_id=call.message.chat.id,
                            message_id=call.message.message_id)
      return
  
  start_copy(driveid=driveid, itemid=itemid,
             root_driveid=config[&#39;drive_id&#39;],root_itemid=config[&#39;save_folder&#39;],
             refresh_token=refresh_token,call=call)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “copy” in str(call.data))<br>  def od_copy(call):<br>  print(call.data)<br>  od_name = str(call.data).split(“ “)[1]<br>  print(od_name)<br>  user_id = call.from_user.id<br>  info_text = call.message.text  url = re.findall(‘([a-zA-z]+://[^\s]*)’, str(info_text))[0]<br>  print(url)<br>  od_config = get_config(user_id, od_name)<br>  visit_url(link=url,config=od_config,call=call)  @bot.callback_query_handler(func=lambda call: “save” == str(call.data))<br>  def choose_folder(call):<br>  try:<br>  user_id = call.from_user.id<pre><code>  temp_list = str(call.message.text).split(&quot;\\n&quot;)
  od_name = temp_list[0]
  
  temp_drive_id = temp_list[1]
  temp_item_id = temp_list[2]
  
  with open(&quot;config.json&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as jsonFile:
      data = json.load(jsonFile)
      jsonFile.close()
  
  for a in data[&#39;Telegram list&#39;]:
      if str(a[&#39;id&#39;]) == str(user_id):
          account_list = list(a[&quot;account list&quot;])
  
  for a in account_list:
      if str(a[&#39;name&#39;]) == str(od_name):
          od_config = a
  
  od_config[&#39;drive_id&#39;] = temp_drive_id
  od_config[&#39;save_folder&#39;] = temp_item_id
  
  for a in range(len(account_list)):
      if str(account_list[a][&#39;name&#39;]) == str(od_name):
          account_list[a] = od_config
  
  for a in range(len(data[&#39;Telegram list&#39;])):
      if str(data[&#39;Telegram list&#39;][a][&#39;id&#39;]) == str(user_id):
          data[&#39;Telegram list&#39;][a][&#39;account list&#39;] = account_list
  
  with open(&quot;config.json&quot;, &quot;w&quot;) as jsonFile:
      json.dump(data, jsonFile, indent=4, ensure_ascii=False)
      jsonFile.close()
  print(&quot;写入完成&quot;)
  bot.edit_message_text(&quot;设定保存文件夹成功&quot;, call.message.chat.id, call.message.message_id)
  time.sleep(1)
  change_old_account(user_id=user_id,call=call.message)
</code></pre>
  except Exception as e:<pre><code>  print(f&quot;choose_folder &#123;e&#125;&quot;)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “back” == str(call.data))<br>  def back_page(call):<br>  user_id = call.from_user.id  temp_list = str(call.message.text).split(“\n”)<br>  od_name = temp_list[0]  temp_drive_id = temp_list[1]<br>  temp_item_id = temp_list[2]<br>  od_config = get_config(user_id, od_name)<br>  info_list = get_folder_par(drive_id=temp_drive_id,<pre><code>                   item_id=temp_item_id,
                   refresh_token=od_config[&#39;refresh_token&#39;])
</code></pre>
  print(info_list)<br>  drive_id = info_list[‘parentReference’][‘driveId’]<br>  item_id = info_list[‘parentReference’][‘id’]  folder_info = get_folder_par(drive_id=drive_id,<pre><code>                       item_id=item_id,
                       refresh_token=od_config[&#39;refresh_token&#39;])
</code></pre>
  new_file_list = get_info(drive_id=drive_id,<pre><code>                       item_id=item_id,
                       refresh_token=od_config[&#39;refresh_token&#39;])
</code></pre>
  text = f”{od_name}\n{drive_id}\n{item_id}\n”<br>  file_list = []<br>  num = 0<br>  markup = types.InlineKeyboardMarkup()<br>  button_list = []<br>  for a in new_file_list[‘value’]:<pre><code>  if num == 10:
      break
  if &#39;folder&#39; in a:
      file_list.append(a)
      # print(num+&quot; - &quot;+ a[&#39;name&#39;]+&#39;   ItemID:&#39;+a[&#39;id&#39;]+&#39;   driveId:&#39;+a[&#39;parentReference&#39;][&#39;driveId&#39;])
      # print(f&quot;&#123;num&#125; - &#123;a[&#39;name&#39;]&#125;&quot;)
      button_list.append(types.InlineKeyboardButton(num, callback_data=f&quot;folder &#123;num&#125;&quot;))
      if (num + 1) % 4 == 5:
          markup.add(*button_list)
          button_list = []

      text = text + f&quot;&#123;num&#125; - &#123;a[&#39;name&#39;]&#125;\\n&quot;
      num = num + 1
</code></pre>
  markup.add(*button_list)  if folder_info[‘name’] != “root”:<pre><code>  markup.add(types.InlineKeyboardButton(&quot;上级文件夹&quot;, callback_data=f&quot;back&quot;),
             types.InlineKeyboardButton(&quot;设置为保存文件夹&quot;, callback_data=f&quot;save&quot;))
</code></pre>
  bot.edit_message_text(text, call.message.chat.id, call.message.message_id,<pre><code>                    reply_markup=markup)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “folder” in str(call.data))<br>  def show_folder(call):<br>  user_id = call.from_user.id  temp_list = str(call.message.text).split(“\n”)<br>  od_name = temp_list[0]<br>  par = temp_list[1]  key = int(str(call.data).split(“ “)[1])  od_config=get_config(user_id,od_name)<br>  if par == “root”:<pre><code>  info_list = my_file(refresh_token=od_config[&#39;refresh_token&#39;])[&#39;value&#39;]
</code></pre>
  else:<pre><code>  temp_drive_id = temp_list[1]
  temp_item_id = temp_list[2]
  info_list = get_info(drive_id=temp_drive_id,
                           item_id=temp_item_id,
                           refresh_token=od_config[&#39;refresh_token&#39;])[&#39;value&#39;]
</code></pre>
  print(key)<br>  print(info_list)<br>  print(info_list[key][‘parentReference’][‘driveId’])<br>  print(info_list[key][‘id’])<br>  drive_id = info_list[key][‘parentReference’][‘driveId’]<br>  item_id = info_list[key][‘id’]<br>  new_file_list = get_info(drive_id=drive_id,<pre><code>                       item_id = item_id,
                       refresh_token=od_config[&#39;refresh_token&#39;])
</code></pre>
  print(new_file_list)  text = f”{od_name}\n{drive_id}\n{item_id}\n”<br>  file_list=[]<br>  num=0<br>  markup = types.InlineKeyboardMarkup()<br>  button_list = []<br>  for a in new_file_list[‘value’]:<pre><code>  if num == 10:

      break
  if &#39;folder&#39; in a:
      file_list.append(a)
      # print(num+&quot; - &quot;+ a[&#39;name&#39;]+&#39;   ItemID:&#39;+a[&#39;id&#39;]+&#39;   driveId:&#39;+a[&#39;parentReference&#39;][&#39;driveId&#39;])
      # print(f&quot;&#123;num&#125; - &#123;a[&#39;name&#39;]&#125;&quot;)
      button_list.append(types.InlineKeyboardButton(num, callback_data=f&quot;folder &#123;num&#125;&quot;))
      if (num + 1) % 4 == 5:
          markup.add(*button_list)
          button_list = []
  
      text = text + f&quot;&#123;num&#125; - &#123;a[&#39;name&#39;]&#125;\\n&quot;
      num = num + 1
</code></pre>
  markup.add(*button_list)<br>  print(text)<br>  markup.add(types.InlineKeyboardButton(“上级文件夹”, callback_data=f”back”),<pre><code>         types.InlineKeyboardButton(&quot;设置为保存文件夹&quot;, callback_data=f&quot;save&quot;))
</code></pre>
  markup.add(types.InlineKeyboardButton(“账号列表”, callback_data=”account list”))<br>  bot.edit_message_text(text, call.message.chat.id, call.message.message_id,<pre><code>                    reply_markup=markup)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “onedrive” in str(call.data))<br>  def show_od(call):<br>  print(call.data)<br>  od_name = str(call.data).split(“ “)[1]<br>  print(od_name)<br>  user_id = call.from_user.id<br>  with open(“config.json”, “r”, encoding=’utf-8’) as jsonFile:<br>  data = json.load(jsonFile)<br>  jsonFile.close()<br>  Telegram_list = data[‘Telegram list’]<br>  for a in Telegram_list:<br>  if str(a[‘id’]) == str(user_id):<br>  print(“找到用户信息”)<br>  account_list = list(a[“account list”])  for a in account_list:<pre><code>  if str(a[&#39;name&#39;]) == str(od_name):

      od_config = a
</code></pre>
  info_list = my_file(refresh_token=od_config[‘refresh_token’])  file_list = []<br>  num = 0  text = f”{od_name}\nroot\n选择对应序号进入文件夹，根目录无法设置为保存文件夹\n”  markup = types.InlineKeyboardMarkup()<br>  button_list = []<br>  print(info_list)<br>  for a in info_list[‘value’]:<pre><code>  if num == 10:

      break
  if &#39;folder&#39; in a:
      file_list.append(a)
      # print(num+&quot; - &quot;+ a[&#39;name&#39;]+&#39;   ItemID:&#39;+a[&#39;id&#39;]+&#39;   driveId:&#39;+a[&#39;parentReference&#39;][&#39;driveId&#39;])
      # print(f&quot;&#123;num&#125; - &#123;a[&#39;name&#39;]&#125;&quot;)
      button_list.append(types.InlineKeyboardButton(num, callback_data=f&quot;folder &#123;num&#125;&quot;))
      if (num + 1) % 4 == 5:
          markup.add(*button_list)
          button_list = []
  
      text = text + f&quot;&#123;num&#125; - &#123;a[&#39;name&#39;]&#125;\\n&quot;
      num = num + 1
</code></pre>
  markup.add(*button_list)<br>  print(text)<br>  markup.add(types.InlineKeyboardButton(“账号列表”, callback_data=”account list”))<br>  bot.edit_message_text(text, call.message.chat.id, call.message.message_id,<pre><code>                    reply_markup=markup)
</code></pre>
  def check_id(info_list, telegram_id):<br>  num = 0<br>  print(info_list, telegram_id)<br>  for a in info_list:<br>  if str(a[‘id’]) == str(telegram_id):<br>  num = 1<br>  if num == 0:<br>  return False<br>  else:<br>  return True  def add_onedrive_token(message, name, info):<br>  print(message)<br>  bot.delete_message(chat_id=<a href="http://message.chat.id/">message.chat.id</a>, message_id=message.message_id)<br>  user_id = message.from_user.id<br>  result = str(message.text)<br>  if result == “/cancel”:<br>  change_old_account(call=info,user_id=user_id)<br>  return<br>  else:<pre><code>  code = re.findall(&quot;.*?code=(.*?)&amp;&quot;, result, re.S)[0]
  
  data = &#123;
      &quot;client_id&quot;: client_id,
      &quot;grant_type&quot;: &quot;authorization_code&quot;,
      &quot;redirect_uri&quot;: redirect_uri,
      &quot;scope&quot;: scope,
      &quot;client_secret&quot;: client_secret,
      &quot;code&quot;: code
  &#125;
  print(&quot;获取参数成功，开始登录&quot;)
  test_url = &quot;&lt;https://login.microsoftonline.com/common/oauth2/v2.0/token&gt;&quot;
  result = requests.post(url=test_url, data=data, timeout=10)
  
  if result.status_code == 200:
      result_json = result.json()
      print(&quot;开始写入配置&quot;)
      with open(&quot;config.json&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as jsonFile:
          data = json.load(jsonFile)
          jsonFile.close()
  
      for a in data[&#39;Telegram list&#39;]:
          if str(a[&#39;id&#39;]) == str(user_id):
              account_list = list(a[&quot;account list&quot;])
  
      config_data = &#123;&#125;
      config_data[&#39;name&#39;] = name
      config_data[&#39;access_token&#39;] = result_json[&#39;access_token&#39;]
      config_data[&#39;refresh_token&#39;] = result_json[&#39;refresh_token&#39;]
  
      account_list.append(config_data)
  
      for a in range(len(data[&#39;Telegram list&#39;])):
          if str(data[&#39;Telegram list&#39;][a][&#39;id&#39;]) == str(user_id):
              data[&#39;Telegram list&#39;][a][&#39;account list&#39;] = account_list
  
      with open(&quot;config.json&quot;, &quot;w&quot;) as jsonFile:
          json.dump(data, jsonFile, indent=4, ensure_ascii=False)
          jsonFile.close()
      print(&quot;登录成功&quot;)
      bot.edit_message_text(text=&quot;登录成功&quot;, chat_id=info.chat.id, message_id=int(info.message_id),
                            parse_mode=&#39;Markdown&#39;)
  
      time.sleep(1)
  
      change_old_account(user_id=user_id,call=info)
      return
  else:
      bot.edit_message_text(text=f&quot;登录失败\\n&#123;result.text&#125;&quot;, chat_id=info.chat.id, message_id=int(info.message_id),
                            parse_mode=&#39;Markdown&#39;)
      return
</code></pre>
  def change_old_account(user_id,call):  with open(“config.json”, “r”, encoding=’utf-8’) as jsonFile:<pre><code>  data = json.load(jsonFile)
  jsonFile.close()
</code></pre>
  Telegram_list = data[‘Telegram list’]<br>  print(user_id)<br>  if check_id(Telegram_list, user_id) == True:<pre><code>  print(&quot;用户存在&quot;)
  for a in Telegram_list:
      if str(a[&#39;id&#39;]) == str(user_id):
          print(&quot;找到用户信息&quot;)
          account_list = list(a[&quot;account list&quot;])

  if len(account_list) == 0:
      text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
             f&quot;已有账号数:`0`&quot;
  
      markup = types.InlineKeyboardMarkup()
      markup.add(types.InlineKeyboardButton(&quot;添加账号&quot;, callback_data=&quot;add_account&quot;))
  
      bot.edit_message_text(text, call.chat.id, call.message_id, parse_mode=&#39;Markdown&#39;,
                            reply_markup=markup)
  else:
      text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
             f&quot;已有账号数:`&#123;len(account_list)&#125;`&quot;
  
      markup = types.InlineKeyboardMarkup()
      for a in account_list:
          markup.add(types.InlineKeyboardButton(a[&#39;name&#39;], callback_data=f&quot;onedrive &#123;a[&#39;name&#39;]&#125;&quot;))
  
      markup.add(types.InlineKeyboardButton(&quot;添加账号&quot;, callback_data=&quot;add_account&quot;))
      markup.add(types.InlineKeyboardButton(&quot;删除账号&quot;, callback_data=&quot;del_account&quot;))
  
      bot.edit_message_text(text, call.chat.id, call.message_id, parse_mode=&#39;Markdown&#39;,
                            reply_markup=markup)
</code></pre>
  def add_onedrive_name(message,call):<br>  keywords = str(message.text)<br>  print(message)<br>  user_id = message.from_user.id<br>  bot.delete_message(chat_id=<a href="http://message.chat.id/">message.chat.id</a>, message_id=message.message_id)  if keywords == “/cancel”:<pre><code>  print(&quot;取消输入昵称&quot;)
  change_old_account(user_id=user_id,call=call)
  return
</code></pre>
  else:<pre><code>  name = keywords

  print(f&quot;备注名:&#123;keywords&#125;-&#123;user_id&#125;&quot;)
  
  text = f&quot;你的ID:&#123;user_id&#125;\\n&quot; \\
         f&quot;账号备注:&#123;name&#125;\\n&quot; \\
         f&quot;请复制链接到浏览器打开登录:[链接地址](&#123;login_url&#125;)\\n&quot; \\
         f&quot;登录说明:登录成功后会显示**无法访问此网站**，此时复制网址发送给本Bot即可\\n&quot; \\
         f&quot;或者输入 /cancel 取消添加&quot;
  
  msg = bot.edit_message_text(text=text, chat_id=call.chat.id, message_id=int(call.message_id),
                              parse_mode=&#39;Markdown&#39;)
  
  # info = bot.send_message(text=text, chat_id=call.from_user.id, parse_mode=&#39;Markdown&#39;)
  
  bot.register_next_step_handler(msg, add_onedrive_token, name, msg)
  
  return
</code></pre>
  @bot.callback_query_handler(func=lambda call: “delod” in str(call.data))<br>  def del_od(call):<br>  try:<br>  print(“删除用户”)<br>  user_id = call.from_user.id<br>  print(call.data)<br>  temp_list = str(call.data).split(“ “)<br>  od_name = temp_list[1]<pre><code>  with open(&quot;config.json&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as jsonFile:
      data = json.load(jsonFile)
      jsonFile.close()
  
  for a in range(len(data[&#39;Telegram list&#39;])):
      print(a)
      if str(data[&#39;Telegram list&#39;][a][&#39;id&#39;]) == str(user_id):
          account_list = list(data[&#39;Telegram list&#39;][a][&quot;account list&quot;])
  
  print(account_list)
  
  for a in range(len(account_list)):
      print(a)
      print(account_list[a][&#39;name&#39;],str(od_name))
      if str(account_list[a][&#39;name&#39;]) == str(od_name):
          print(account_list[a])
          del account_list[a]
          break
  
  for a in range(len(data[&#39;Telegram list&#39;])):
      if str(data[&#39;Telegram list&#39;][a][&#39;id&#39;]) == str(user_id):
          data[&#39;Telegram list&#39;][a][&#39;account list&#39;] = account_list
  
  with open(&quot;config.json&quot;, &quot;w&quot;) as jsonFile:
      json.dump(data, jsonFile, indent=4, ensure_ascii=False)
      jsonFile.close()
  
  print(&quot;删除成功&quot;)
  
  change_old_account(call=call.message, user_id=user_id)
</code></pre>
  except Exception as e:<pre><code>  print(f&quot;del_od:&#123;e&#125;&quot;)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “del_account” == str(call.data))<br>  def del_account_list(call):<br>  print(call.message)<br>  user_id = call.from_user.id<br>  print(user_id)  try:<pre><code>  with open(&quot;config.json&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as jsonFile:
      data = json.load(jsonFile)
      jsonFile.close()
  Telegram_list = data[&#39;Telegram list&#39;]

  for a in Telegram_list:
      if str(a[&#39;id&#39;]) == str(user_id):
          print(&quot;找到用户信息&quot;)
          account_list = list(a[&quot;account list&quot;])
  
  if len(account_list) == 0:
      text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
             f&quot;已有账号数:`0`\\n&quot; \\
             f&quot;请选择删除的账号&quot;
  
      markup = types.InlineKeyboardMarkup()
      markup.add(types.InlineKeyboardButton(&quot;账号列表&quot;, callback_data=&quot;account list&quot;))
  
      bot.edit_message_text(text, call.message.chat.id, call.message.message_id, parse_mode=&#39;Markdown&#39;,
                            reply_markup=markup)
  else:
      text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
             f&quot;已有账号数:`&#123;len(account_list)&#125;`\\n&quot; \\
             f&quot;请选择删除的账号&quot;
  
      markup = types.InlineKeyboardMarkup()
      for a in account_list:
          markup.add(types.InlineKeyboardButton(a[&#39;name&#39;], callback_data=f&quot;delod &#123;a[&#39;name&#39;]&#125;&quot;))
  
      markup.add(types.InlineKeyboardButton(&quot;账号列表&quot;, callback_data=&quot;account list&quot;))
      bot.edit_message_text(text, call.message.chat.id, call.message.message_id, parse_mode=&#39;Markdown&#39;,
                            reply_markup=markup)
</code></pre>
  except Exception as e:<pre><code>  input(f&quot;del_account:&#123;e&#125;&quot;)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “add_account” == str(call.data))<br>  def add_onedrive(call):<br>  try:<br>  text = “请输入该Onedrive账号的备注\n” <br>  “或者输入 /cancel 取消添加\n” <br>  “名称尽量简洁”<br>  info = bot.edit_message_text(text, <a href="http://call.message.chat.id/">call.message.chat.id</a>, call.message.message_id, parse_mode=’Markdown’)<pre><code>  bot.register_next_step_handler(info, add_onedrive_name,info)
  
  return
</code></pre>
  except Exception as e:<pre><code>  print(f&#39;add_onedrive error &#123;e&#125;&#39;)
</code></pre>
  @bot.callback_query_handler(func=lambda call: “account list” == str(call.data))<br>  def account_list(call):<br>  try:<br>  print(call.message)<br>  user_id = call.from_user.id<br>  print(user_id)<pre><code>  if os.path.isfile(&quot;config.json&quot;) == True:
  
      try:
          with open(&quot;config.json&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as jsonFile:
              data = json.load(jsonFile)
              jsonFile.close()
          Telegram_list = data[&#39;Telegram list&#39;]
          if check_id(Telegram_list, user_id) == True:
              print(&quot;用户存在&quot;)
              for a in Telegram_list:
                  if str(a[&#39;id&#39;]) == str(user_id):
                      print(&quot;找到用户信息&quot;)
                      account_list = list(a[&quot;account list&quot;])
  
              if len(account_list) == 0:
                  text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
                         f&quot;已有账号数:`0`&quot;
  
                  markup = types.InlineKeyboardMarkup()
                  markup.add(types.InlineKeyboardButton(&quot;添加账号&quot;, callback_data=&quot;add_account&quot;))
  
                  bot.edit_message_text(text, call.message.chat.id, call.message.message_id, parse_mode=&#39;Markdown&#39;,
                                        reply_markup=markup)
              else:
                  text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
                         f&quot;已有账号数:`&#123;len(account_list)&#125;`&quot;
  
                  markup = types.InlineKeyboardMarkup()
                  for a in account_list:
                      markup.add(types.InlineKeyboardButton(a[&#39;name&#39;], callback_data=f&quot;onedrive &#123;a[&#39;name&#39;]&#125;&quot;))
  
                  markup.add(types.InlineKeyboardButton(&quot;添加账号&quot;, callback_data=&quot;add_account&quot;))
                  markup.add(types.InlineKeyboardButton(&quot;删除账号&quot;, callback_data=&quot;del_account&quot;))
  
                  bot.edit_message_text(text, call.message.chat.id, call.message.message_id, parse_mode=&#39;Markdown&#39;,
                                        reply_markup=markup)
  
          else:
              print(&quot;用户不存在&quot;)
              Telegram_list = list(data[&#39;Telegram list&#39;])
              config_data = &#123;&#125;
              config_data[&#39;id&#39;] = user_id
              config_data[&#39;account list&#39;] = []
              Telegram_list.append(config_data)
              data[&#39;Telegram list&#39;] = Telegram_list
              with open(&quot;config.json&quot;, &quot;w&quot;) as jsonFile:
                  json.dump(data, jsonFile, indent=4, ensure_ascii=False)
                  jsonFile.close()
  
              account_list = config_data[&#39;account list&#39;]
  
              text = f&quot;你的ID：`&#123;user_id&#125;`\\n&quot; \\
                     f&quot;已有账号数:`&#123;len(account_list)&#125;`&quot;
  
              markup = types.InlineKeyboardMarkup()
              markup.add(types.InlineKeyboardButton(&quot;添加账号&quot;, callback_data=&quot;add_account&quot;))
  
              bot.edit_message_text(text, call.message.chat.id, call.message.message_id, parse_mode=&#39;Markdown&#39;,
                                    reply_markup=markup)
  
      except Exception as e:
          input(f&quot;读取配置错误:&#123;e&#125;&quot;)
  else:
      print(&quot;未找到配置&quot;)
      with open(&quot;config.json&quot;, &quot;a&quot;) as file:  # 只需要将之前的”w&quot;改为“a&quot;即可，代表追加内容
          file.close()
</code></pre>
  except Exception as e:<pre><code>  print(e)
</code></pre>
  @bot.message_handler(commands=[‘start’], func=lambda message: (message.chat.type == “private”))<br>  def start_info(message):  try:<pre><code>  text = &quot;本Bot为Onedrive同域转存的工具，旨在方便广大群友转存\\n&quot; \\
         &quot;注意：\\n&quot; \\
         &quot;- 本Bot获取的权限可对你的onedrive文件进行一系列操作，介意请勿使用\\n&quot; \\
         &quot;- 此Bot使用microsoft官方API，复制操作仅为向微软服务器提交复制请求，非vps搬运\\n&quot; \\
         &quot;- 不支持带密码的分享链接\\n&quot; \\
         &quot;- Bot提交时为单线程，速度较慢但避免滥用\\n&quot; \\
         &quot;- 此Bot不支持世纪互联\\n\\n&quot; \\
         &quot;使用方法:\\n&quot; \\
         &quot;1 - 在账号列表添加账号\\n&quot; \\
         &quot;2 - 进入账号设定保存文件夹\\n&quot; \\
         &quot;3 - 向Bot发送分享链接，选择正确的账号\\n&quot; \\
         &quot;4 - 等待提交任务完成&quot;

  markup = types.InlineKeyboardMarkup()
  markup.add(types.InlineKeyboardButton(&quot;账号列表&quot;, callback_data=&quot;account list&quot;))
  
  bot.send_message(message.chat.id, text, disable_notification=True, reply_markup=markup)
</code></pre>
  except Exception as e:<pre><code>  print(f&quot;start 错误:&#123;e&#125;&quot;)
  bot.send_message(message.chat.id, f&quot;start 错误:`&#123;e&#125;`&quot;, parse_mode=&#39;Markdown&#39;)
</code></pre>
  @bot.message_handler(content_types=[‘text’],func=lambda message: “https” in str(message.text))<br>  def get_share_url(message):  try:<pre><code>  print(message)
  print(message.text)
  user_id = message.from_user.id
  if &quot;https&quot; in str(message.text):
      print(&quot;检测到链接&quot;)
      bot.delete_message(chat_id=message.chat.id,message_id=message.message_id)
  
      url = re.findall(&#39;([a-zA-z]+://[^\\s]*)&#39;, str(message.text))[0]
  
      print(url)
  
      text=f&quot;检测到链接:&#123;url&#125;\\n&quot; \\
           f&quot;请选择保存的od账号\\n&quot; \\
           f&quot;**保存前请设定好保存文件夹**&quot;
  
      with open(&quot;config.json&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as jsonFile:
          data = json.load(jsonFile)
          jsonFile.close()
      Telegram_list = data[&#39;Telegram list&#39;]
      for a in Telegram_list:
          if str(a[&#39;id&#39;]) == str(user_id):
  
              account_list = list(a[&quot;account list&quot;])
  
      markup = types.InlineKeyboardMarkup()
      for a in account_list:
          markup.add(types.InlineKeyboardButton(a[&#39;name&#39;], callback_data=f&quot;copy &#123;a[&#39;name&#39;]&#125;&quot;))
  
      bot.send_message(text=text, chat_id=message.chat.id,
                            reply_markup=markup)
</code></pre>
  except Exception as e:<pre><code>  print(e)
</code></pre>
  if <strong>name</strong> == ‘<strong>main</strong>‘:<br>  bot.enable_save_next_step_handlers(delay=2)<h1 id="Load-next-step-handlers-from-save-file-default-“-handlers-saves-step-save”"><a href="#Load-next-step-handlers-from-save-file-default-“-handlers-saves-step-save”" class="headerlink" title="Load next_step_handlers from save file (default “./.handlers-saves/step.save”)"></a>Load next_step_handlers from save file (default “./.handlers-saves/step.save”)</h1><h1 id="WARNING-It-will-work-only-if-enable-save-next-step-handlers-was-called"><a href="#WARNING-It-will-work-only-if-enable-save-next-step-handlers-was-called" class="headerlink" title="WARNING It will work only if enable_save_next_step_handlers was called!"></a>WARNING It will work only if enable_save_next_step_handlers was called!</h1>  bot.load_next_step_handlers()<br>  while True:<pre><code>  try:
      print(&quot;启动机器人&quot;)
      bot.polling(none_stop=True, timeout=100)
  except Exception as e:
      print(f&quot;启动失败&#123;e&#125;&quot;)
      log = open(&#39;log.txt&#39;, &#39;a&#39;)
      log.writelines(&quot;启动错误: &#123;&#125;\\n&quot;.format(e))
      log.close()
      time.sleep(10)
</code></pre>
</li>
<li>代码config.json  {<br>  “Telegram list”: [  ]  }</li>
</ul>
<p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/481835d4-86be-4619-8767-b03f277b71a6/main.py">main.py</a></p>
<p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f23f53da-e7d6-4816-82e1-e3cb06b34faf/config.json">config.json</a></p>
]]></content>
      <tags>
        <tag>转存</tag>
        <tag>onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title>Statically.io：一款免费、强大、迅速的CDN加速服务</title>
    <url>/posts/60766/</url>
    <content><![CDATA[<p>Jsdelivr我想很多人都知道，开发者们会用它来加速css、JavaScript之类的静态资源，当然也会有部分哥们用它来加速图像服务，但在这里建议适量使用，滥用不是一个好的思想。<br>  Statically也是一款为开发者免费提供的CDN加速服务，它与Jsdelivr一样有着深厚的资源支持，同时其支持的内容更加丰富一些。下面介绍一下。<br>支持各家Git服务<br>服务名请求格式GitHub <a href="https://cdn.statically.io/gh/:user/:repo/:tag/:file">https://cdn.statically.io/gh/:user/:repo/:tag/:file</a><br>GitLab <a href="https://cdn.statically.io/gl/:user/:repo/:tag/:file">https://cdn.statically.io/gl/:user/:repo/:tag/:file</a><br>Bitbucket <a href="https://cdn.statically.io/bb/:user/:repo/:tag/:file">https://cdn.statically.io/bb/:user/:repo/:tag/:file</a></p>
<p>举个例子：<a href="https://cdn.statically.io/gh/qiantigers/Markdown2HTML/main/README.md">https://cdn.statically.io/gh/qiantigers/Markdown2HTML/main/README.md</a><br>勿埋我心试着访问了一下，速度也颇为可观。<br>加速图像显示<br>选项请求格式无修改打开 <a href="https://cdn.statically.io/img/:domain/:image">https://cdn.statically.io/img/:domain/:image</a><br>限制width打开 <a href="https://cdn.statically.io/img/:domain/w=:pixel/:image">https://cdn.statically.io/img/:domain/w=:pixel/:image</a><br>限制height打开 <a href="https://cdn.statically.io/img/:domain/h=:pixel/:image">https://cdn.statically.io/img/:domain/h=:pixel/:image</a><br>启动自动WebP <a href="https://cdn.statically.io/img/:domain/f=auto/:image">https://cdn.statically.io/img/:domain/f=auto/:image</a><br>调整图像质量 <a href="https://cdn.statically.io/img/:domain/q=:percentage/:image">https://cdn.statically.io/img/:domain/q=:percentage/:image</a></p>
<p>注：如果需要将选项整合到一起，用逗号隔开即可，比如：<a href="https://cdn.statically.io/img/:domain/w=:pixel,h=:pixel/:image">https://cdn.statically.io/img/:domain/w=:pixel,h=:pixel/:image</a></p>
<p>具体怎么实现加速呢？举个例子，用SMMS图床演示一下：<a href="https://cdn.statically.io/img/i.loli.net/2021/06/21/vshUdLDPHzxRZnS.jpg">https://cdn.statically.io/img/i.loli.net/2021/06/21/vshUdLDPHzxRZnS.jpg</a></p>
<p>加速WordPress</p>
<p>  这个跟勿埋我心的关系不大，因为博主用的是Typecho，不过也为使用WordPress的哥们介绍一下。<br>加速类型请求格式核心代码加速 <a href="https://cdn.statically.io/wp/c/:version/:file">https://cdn.statically.io/wp/c/:version/:file</a><br>插件加速 <a href="https://cdn.statically.io/wp/p/:plugin/:version/:file">https://cdn.statically.io/wp/p/:plugin/:version/:file</a><br>主题加速 <a href="https://cdn.statically.io/wp/t/:theme/:version/:file">https://cdn.statically.io/wp/t/:theme/:version/:file</a></p>
<p>因为我不用这个，所以就不举例子了，可以自己多琢磨琢磨。<br>截屏整个网页</p>
<p>  进入某个网站，对该网站页面整个截屏，实现的就是这样的一个功能。<br>选项请求格式直接截屏 <a href="https://cdn.statically.io/screenshot/:url">https://cdn.statically.io/screenshot/:url</a><br>返回移动设备视角 <a href="https://cdn.statically.io/screenshot/device=mobile/:url">https://cdn.statically.io/screenshot/device=mobile/:url</a><br>整个截屏 <a href="https://cdn.statically.io/screenshot/full=true/:url">https://cdn.statically.io/screenshot/full=true/:url</a></p>
<p>注：如果需要将选项整合到一起，用逗号隔开即可。</p>
<p>举个例子：<a href="https://cdn.statically.io/screenshot/google.com">https://cdn.statically.io/screenshot/google.com</a><br>生成文本头像<br>选项请求格式默认生成（默认是方形） <a href="https://cdn.statically.io/avatar/:text">https://cdn.statically.io/avatar/:text</a><br>设置尺寸 <a href="https://cdn.statically.io/avatar/s=:pixel/:text">https://cdn.statically.io/avatar/s=:pixel/:text</a><br>设置形状（圆形：circle，椭圆：rounded） <a href="https://cdn.statically.io/avatar/shape=circle/:text">https://cdn.statically.io/avatar/shape=circle/:text</a></p>
<p>看看样例：<br><a href="https://cdn.statically.io/avatar/qiantigers">https://cdn.statically.io/avatar/qiantigers</a><br><a href="https://cdn.statically.io/avatar/s=480/qiantigers">https://cdn.statically.io/avatar/s=480/qiantigers</a><br><a href="https://cdn.statically.io/avatar/shape=circle/qiantigers">https://cdn.statically.io/avatar/shape=circle/qiantigers</a><br>生成文字图片<br>选项请求格式默认生成 <a href="https://cdn.statically.io/og/:text.jpg">https://cdn.statically.io/og/:text.jpg</a><br>设置暗黑背景（默认明亮背景） <a href="https://cdn.statically.io/og/theme=dark/:text.jpg">https://cdn.statically.io/og/theme=dark/:text.jpg</a><br>设置尺寸 <a href="https://cdn.statically.io/og/fontsize=:numeric/:text.jpg">https://cdn.statically.io/og/fontsize=:numeric/:text.jpg</a><br>生成png格式图像（默认是jpg） <a href="https://cdn.statically.io/og/:text.png">https://cdn.statically.io/og/:text.png</a></p>
<p>举个例子：<a href="https://cdn.statically.io/og/Qiantigers%20:%20www.qian.blue.jpg">https://cdn.statically.io/og/Qiantigers%20:%20www.qian.blue.jpg</a><br>结语</p>
<p>  截屏、文字头像、文字图片用的频率一般般，但前三者的使用却是无处不在，有效使用，提高你的开发效率吧。</p>
]]></content>
      <tags>
        <tag>免费</tag>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>freenom域名自动续期</title>
    <url>/posts/60166/</url>
    <content><![CDATA[<p>原文：<a href="https://github.com/luolongfei/freenom">https://github.com/luolongfei/freenom</a></p>
<h3 id="📢-注意"><a href="#📢-注意" class="headerlink" title="📢 注意"></a>📢 注意</h3><ul>
<li>之前因为 GitHub Action 事件导致本项目被封禁，而后我短暂将项目转移到了 <a href="https://github.com/luolongfei/next-freenom">https://github.com/luolongfei/next-freenom</a> 仓库，然后在 <a href="https://github.com/Mattraks">@Mattraks</a> 的提醒下，通过特别的方式恢复了本仓库。</li>
<li>本次封禁导致的直接后果是以前的<code>issues</code>全部丢失，以及近<code>1.8k</code>的<code>star</code>数重新归零，在动力上面确实有受到影响，不过也不会有太大影响，本项目依然长期维护，如果项目有帮到你，欢迎 star。</li>
<li>狡兔三窟，临时仓库 <a href="https://github.com/luolongfei/next-freenom">https://github.com/luolongfei/next-freenom</a> 也是备用仓库，如若本仓库再次失联，可以移步到备用仓库获取最新消息，正常情况下以后的开发维护依然在本仓库进行。</li>
<li>推荐 <a href="https://github.com/luolongfei/freenom#-%E6%96%B9%E5%BC%8F%E4%B8%80%E9%80%9A%E8%BF%87-docker-%E9%83%A8%E7%BD%B2%E6%8E%A8%E8%8D%90%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F">通过 Docker 方式部署</a>，或者参考下方文档直接搬运到 <a href="https://github.com/luolongfei/freenom#-%E6%96%B9%E5%BC%8F%E4%BA%8C%E9%80%9A%E8%BF%87%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2%E6%8E%A8%E8%8D%90%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8">腾讯云函数部署</a> ，腾讯云函数不需要有自己的服务器。</li>
</ul>
<h3 id="📃-引言"><a href="#📃-引言" class="headerlink" title="📃 引言"></a>📃 引言</h3><p>众所周知，Freenom是地球上唯一一个提供免费顶级域名的商家，不过需要每年续期，每次续期最多一年。由于我申请了一堆域名，而且不是同一时段申请的， 所以每次续期都觉得折腾，于是就写了这个自动续期的脚本。</p>
<h3 id="🍭-效果"><a href="#🍭-效果" class="headerlink" title="🍭 效果"></a>🍭 效果</h3><p><a href="https://camo.githubusercontent.com/6fc6d19ebf59fcc4f7c598ee10239cf08ff1ab7c99c485d04400102af05e5031/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133395272642e706e67"><img src="https://camo.githubusercontent.com/6fc6d19ebf59fcc4f7c598ee10239cf08ff1ab7c99c485d04400102af05e5031/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133395272642e706e67" alt="邮件示例"></a></p>
<p>无论是续期成败或者脚本执行出错，都会收到的程序发出的邮件。如果是续期成败相关的邮件，邮件会包括未续期域名的到期天数等内容。 邮件参考了微信发送的注销公众号的邮件样式。</p>
<h3 id="🎁-事前准备"><a href="#🎁-事前准备" class="headerlink" title="🎁 事前准备"></a>🎁 事前准备</h3><ul>
<li>VPS：随便一台服务器都行，系统推荐<code>Centos7</code>或者<code>Debian</code>，另外 PHP 版本需在<code>php7.2</code>及以上。如果你没有服务器，推荐参考下方文档部署到 <a href="https://github.com/luolongfei/freenom#-%E6%96%B9%E5%BC%8F%E4%BA%8C%E9%80%9A%E8%BF%87%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E9%83%A8%E7%BD%B2%E6%8E%A8%E8%8D%90%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8">腾讯云函数</a> 。</li>
<li>送信邮箱（可选）：为了方便理解又称机器人邮箱，用于发送通知邮件。目前针对<code>Gmail</code>、<code>QQ邮箱</code>、<code>163邮箱</code>以及<code>Outlook邮箱</code>，程序会自动判断送信邮箱类型并使用合适的配置。 如果你使用的是其它第三方邮箱或者自建邮件服务，那么请参考 <a href="https://github.com/luolongfei/freenom/blob/main/.env.example">.env.example</a> 文件中与邮件配置相关的注释进行配置。</li>
<li>收信邮箱（可选）：用于接收机器人发出的通知邮件。</li>
<li>上面的<code>送信邮箱</code>和<code>收信邮箱</code>是可选项，因为目前程序已支持<code>邮件送信</code> / <code>Telegram Bot</code> / <code>企业微信</code> / <code>Server 酱</code> / <code>Bark</code>等送信方式，仅当你使用<code>邮件送信</code>的时候，<code>送信邮箱</code>和<code>收信邮箱</code> 才是必须的，其它送信方式所需请参考下面的 <a href="https://github.com/luolongfei/freenom#-%E9%85%8D%E7%BD%AE%E9%80%81%E4%BF%A1%E5%8A%9F%E8%83%BD">配置送信功能</a> 。</li>
<li>耐心。</li>
</ul>
<h3 id="📪-配置送信功能"><a href="#📪-配置送信功能" class="headerlink" title="📪 配置送信功能"></a>📪 配置送信功能</h3><p>此处会分别介绍<code>邮件送信</code> / <code>Telegram Bot</code> / <code>企业微信</code> / <code>Server 酱</code> / <code>Bark</code>送信方式的配置方法，以及其所需的资料，你可以任选一种送信方式进行配置，直接跳到对应的文档查看即可。 如果你是 IOS 用户，推荐使用 <code>Bark</code> 送信方式，一切尽在掌握的感觉很好。其它平台的用户根据自己喜好选择可接受的送信方式即可。这里非常不推荐使用<code>Server 酱</code>送信，<code>Server 酱</code>每日送信条数的限制，以及需要开会员才能直接看到送信内容，否则需要跳到 <code>Server 酱</code> 网站才能查看内容，都是不推荐的原因。同样的配置完全可以直接使用<code>企业微信</code>送信方式，<code>企业微信</code>送信直接在普通微信客户端就能看到信件内容。</p>
<p><em>快速到文档指定位置：</em></p>
<p><a href="https://github.com/luolongfei/freenom#%E9%82%AE%E4%BB%B6%E9%80%81%E4%BF%A1">邮件送信</a></p>
<p><a href="https://github.com/luolongfei/freenom#Telegram-Bot">Telegram Bot</a></p>
<p><a href="https://github.com/luolongfei/freenom#%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1">企业微信</a></p>
<p><a href="https://github.com/luolongfei/freenom#Server-%E9%85%B1">Server 酱</a>（不推荐）</p>
<p><a href="https://github.com/luolongfei/freenom#Bark-%E9%80%81%E4%BF%A1">Bark 送信</a></p>
<h4 id="邮件送信"><a href="#邮件送信" class="headerlink" title="邮件送信"></a>邮件送信</h4><p>下面分别介绍<code>Gmail</code>、<code>QQ邮箱</code>以及<code>163邮箱</code>的设置，你只用看自己需要的部分。注意，<code>QQ邮箱</code>与<code>163邮箱</code>均使用<code>账户加授权码</code>的方式登录， <code>谷歌邮箱</code>使用<code>账户加密码</code>或者<code>账户加授权码</code>的方式登录，请知悉。另外还想吐槽一下，国产邮箱你得花一毛钱给邮箱提供方发一条短信才能拿到授权码。</p>
<p><em>（点击即可展开或收起）</em></p>
<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 47); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">设置Gmail</summary><br style="box-sizing: border-box;"><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">1、在<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">设置&gt;转发和POP/IMAP</code>中，勾选</p><ul dir="auto" style="box-sizing: border-box; padding-left: 2em; margin-top: 0px; margin-bottom: 16px;"><li style="box-sizing: border-box;">对所有邮件启用 POP</li><li style="box-sizing: border-box; margin-top: 0.25em;">启用 IMAP</li></ul><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/9dd9133768961d8588901418e90d6ad1db8d78337777d5b87c17d2e28b157c28/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133744b73672e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/9dd9133768961d8588901418e90d6ad1db8d78337777d5b87c17d2e28b157c28/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133744b73672e706e67" alt="gmail配置01" title="gmail配置01" data-canonical-src="https://s2.ax1x.com/2020/01/31/13tKsg.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">然后保存更改。</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">2、允许不够安全的应用</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">登录谷歌邮箱后，访问<span>&nbsp;</span><a href="https://myaccount.google.com/u/0/lesssecureapps?pli=1&amp;pageId=none" rel="nofollow" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;">谷歌权限设置界面</a><span>&nbsp;</span>，启用允许不够安全的应用。</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1ec85c95621bfc1683b4b6d290a37a1ae09ee7d6e6884983742934dff15c137f/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f313339324b482e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/1ec85c95621bfc1683b4b6d290a37a1ae09ee7d6e6884983742934dff15c137f/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f313339324b482e706e67" alt="gmail配置02" title="gmail配置02" data-canonical-src="https://s2.ax1x.com/2020/01/31/1392KH.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">另外，若遇到提示</p><blockquote style="box-sizing: border-box; margin: 0px 0px 16px; padding: 0px 1em; color: var(--color-fg-muted); border-left: 0.25em solid var(--color-border-default);"><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0px;">不允许访问账户</p></blockquote><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">登录谷歌邮箱后，去<span>&nbsp;</span><a href="https://accounts.google.com/b/0/DisplayUnlockCaptcha" rel="nofollow" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;">gmail的这个界面</a><span>&nbsp;</span>点击允许。这种情况较为少见。</p><hr style="box-sizing: content-box; height: 0.25em; overflow: hidden; margin: 24px 0px; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: var(--color-border-default); border: 0px; padding: 0px;"></details>

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 47); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">设置QQ邮箱</summary><br style="box-sizing: border-box;"><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">在<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">设置&gt;账户&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</code>下，开启<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">POP3/SMTP服务</code></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d919fed60cb19ef83a4d12108aaa9c4224431b54393f5d7e2a543ce6ec477755/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f313363494b412e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/d919fed60cb19ef83a4d12108aaa9c4224431b54393f5d7e2a543ce6ec477755/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f313363494b412e706e67" alt="qq邮箱配置01" title="qq邮箱配置01" data-canonical-src="https://s2.ax1x.com/2020/01/31/13cIKA.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">此时坑爹的QQ邮箱会要求你用手机发送一条短信给腾讯，发送完了点一下<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">我已发送</code></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/f2875b489cef9c91cea4dad6fc2c54a3e9e5d1a68ffde368fe8ae2f009e179c8/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133633476642e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/f2875b489cef9c91cea4dad6fc2c54a3e9e5d1a68ffde368fe8ae2f009e179c8/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133633476642e706e67" alt="qq邮箱配置02" title="qq邮箱配置02" data-canonical-src="https://s2.ax1x.com/2020/01/31/13c4vd.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">然后你就能看到你的邮箱授权码了，使用邮箱账户加授权码即可登录，记下授权码</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/ed25fdf0dfda956cc8c23b50214c162cc648a45563c1cd66fa97b5b73ef34399/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133635462742e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/ed25fdf0dfda956cc8c23b50214c162cc648a45563c1cd66fa97b5b73ef34399/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133635462742e706e67" alt="qq邮箱配置03" title="qq邮箱配置03" data-canonical-src="https://s2.ax1x.com/2020/01/31/13cTbt.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/be02667e951699cc8a13841ce664d385dd67f20de46eb69d5b0b777b0d7a78d0/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133636f44492e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/be02667e951699cc8a13841ce664d385dd67f20de46eb69d5b0b777b0d7a78d0/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133636f44492e706e67" alt="qq邮箱配置04" title="qq邮箱配置04" data-canonical-src="https://s2.ax1x.com/2020/01/31/13coDI.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><hr style="box-sizing: content-box; height: 0.25em; overflow: hidden; margin: 24px 0px; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: var(--color-border-default); border: 0px; padding: 0px;"></details>

<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 47); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">设置163邮箱</summary><br style="box-sizing: border-box;"><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">在<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">设置&gt;POP3/SMTP/IMAP</code>下，开启<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">POP3/SMTP服务</code>和<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">IMAP/SMTP服务</code>并保存</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/41ffb7ab319d5ec7ab64c0679eed59500f5ceb4f95e933ca74afe671b58abb9a/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133574b5a6e2e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/41ffb7ab319d5ec7ab64c0679eed59500f5ceb4f95e933ca74afe671b58abb9a/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133574b5a6e2e706e67" alt="163邮箱配置01" title="163邮箱配置01" data-canonical-src="https://s2.ax1x.com/2020/01/31/13WKZn.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/79dab5c92eecb2f0b5926a52a6b15d7164d4bf4bd93eeaacfc3d4378d48d774c/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133575149302e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/79dab5c92eecb2f0b5926a52a6b15d7164d4bf4bd93eeaacfc3d4378d48d774c/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133575149302e706e67" alt="163邮箱配置02" title="163邮箱配置02" data-canonical-src="https://s2.ax1x.com/2020/01/31/13WQI0.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">现在点击侧边栏的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">客户端授权密码</code>，并获取授权码，你看到画面可能和我不一样，因为我已经获取了授权码，所以只有<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">重置授权码</code>按钮，这里自己根据网站提示申请获取授权码，网易和腾讯一样恶心，需要你用手机给它发一条短信才能拿到授权码</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/185fe465f20f4f41a4b38cce017c381cade18b2a912908551a75b13d654abd32/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133574d61712e706e67" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;"><img src="https://camo.githubusercontent.com/185fe465f20f4f41a4b38cce017c381cade18b2a912908551a75b13d654abd32/68747470733a2f2f73322e617831782e636f6d2f323032302f30312f33312f3133574d61712e706e67" alt="163邮箱配置03" title="163邮箱配置03" data-canonical-src="https://s2.ax1x.com/2020/01/31/13WMaq.png" style="box-sizing: content-box; border-style: none; max-width: 100%; background-color: var(--color-canvas-default);"></a></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">163 邮箱送信后，接收方如果没收到可以在垃圾邮件里面找一下。</p><hr style="box-sizing: content-box; height: 0.25em; overflow: hidden; margin: 24px 0px; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: var(--color-border-default); border: 0px; padding: 0px;"></details>

<p>上面介绍了三种邮箱的设置方法，如果你不想使用邮件送信，而<strong>由于程序默认启用邮件送信方式，故不配置邮件送信的话，一定要记得关闭邮件推送方式。</strong> 将根目录下的<code>.env</code>文件中的<code>MAIL_ENABLE</code>的值改为<code>0</code>即可关闭邮件推送方式。</p>
<p><em>邮件 送信部分完。</em></p>
<h4 id="Telegram-Bot"><a href="#Telegram-Bot" class="headerlink" title="Telegram Bot"></a>Telegram Bot</h4><p>1、将<code>.env</code>文件中的<code>TELEGRAM_BOT_ENABLE</code>的值改为<code>1</code>，即可启用 Telegram Bot 送信功能</p>
<p>2、在 Telegram 客户端中搜索<code>@userinfobot</code>，并打开聊天窗口</p>
<p>3、发送<code>/start</code>给<code>@userinfobot</code>即可以获取自己的 Id，将<code>.env</code>文件中的<code>TELEGRAM_CHAT_ID</code>的值改为前面获取到的 Id</p>
<p>4、在 Telegram 客户端中搜索<code>@BotFather</code>，并打开聊天窗口</p>
<p>5、发送<code>/newbot</code>给<code>@BotFather</code>，然后根据提示创建，创建完成后根据图示操作获取<code>token</code></p>
<p><a href="https://imgtu.com/i/I1gpFA"><img src="https://camo.githubusercontent.com/e1a7d175fa75f7001237a41567da7723512b59c41deade14b151b173a17f66dd/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30372f4931677046412e706e67" alt="I1gpFA.png"></a></p>
<p>6、将<code>.env</code>文件中的<code>TELEGRAM_BOT_TOKEN</code>的值改为上一步获取的<code>token</code>值</p>
<p>7、在 Telegram 客户端中搜索你创建的机器人的账户，上面示例中机器人账户为<code>@fat_tiger_bot</code>，请替换为你自己的。找到机器人账户并打开聊天对话框，点击聊天输入框中的 <code>/start</code> 按钮或者直接给机器人发送 <code>/start</code>，以启用机器人</p>
<p>8、（可选）为 Telegram Bot 设置代理。针对国内网络环境，可将<code>.env</code>文件中的<code>TELEGRAM_PROXY</code>的值改为代理值，具体参考<code>.env</code>文件中的注释</p>
<p>更多与 Telegram Bot 相关内容请参考：<a href="https://core.telegram.org/bots#6-botfather">官方文档</a></p>
<p><em>Telegram bot 送信部分完。</em></p>
<h4 id="企业微信"><a href="#企业微信" class="headerlink" title="企业微信"></a>企业微信</h4><p>1、在电脑上打开 <a href="https://work.weixin.qq.com/">https://work.weixin.qq.com</a> ，注册一个企业。注册的过程需要填的信息，腾讯已经做了详尽的说明，根据提示操作即可</p>
<p>2、注册成功后，会跳到注册成功画面，点击页面最下方的<code>进入管理后台</code>按钮，将打开管理后台画面</p>
<p>3、在管理后台，点击<code>应用管理</code>，然后往下翻，在<code>自建</code>部分找到并点击<code>创建应用</code></p>
<p><a href="https://imgtu.com/i/I8160O"><img src="https://camo.githubusercontent.com/be64123f3154e0526815c370627a37c0753062ea47bfde727e4f1131b1b8101e/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f49383136304f2e706e67" alt="wechat_01.png"></a></p>
<p>4、创建应用，应用名称随意，注意下面的<code>可见范围</code>选公司名，以使得公司下的所有人可见</p>
<p><a href="https://imgtu.com/i/I8N4IK"><img src="https://camo.githubusercontent.com/7f029396ad8cc686016d3f8fa1c8a41ac8917cc888c6f17a3cca043ebe20d239/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f49384e34494b2e706e67" alt="wechat_02.png"></a></p>
<p>5、应用创建完成后，会跳到应用详情页面，在详情页面，你可以拿到<code>AgentId</code>和<code>Secret</code>的值， 在<code>.env</code>文件中，将<code>WECHAT_AGENT_ID</code>的值改为这里拿到的 <code>AgentId</code> 的值，将<code>WECHAT_CORP_SECRET</code>的值改为这里拿到的<code>Secret</code>的值</p>
<p><a href="https://imgtu.com/i/I8auAP"><img src="https://camo.githubusercontent.com/9ee2af41f423eb34ae5b4e8e308ee2fbb4968cf62ace4488dff4007191cad227/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f4938617541502e706e67" alt="wechat_03.png"></a></p>
<p>注意，此处要查看<code>Secret</code>的值的话，需要先安装<code>企业微信 app</code>，点击<code>发送</code>后会在<code>企业微信 app</code>客户端收到<code>Secret</code>的值，将值记录下来后，便可以卸载<code>企业微信 app</code>，然后记得将 <code>.env</code> 文件中的<code>WECHAT_CORP_SECRET</code>的值改为这里拿到的<code>Secret</code>的值</p>
<p><a href="https://imgtu.com/i/I8009f"><img src="https://camo.githubusercontent.com/6aaded5f92027e6da789458fee07c1dee4078600ab3b1226dc16d25c8e9fbedf/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f4938303039662e706e67" alt="wechat_04.png"></a></p>
<p><a href="https://imgtu.com/i/I8rqEj"><img src="https://camo.githubusercontent.com/bcb63dfd33e7baf4a3ef262393374973ce8c8b9e12f1ca7f814b62a43510c9ef/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f49387271456a2e706e67" alt="wechat_05.png"></a></p>
<p>6、获取<code>企业 ID</code>，并将<code>.env</code>文件中<code>WECHAT_CORP_ID</code>的值改为<code>企业 ID</code>的值</p>
<p><a href="https://imgtu.com/i/I8sLLD"><img src="https://camo.githubusercontent.com/0380ce92920d81fe0f072fef07741a62c482c83335e2ce618411cca5d715fc51/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f4938734c4c442e706e67" alt="wechat_06.png"></a></p>
<p>7、推送消息到微信客户端。在管理后台点击<code>我的企业</code>，再点击<code>微信插件</code>，接着往下翻，找到<code>邀请关注</code>部分的二维码，用微信扫码关注即可</p>
<p><a href="https://imgtu.com/i/I86TKK"><img src="https://camo.githubusercontent.com/5dd1588c0e8ebbda5d1bcab8f249608b6ea9c64792ecaf285803d58200ae957c/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f493836544b4b2e706e67" alt="wechat_07.png"></a></p>
<p>关注后，就可以在微信收到推送消息了</p>
<p>8、将<code>.env</code>文件中的<code>WECHAT_ENABLE</code>的值改为<code>1</code>，以启用微信推送功能</p>
<p><em>企业微信 送信部分完。</em></p>
<h4 id="Server-酱"><a href="#Server-酱" class="headerlink" title="Server 酱"></a>Server 酱</h4><p>参考 <a href="https://sct.ftqq.com/forward">Server 酱 教程之企业微信应用消息配置说明</a> ，这里的配置过程跟上面的<code>企业微信</code>配置过程一模一样，所以同样的配置，还是建议直接使用上面的<code>企业微信</code> ，不需要开会员也能直接查看消息，不用跳到<code>Server 酱</code>的网页查看消息，也不会有每天 5 条送信次数的限制，何乐而不为。</p>
<p>上一步配置完成，你会得到一个<code>SendKey</code>，在<code>.env</code>文件中，将<code>SCT_SEND_KEY</code>的值改为这个<code>SendKey</code>所对应的值，然后再将<code>SCT_ENABLE</code>的值改为<code>1</code>，即可启用<code>Server 酱</code>送信。</p>
<p><em>Server 酱 送信部分完。</em></p>
<h4 id="Bark-送信"><a href="#Bark-送信" class="headerlink" title="Bark 送信"></a>Bark 送信</h4><p>Bark 是一款 IOS 端用于推送自定义通知的 app，是个人开发者在维护，项目地址为 <a href="https://github.com/Finb/Bark">https://github.com/Finb/Bark</a> ，客户端和服务端均开源。</p>
<p>1、前往 App Store 搜索<code>Bark</code>并安装</p>
<p><a href="https://imgtu.com/i/I845nI"><img src="https://camo.githubusercontent.com/b593da5d937ebaf5d09960f02994e8dcfcf1fac5c106f25a286d2cc5e3c08198/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f493834356e492e706e67" alt="bark_01.png"></a></p>
<p>2、打开<code>Bark</code> app，点击<code>注册设备</code>，记得允许通知，然后就可以看到，右边红框中两个<code>/</code>之间的字符便是你的<code>BARK_KEY</code>，请将<code>.env</code>文件中的<code>BARK_KEY</code>的值设为此处获取的值</p>
<p><a href="https://imgtu.com/i/I8Iqyj"><img src="https://camo.githubusercontent.com/14f7f6014cf7edcb67f1f87069b324ad662fcb25abe041e185582375ec335615/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30382f49384971796a2e706e67" alt="bark_02.png"></a></p>
<p>3、将<code>.env</code>文件中的<code>BARK_ENABLE</code>的值设为<code>1</code>，以启用<code>Bark</code>送信功能</p>
<p><em>Bark 送信部分完。</em></p>
<hr>
<p><em>与 配置送信功能 相关的篇幅完。下面开始讲本项目的三种使用方式，一种是通过 Docker，另一种是通过腾讯云函数，再一种是直接拉取源码部署，推荐使用 Docker 方式，无需纠结环境。</em></p>
<h3 id="⛵-方式一：通过-Docker-部署（推荐，最简单的部署方式）"><a href="#⛵-方式一：通过-Docker-部署（推荐，最简单的部署方式）" class="headerlink" title="⛵ 方式一：通过 Docker 部署（推荐，最简单的部署方式）"></a>⛵ 方式一：通过 Docker 部署（推荐，最简单的部署方式）</h3><hr>
<p>Docker 仓库地址为： <a href="https://hub.docker.com/r/luolongfei/freenom">https://hub.docker.com/r/luolongfei/freenom</a> ，同样欢迎 star 。 此镜像支持的架构为<code>linux/amd64</code>，<code>linux/arm64</code>，<code>linux/ppc64le</code>，<code>linux/s390x</code>，<code>linux/386</code>，<code>linux/arm/v7</code>，<code>linux/arm/v6</code>， 理论上支持<code>群晖</code> 、<code>威联通</code>、<code>树莓派</code>以及各种类型的<code>VPS</code>。</p>
<h4 id="1、安装-Docker"><a href="#1、安装-Docker" class="headerlink" title="1、安装 Docker"></a>1、安装 Docker</h4><h5 id="1-1-以-root-用户登录，执行一键脚本安装-Docker"><a href="#1-1-以-root-用户登录，执行一键脚本安装-Docker" class="headerlink" title="1.1 以 root 用户登录，执行一键脚本安装 Docker"></a>1.1 以 root 用户登录，执行一键脚本安装 Docker</h5><p>升级源并安装软件（下面两行命令二选一，根据你自己的系统）</p>
<p>Debian / Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y wget vim</span><br></pre></td></tr></table></figure>

<p>CentOS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum update &amp;&amp; yum install -y wget vim</span><br></pre></td></tr></table></figure>

<p>执行此命令等候自动安装 Docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -qO- get.docker.com | bash</span><br></pre></td></tr></table></figure>

<p>说明：请使用 KVM 架构的 VPS，OpenVZ 架构的 VPS 不支持安装 Docker，另外 CentOS 8 不支持用此脚本来安装 Docker。 更多关于 Docker 安装的内容参考 <a href="https://docs.docker.com/engine/install/">Docker 官方安装指南</a> 。</p>
<h5 id="1-2-对-Docker-的一些命令操作"><a href="#1-2-对-Docker-的一些命令操作" class="headerlink" title="1.2 对 Docker 的一些命令操作"></a>1.2 对 Docker 的一些命令操作</h5><p>查看 Docker 安装版本等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>启动 Docker 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>查看 Docker 运行状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>将 Docker 服务加入开机自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h4 id="2、通过-Docker-部署域名续期脚本"><a href="#2、通过-Docker-部署域名续期脚本" class="headerlink" title="2、通过 Docker 部署域名续期脚本"></a>2、通过 Docker 部署域名续期脚本</h4><h5 id="2-1-用-Docker-创建并启动容器"><a href="#2-1-用-Docker-创建并启动容器" class="headerlink" title="2.1 用 Docker 创建并启动容器"></a>2.1 用 Docker 创建并启动容器</h5><p>命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name freenom --restart always -v $(pwd):/conf -v $(pwd)/logs:/app/logs luolongfei/freenom</span><br></pre></td></tr></table></figure>

<p>或者，如果你想自定义脚本执行时间，则命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name freenom --restart always -v $(pwd):/conf -v $(pwd)/logs:/app/logs -e RUN_AT=&quot;11:24&quot; luolongfei/freenom</span><br></pre></td></tr></table></figure>

<p>上面这条命令只比上上条命令多了个<code> -e RUN_AT=&quot;11:24&quot;</code>，其中<code>11:24</code>表示在北京时间每天的 11:24 执行续期任务，你可以自定义这个时间。 这里的<code>RUN_AT</code>参数同时也支持 CRON 命令里的时间形式，比如，<code> -e RUN_AT=&quot;9 11 * * *&quot;</code>，表示每天北京时间 11:09 执行续期任务， 如果你不想每天执行任务，只想隔几天执行，只用修改<code>RUN_AT</code>的值即可。</p>
<p><strong>注意：不推荐自定义脚本执行时间。因为你可能跟很多人定义的是同一个时间点，这样可能导致所有人都是同一时间向 Freenom 的服务器发起请求， 使得 Freenom 无法稳定提供服务。而如果你不自定义时间，程序会自动指定北京时间 06 ~ 23 点全时段随机的一个时间点作为执行时间， 每次重启容器都会自动重新指定。</strong></p>
<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 47); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">点我查看上方 Docker 命令的参数解释</summary><br style="box-sizing: border-box;"><table style="box-sizing: border-box; border-spacing: 0px; border-collapse: collapse; margin-top: 0px; margin-bottom: 16px; display: block; width: max-content; max-width: 100%; overflow: auto;"><thead style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><th align="left" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">命令</th><th align="left" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">含义</th></tr></thead><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">docker run</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">开始运行一个容器</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-d 参数</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">容器以后台运行并输出容器 ID</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">--name 参数</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">给容器分配一个识别符，方便将来的启动，停止，删除等操作</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">--restart 参数</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">配置容器启动类型，always 即为 docker 服务重新启动时自动启动本容器</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-v 参数</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">挂载卷（volume），冒号后面是容器的路径，冒号前面是宿主机的路径（只支持绝对路径），<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">$(pwd)</code>表示当前目录，如果是 Windows 系统，则可用<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">$&#123;PWD&#125;</code>替换此处的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">$(pwd)</code></td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-e 参数</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">指定容器中的环境变量</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">luolongfei/freenom</td><td align="left" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">这是从 docker hub 下载回来的镜像完整路径名</td></tr></tbody></table></details>

<p>至此，你的自动续期容器就跑起来了，执行<code>ls -a</code>后你就可以看到在你的当前目录下，有一个<code>.env</code>文件和一个<code>logs</code>目录，<code>logs</code>目录里面存放的是程序日志， 而<code>.env</code>则是配置文件，现在直接执行<code>vim .env</code> 将<code>.env</code>文件里的所有配置项改为你自己的并保存即可。然后重启容器，如果配置正确的话，便很快可以收到相关邮件。</p>
<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 47); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">点我查看 .env 文件中部分配置项的含义</summary><br style="box-sizing: border-box;"><table style="box-sizing: border-box; border-spacing: 0px; border-collapse: collapse; margin-top: 0px; margin-bottom: 16px; display: block; width: max-content; max-width: 100%; overflow: auto;"><thead style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><th align="center" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">变量名</th><th align="center" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">含义</th><th align="center" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">默认值</th><th align="center" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">是否必须</th><th align="center" style="box-sizing: border-box; padding: 6px 13px; font-weight: 600; border: 1px solid var(--color-border-default);">备注</th></tr></thead><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">FREENOM_USERNAME</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Freenom 账户</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">只支持邮箱账户，如果你是使用第三方社交账户登录的用户，请在 Freenom 管理页面绑定邮箱，绑定后即可使用邮箱账户登录</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">FREENOM_PASSWORD</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">Freenom 密码</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">某些特殊字符可能需要转义，详见<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">.env</code>文件内注释</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">MULTIPLE_ACCOUNTS</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">多账户支持</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">否</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">多个账户和密码的格式必须是“<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">&lt;账户1&gt;@&lt;密码1&gt;|&lt;账户2&gt;@&lt;密码2&gt;|&lt;账户3&gt;@&lt;密码3&gt;</code>”，注意不要省略“&lt;&gt;”符号，否则无法正确匹配。如果设置了多账户，上面的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">FREENOM_USERNAME</code>和<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">FREENOM_PASSWORD</code>可不设置</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">MAIL_USERNAME</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">机器人邮箱账户</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">支持<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Gmail</code>、<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">QQ邮箱</code>、<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">163邮箱</code>以及<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Outlook邮箱</code>，尽可能使用<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">163邮箱</code>或者<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">QQ邮箱</code>而非<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Gmail</code>。因为谷歌的安全机制，每次在新设备登录<span>&nbsp;</span><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Gmail</code><span>&nbsp;</span>都会先被限制，需要手动解除限制才行。具体的配置方法参考「<span>&nbsp;</span><a href="https://github.com/luolongfei/freenom#-%E9%85%8D%E7%BD%AE%E9%80%81%E4%BF%A1%E5%8A%9F%E8%83%BD" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;">配置送信功能</a><span>&nbsp;</span>」</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">MAIL_PASSWORD</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">机器人邮箱密码</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Gmail</code>填密码，<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">QQ邮箱</code>或<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">163邮箱</code>填授权码</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">TO</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">接收通知的邮箱</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">你自己最常用的邮箱，用来接收机器人邮箱发出的域名相关邮件</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">MAIL_ENABLE</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是否启用邮件推送功能</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">1</code></td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">否</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">1</code>：启用<br style="box-sizing: border-box;"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">0</code>：不启用<br style="box-sizing: border-box;">默认启用，如果设为<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">0</code>，不启用邮件推送功能，则上面的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">MAIL_USERNAME</code>、<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">MAIL_PASSWORD</code>、<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">TO</code>变量变为非必须，可不设置</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">TELEGRAM_CHAT_ID</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">你的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">chat_id</code></td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">否</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">通过发送<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">/start</code>给<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">@userinfobot</code>可以获取自己的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">id</code></td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">TELEGRAM_BOT_TOKEN</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">你的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Telegram bot</code>的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">token</code></td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">-</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">否</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"></td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-subtle); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">TELEGRAM_BOT_ENABLE</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">是否启用<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">Telegram Bot</code>推送功能</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">0</code></td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">否</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">1</code>：启用<br style="box-sizing: border-box;"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">0</code>：不启用<br style="box-sizing: border-box;">默认不启用，如果设为<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">1</code>，则必须设置上面的<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">TELEGRAM_CHAT_ID</code>和<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">TELEGRAM_BOT_TOKEN</code>变量</td></tr><tr style="box-sizing: border-box; background-color: var(--color-canvas-default); border-top: 1px solid var(--color-border-muted);"><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">NOTICE_FREQ</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">通知频率</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">1</code></td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);">否</td><td align="center" style="box-sizing: border-box; padding: 6px 13px; border: 1px solid var(--color-border-default);"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">0</code>：仅当有续期操作的时候<br style="box-sizing: border-box;"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">1</code>：每次执行</td></tr></tbody></table><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><strong style="box-sizing: border-box; font-weight: 600;">更多配置项含义，请参考<span>&nbsp;</span><a href="https://github.com/luolongfei/freenom/blob/main/.env.example" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;">.env.example</a><span>&nbsp;</span>文件中的注释。</strong></p></details>

<blockquote>
<p>如何验证你的配置是否正确呢？</p>
</blockquote>
<p>修改并保存<code>.env</code>文件后，执行<code>docker restart freenom</code>重启容器，等待 5 秒钟左右，然后执行<code>docker logs freenom</code>查看输出内容， 观察输出内容中有<code>执行成功</code> 字样，则表示配置无误。如果你还来不及配置送信邮箱等内容，可先停用邮件功能。</p>
<blockquote>
<p>如何升级到最新版或者重新部署呢？</p>
</blockquote>
<p>在<code>.env</code>所在目录，执行<code>docker rm -f freenom</code>删除现有容器，然后再执行 <code>docker rmi -f luolongfei/freenom</code> 删除旧的镜像，然后再执行上面的 <code>docker run -d --name freenom --restart always -v $(pwd):/conf -v $(pwd)/logs:/app/logs luolongfei/freenom</code> 重新部署即可，这样部署后就是最新的代码了。当然，新版对应的<code>.env</code>文件可能有变动，不必担心，程序会自动更新<code>.env</code>文件内容，并将已有的配置迁移过去。</p>
<h5 id="2-2-后期容器处理常用命令"><a href="#2-2-后期容器处理常用命令" class="headerlink" title="2.2 后期容器处理常用命令"></a>2.2 后期容器处理常用命令</h5><p>查看容器在线状态及大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -as</span><br></pre></td></tr></table></figure>

<p>查看容器的运行输出日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs freenom</span><br></pre></td></tr></table></figure>

<p>重新启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart freenom</span><br></pre></td></tr></table></figure>

<p>停止容器的运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop freenom</span><br></pre></td></tr></table></figure>

<p>移除容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm $name</span><br></pre></td></tr></table></figure>

<p>查看 docker 容器占用 CPU，内存等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stats --no-stream</span><br></pre></td></tr></table></figure>

<p><em>有关容器部署的内容结束。</em></p>
<h3 id="🕹-方式二：通过腾讯云函数部署（推荐无服务器的用户使用）"><a href="#🕹-方式二：通过腾讯云函数部署（推荐无服务器的用户使用）" class="headerlink" title="🕹 方式二：通过腾讯云函数部署（推荐无服务器的用户使用）"></a>🕹 方式二：通过腾讯云函数部署（推荐无服务器的用户使用）</h3><hr>
<h4 id="1、下载腾讯云函数版的压缩包"><a href="#1、下载腾讯云函数版的压缩包" class="headerlink" title="1、下载腾讯云函数版的压缩包"></a>1、下载腾讯云函数版的压缩包</h4><p>腾讯云函数版将与主版同步维护更新，推荐没有自己服务器的用户使用，最新版本号为<code>v0.4.3</code>。下载地址： <a href="https://github.com/luolongfei/freenom/releases/download/v0.4.3/freenom_scf.zip">https://github.com/luolongfei/freenom/releases/download/v0.4.3/freenom_scf.zip</a></p>
<p>下载后你将得到一个 zip 文件，将 zip 文件放到你能找到的任意目录，后面我们将以 zip 文件的形式上传到腾讯云函数。</p>
<h4 id="2、创建腾讯云函数"><a href="#2、创建腾讯云函数" class="headerlink" title="2、创建腾讯云函数"></a>2、创建腾讯云函数</h4><p>直接访问腾讯云函数控制台创建云函数： <a href="https://console.cloud.tencent.com/scf/list-create?rid=5&amp;ns=default&amp;createType=empty">https://console.cloud.tencent.com/scf/list-create?rid=5&amp;ns=default&amp;createType=empty</a> ，按照下图所示的说明进行创建。如果无法看清图片，可访问： <a href="https://github.com/luolongfei/freenom/blob/main/resources/screenshot/scf.png">https://github.com/luolongfei/freenom/blob/main/resources/screenshot/scf.png</a> 或者 <a href="https://z3.ax1x.com/2021/10/14/5lMweU.png">https://z3.ax1x.com/2021/10/14/5lMweU.png</a> 查看原图，也可以直接点击图片查看原图。</p>
<p><a href="https://z3.ax1x.com/2021/10/14/5lMweU.png"><img src="https://camo.githubusercontent.com/3d69e3543159f7113e01343bd78b09829f92bfc51458be894136a97a40f82bc6/68747470733a2f2f7a332e617831782e636f6d2f323032312f31302f31342f356c4d7765552e706e67" alt="scf01"></a></p>
<p>按照上图所示部署完成后，可以点击云函数的名称进入云函数管理画面，管理画面点击函数代码，然后往下翻可看到<code>部署</code>与<code>测试</code>按钮，点击<code>测试</code>，稍等几秒钟，即可看到输出日志， 根据输出日志判断配置以及部署是否正确。</p>
<p><a href="https://z3.ax1x.com/2021/10/14/5l3oHf.png"><img src="https://camo.githubusercontent.com/5430efa8d5a6b8b3f7151738b7345e3763eac5b916153e4690f863b317b8ccb4/68747470733a2f2f7a332e617831782e636f6d2f323032312f31302f31342f356c336f48662e706e67" alt="scf02"></a></p>
<p>如果你在创建腾讯云函数的时候，某些环境变量忘记填了，或者在创建腾讯云函数后想要修改或者新增某些环境变量，可以参考这里操作，无需重建：</p>
<p><a href="https://imgtu.com/i/I13Ku8"><img src="https://camo.githubusercontent.com/2d0eac33807186bdd7b15b410484171d7b0f0b2b0a67e04600e6015dc1f3f852/68747470733a2f2f7a332e617831782e636f6d2f323032312f31312f30372f4931334b75382e706e67" alt="scf03"></a></p>
<p><em>有关腾讯云函数部署的内容结束。</em></p>
<h3 id="🚧-方式三：直接拉取源码部署"><a href="#🚧-方式三：直接拉取源码部署" class="headerlink" title="🚧 方式三：直接拉取源码部署"></a>🚧 方式三：直接拉取源码部署</h3><hr>
<p>所有操作均在Centos7系统下进行，其它Linux发行版大同小异</p>
<h4 id="1、获取源码"><a href="#1、获取源码" class="headerlink" title="1、获取源码"></a>1、获取源码</h4><p>创建文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/wwwroot/freenom &amp;&amp; cd /data/wwwroot/freenom</span><br></pre></td></tr></table></figure>

<p>clone 本仓库源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/luolongfei/freenom.git ./</span><br></pre></td></tr></table></figure>

<h4 id="2、修改配置"><a href="#2、修改配置" class="headerlink" title="2、修改配置"></a>2、修改配置</h4><p>复制配置文件模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp .env.example .env</span><br></pre></td></tr></table></figure>

<p>编辑配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .env</span><br><span class="line"># 注意事项</span><br><span class="line"># .env 文件里每个项目都有详细的说明，这里不再赘述，简言之，你需要把里面所有项都改成你自己的。需要注意的是多账户配置的格式：</span><br><span class="line"># e.g. MULTIPLE_ACCOUNTS=&#x27;&lt;账户1&gt;@&lt;密码1&gt;|&lt;账户2&gt;@&lt;密码2&gt;|&lt;账户3&gt;@&lt;密码3&gt;&#x27;</span><br><span class="line"># （注意不要省略“&lt;&gt;”符号，否则无法正确匹配）</span><br><span class="line"># 当然，若你只有单个账户，只配置 FREENOM_USERNAME 和 FREENOM_PASSWORD 就够了，单账户和多账户的配置会被合并在一起读取并去重。</span><br><span class="line"></span><br><span class="line"># 编辑完成后，按“Esc”回到命令模式，输入“:wq”回车即保存并退出，不会用 vim 编辑器的可以谷歌一下:)</span><br></pre></td></tr></table></figure>

<h4 id="3、添加计划任务"><a href="#3、添加计划任务" class="headerlink" title="3、添加计划任务"></a>3、添加计划任务</h4><h5 id="3-1-安装-crontabs-以及-cronie"><a href="#3-1-安装-crontabs-以及-cronie" class="headerlink" title="3.1 安装 crontabs 以及 cronie"></a>3.1 安装 crontabs 以及 cronie</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install cronie crontabs</span><br></pre></td></tr></table></figure>

<p>验证 crond 是否安装及启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list cronie &amp;&amp; systemctl status crond</span><br></pre></td></tr></table></figure>

<p>验证crontab是否安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list crontabs $$ which crontab &amp;&amp; crontab -l</span><br></pre></td></tr></table></figure>

<h5 id="3-2-打开任务表单，并编辑"><a href="#3-2-打开任务表单，并编辑" class="headerlink" title="3.2 打开任务表单，并编辑"></a>3.2 打开任务表单，并编辑</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"># 任务内容如下</span><br><span class="line"># 此任务的含义是在每天早上 9点 执行 /data/wwwroot/freenom/ 路径下的 run 文件，最佳实践是将这个时间修改为一个非整点的时间，防止与很多人在同一时间进行续期操作导致 freenom 无法稳定提供服务</span><br><span class="line"># 注意：某些情况下，crontab 可能找不到你的 php 路径，下面的命令执行后会在 freenom_crontab.log 文件输出错误信息，你应该指定 php 路径：把下面的 php 替换为 /usr/local/php/bin/php （根据实际情况，执行 whereis php 即可看到 php 执行文件的真实路径）</span><br><span class="line">00 09 * * * cd /data/wwwroot/freenom/ &amp;&amp; php run &gt; freenom_crontab.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h5 id="3-3-重启crond守护进程（每次编辑任务表单后都需此步，以使任务生效）"><a href="#3-3-重启crond守护进程（每次编辑任务表单后都需此步，以使任务生效）" class="headerlink" title="3.3 重启crond守护进程（每次编辑任务表单后都需此步，以使任务生效）"></a>3.3 重启crond守护进程（每次编辑任务表单后都需此步，以使任务生效）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart crond</span><br></pre></td></tr></table></figure>

<p>若要检查<code>计划任务</code>是否正常，你可以将上面的任务执行时间设置在几分钟后，然后等到任务执行完成， 检查<code>/data/wwwroot/freenom/</code>目录下的<code>freenom_crontab.log</code> 文件内容，是否有报错信息。常见的错误信息如下：</p>
<ul>
<li>/bin/sh: php: command not found</li>
<li>/bin/sh: /usr/local/php: Is a directory</li>
</ul>
<p><em>（点击即可展开或收起）</em></p>
<details open="" style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px; color: rgb(36, 41, 47); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;">解决方案</summary><br style="box-sizing: border-box;"><blockquote style="box-sizing: border-box; margin: 0px 0px 16px; padding: 0px 1em; color: var(--color-fg-muted); border-left: 0.25em solid var(--color-border-default);"><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">执行</p><div class="highlight highlight-source-shell position-relative overflow-auto" style="box-sizing: border-box; position: relative !important; overflow: auto !important; margin-bottom: 16px;"><pre style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; margin-top: 0px; margin-bottom: 0px; overflow-wrap: normal; padding: 16px; overflow: auto; line-height: 1.45; background-color: var(--color-canvas-subtle); border-radius: 6px; word-break: normal;">whereis php</pre></div><div class="highlight highlight-source-shell position-relative overflow-auto" style="box-sizing: border-box; position: relative !important; overflow: auto !important; margin-bottom: 16px;"><pre style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; margin-top: 0px; margin-bottom: 0px; overflow-wrap: normal; padding: 16px; overflow: auto; line-height: 1.45; background-color: var(--color-canvas-subtle); border-radius: 6px; word-break: normal;"><span class="pl-c" style="box-sizing: border-box; color: var(--color-prettylights-syntax-comment);"><span class="pl-c" style="box-sizing: border-box; color: var(--color-prettylights-syntax-comment);">#</span> 上面的命令可确定 php 执行文件的位置，一般输出为“php: /usr/local/php /usr/local/php/bin/php”，选长的那个即：/usr/local/php/bin/php</span></pre></div><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">现在我们知道 php 执行文件的路径是<code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">/usr/local/php/bin/php</code>（根据你自己系统的实际情况，可能不同），然后修改表单任务里的命令，把</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">00 09 * * * cd /data/wwwroot/freenom/ &amp;&amp; php run &gt; freenom_crontab.log 2&gt;&amp;1</code></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;">改为</p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 16px;"><code style="box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, &quot;SF Mono&quot;, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 13.6px; padding: 0.2em 0.4em; margin: 0px; background-color: var(--color-neutral-muted); border-radius: 6px;">00 09 * * * cd /data/wwwroot/freenom/ &amp;&amp; /usr/local/php/bin/php run &gt; freenom_crontab.log 2&gt;&amp;1</code></p><p dir="auto" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0px;">更多参考：<a href="https://stackoverflow.com/questions/7397469/why-is-crontab-not-executing-my-php-script" rel="nofollow" style="box-sizing: border-box; background-color: transparent; color: var(--color-accent-fg); text-decoration: none;">点这里</a></p></blockquote></details>

<p>当然，如果你的<code>计划任务</code>能正确找到<code>php路径</code>，没有错误，那你什么也不用做。</p>
<p><em>至此，所有的配置都已经完成，下面我们验证一下整个流程是否走通。</em></p>
<h5 id="3-4-验证"><a href="#3-4-验证" class="headerlink" title="3.4 验证"></a>3.4 验证</h5><p>你可以先将<code>.env</code>中的<code>NOTICE_FREQ</code>的值改为1（即每次执行都推送通知），然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/wwwroot/freenom/ &amp;&amp; php run</span><br></pre></td></tr></table></figure>

<p>不出意外的话，你将收到一封关于域名情况的邮件。</p>
]]></content>
      <tags>
        <tag>freenom</tag>
        <tag>域名续期</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloudflare Workers 部署OnePoint</title>
    <url>/posts/34183/</url>
    <content><![CDATA[<p>原项目地址：</p>
<p><a href="https://github.com/ukuq/onepoint">GitHub - ukuq/onepoint: A simple virtual drive based on many complex drives</a></p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h2><h3 id="🚀-功能一览"><a href="#🚀-功能一览" class="headerlink" title="🚀 功能一览"></a><strong>🚀 功能一览</strong></h3><ul>
<li>全新「面包屑」导航栏；</li>
<li>令牌凭证由 Cloudflare Workers 自动刷新，并保存于（免费的）全局 KV 存储中；</li>
<li>使用 <a href="https://cuojue.org/go/#aHR0cHM6Ly9naXRodWIuY29tL3R1cmJvbGlua3MvdHVyYm9saW5rcw==">Turbolinks®</a> 实现路由懒加载；</li>
<li>支持由世纪互联运营的 OneDrive 版本；</li>
<li>支持 SharePoint 部署；</li>
</ul>
<h3 id="🗃️-目录索引显示"><a href="#🗃️-目录索引显示" class="headerlink" title="🗃️ 目录索引显示"></a><strong>🗃️ 目录索引显示</strong></h3><ul>
<li>全新支持自定义的设计风格：<a href="https://cuojue.org/read/themes/spencer.css">spencer.css</a>；</li>
<li>支持使用 Emoji 作为文件夹图标（如果文件夹名称第一位是 Emoji 则自动开启该功能）；</li>
<li>渲染 <code>README.md</code> 如果当前目录下包含此文件，使用 <a href="https://cuojue.org/go/#aHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9naXRodWItbWFya2Rvd24tY3Nz">github-markdown-css</a> 渲染样式；</li>
<li>支持「分页」，没有一个目录仅限显示 200 个项目的限制了！</li>
</ul>
<h3 id="📁-文件在线预览"><a href="#📁-文件在线预览" class="headerlink" title="📁 文件在线预览"></a><strong>📁 文件在线预览</strong></h3><ul>
<li>根据文件类型渲染文件图标，图标使用 <a href="https://cuojue.org/go/#aHR0cHM6Ly9mb250YXdlc29tZS5jb20v">Font Awesome icons</a>；</li>
<li>支持预览：<ul>
<li>纯文本：<code>.txt</code>.</li>
<li>Markdown 格式文本：<code>.md</code>, <code>.mdown</code>, <code>.markdown</code>.</li>
<li>图片（支持 Medium 风格的图片缩放）：<code>.png</code>, <code>.jpg</code>, and <code>.gif</code>.</li>
<li>代码高亮：<code>.js</code>, <code>.py</code>, <code>.c</code>, <code>.json</code>…</li>
<li>PDF（支持懒加载、加载进度、Chrome 内置 PDF 阅读器）：<code>.pdf</code>.</li>
<li>音乐：<code>.mp3</code>, <code>.aac</code>, <code>.wav</code>, <code>.oga</code>.</li>
<li>视频：<code>.mp4</code>, <code>.flv</code>, <code>.webm</code>, <code>.m3u8</code>.</li>
</ul>
</li>
</ul>
<h3 id="🔒-私有文件夹"><a href="#🔒-私有文件夹" class="headerlink" title="🔒 私有文件夹"></a><strong>🔒 私有文件夹</strong></h3><p>我们可以给某个特定的文件夹（目录）上锁，需要认证才能访问。我们可以在 <code>src/auth/config.js</code> 文件中将我们想要设为私有文件夹的文件夹名称写入 <code>ENABLE_PATHS</code> 列表中，并将 <code>AUTH_ENABLED</code> 设置为 <code>true</code> 来开启这一功能。我们还可以自定义认证所使用的用户名 <code>NAME</code> 以及密码，其中认证密码保存于 <code>AUTH_PASSWORD</code> 环境变量中，如果需要这一功能，则需要使用 wrangler 来设置这一环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wrangler secret put AUTH_PASSWORD</span><br><span class="line"># 在这里输入你自己的认证密码</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里注意，别略过！！！待会部署提交预览之前一定要设置，或者按照下面的提示关掉。不然会提示Uncaught ReferenceError: AUTH_PASSWORD is not defined</p>
</blockquote>
<p>如果不需要开启这一功能，那么你可以直接注释掉定义 <code>PASS</code> 变量的那一行，使用下一行将 <code>PASS</code> 设置为空字符串即可。（另外也需要将 <code>AUTH_ENABLED</code> 设置为 <code>false</code>。）有关 wrangler 的使用细节等详细内容，请参考 <a href="https://cuojue.org/read/Cloudflare-Workers-OneDrive.html#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">接下来的部分段落</a>。</p>
<h3 id="⬇️-代理下载文件-文件直链访问-缩略图"><a href="#⬇️-代理下载文件-文件直链访问-缩略图" class="headerlink" title="⬇️ 代理下载文件 / 文件直链访问 / 缩略图"></a><strong>⬇️ 代理下载文件 / 文件直链访问 / 缩略图</strong></h3><ul>
<li>[可选] Proxied download（代理下载文件）：<code>?proxied</code> - 经由 CloudFlare Workers 下载文件。要满足两个条件（1）<code>config/default.js</code> 中的 <code>proxyDownload</code> 为 <code>true</code>，以及（2）使用参数 <code>?proxied</code> 请求文件；</li>
<li>[可选] Raw file download（文件直链访问）：<code>?raw</code> - 返回文件直链而不是预览界面；</li>
<li>两个参数可以一起使用，即 <code>?proxied&amp;raw</code> 和 <code>?raw&amp;proxied</code> 均有效。</li>
</ul>
<h3 id="补充，缩略图的获取方式"><a href="#补充，缩略图的获取方式" class="headerlink" title="补充，缩略图的获取方式"></a><strong>补充，缩略图的获取方式</strong></h3><ul>
<li><p>[可选] thumbnail（缩略图）：<code>?thumbnail=medium</code> - 返回图片缩略图；</p>
<p>可用的取值参见：<a href="https://cuojue.org/go/#aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvb25lZHJpdmUvZGV2ZWxvcGVyL3Jlc3QtYXBpL2FwaS9kcml2ZWl0ZW1fbGlzdF90aHVtYm5haWxzP3ZpZXc9b2RzcC1ncmFwaC1vbmxpbmUjc2l6ZS1vcHRpb25z">driveitem_list_thumbnails</a>某些缩略图选项在非个人版OneDrive无法使用：<a href="https://cuojue.org/read/Cloudflare-Workers-OneDrive.html#%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE">图片无法显示缩略图</a></p>
</li>
</ul>
<p>是的，这也就意味着你可以将这一项目用来搭建「图床」，或者用于搭建静态文件部署服务，比如下面的图片链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#small 96px</span><br><span class="line">&lt;https://wuyang.ws/***.jpg?proxied&amp;thumbnail=small&gt;</span><br><span class="line"></span><br><span class="line">#medium 176px</span><br><span class="line">&lt;https://wuyang.ws/***.jpg?proxied&amp;thumbnail=medium&gt;</span><br><span class="line"></span><br><span class="line">#large 800px</span><br><span class="line">&lt;https://wuyang.ws/***.jpg?proxied&amp;thumbnail=large&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><img src="https://wuyang.ws/%E5%85%B1%E4%BA%AB/%E5%9B%BE%E7%89%87/%E5%A6%B9%E5%AD%90%E5%9B%BE/2017062317353_5796/%E5%86%99%E7%9C%9F-3/3%20(1).jpg?proxied&thumbnail=small" alt="https://wuyang.ws/共享/图片/妹子图/2017062317353_5796/写真-3/3 (1).jpg?proxied&amp;thumbnail=small"></p>
<p><img src="https://wuyang.ws/%E5%85%B1%E4%BA%AB/%E5%9B%BE%E7%89%87/%E5%A6%B9%E5%AD%90%E5%9B%BE/2017062317353_5796/%E5%86%99%E7%9C%9F-3/3%20(1).jpg?proxied&thumbnail=medium" alt="https://wuyang.ws/共享/图片/妹子图/2017062317353_5796/写真-3/3 (1).jpg?proxied&amp;thumbnail=medium"></p>
<p><img src="https://wuyang.ws/%E5%85%B1%E4%BA%AB/%E5%9B%BE%E7%89%87/%E5%A6%B9%E5%AD%90%E5%9B%BE/2017062317353_5796/%E5%86%99%E7%9C%9F-3/3%20(1).jpg?proxied=&thumbnail=large" alt="https://wuyang.ws/共享/图片/妹子图/2017062317353_5796/写真-3/3 (1).jpg?proxied=&amp;thumbnail=large"></p>
<h2 id="部署指南"><a href="#部署指南" class="headerlink" title="部署指南"></a><strong>部署指南</strong></h2><p><em>又臭又长的中文版部署指南预警！</em></p>
<h3 id="生成-OneDrive-API-令牌"><a href="#生成-OneDrive-API-令牌" class="headerlink" title="生成 OneDrive API 令牌"></a><strong>生成 OneDrive API 令牌</strong></h3><ol>
<li><p>访问此 URL 创建新的 Blade app：<a href="https://cuojue.org/go/#aHR0cHM6Ly9wb3J0YWwuYXp1cmUuY29tLyNibGFkZS9NaWNyb3NvZnRfQUFEX1JlZ2lzdGVyZWRBcHBzL0FwcGxpY2F0aW9uc0xpc3RCbGFkZQ==">Microsoft Azure App registrations</a>（普通版 OneDrive）或 <a href="https://cuojue.org/go/#aHR0cHM6Ly9wb3J0YWwuYXp1cmUuY24vI2JsYWRlL01pY3Jvc29mdF9BQURfUmVnaXN0ZXJlZEFwcHMvQXBwbGljYXRpb25zTGlzdEJsYWRl">Microsoft Azure.cn App registrations</a>（OneDrive 世纪互联版本），<strong>建议将语言设置为「英语」以保证以下步骤中提到的模块和按钮的名称一致</strong>：</p>
<ol>
<li>使用你的 Microsoft 账户登录，选择 <code>New registration</code>；</li>
<li>在 <code>Name</code> 处设置 Blade app 的名称，比如 <code>my-onedrive-cf-index</code>；</li>
<li>将 <code>Supported account types</code> 设置为 <code>Accounts in any organizational directory (Any Azure AD directory - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)</code>。OneDrive 世纪互联用户设置为：<code>任何组织目录（任何 Azure AD 目录 - 多租户）中的帐户</code>；</li>
<li>将 <code>Redirect URI (optional)</code> 设置为 <code>Web</code>（下拉选项框）以及 <code>https://localhost</code>（URL 地址）；</li>
<li>点击 <code>Register</code>.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-1.png" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-1.png"></p>
</li>
<li><p>在 <code>Overview</code> 面板获取你的 Application (client) ID - <code>client_id</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-2.png" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-2.png"></p>
</li>
<li><p>打开 <code>Certificates &amp; secrets</code> 面板，点击 <code>New client secret</code>，创建一个新的叫做 <code>client_secret</code> 的 Client secret，并将 <code>Expires</code> 设置为 <code>Never</code>。点击 <code>Add</code> 并复制 <code>client_secret</code> 的 <code>Value</code> 并保存下来 <strong>（仅有此一次机会）</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-3.png" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-3.png"></p>
</li>
<li><p>打开 <code>API permissions</code> 面板，选择 <code>Microsoft Graph</code>，选择 <code>Delegated permissions</code>，并搜索 <code>offline_access, Files.Read, Files.Read.All</code> 这三个权限，<strong>选择这三个权限，并点击 <code>Add permissions</code>：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-4.png" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-4.png"></p>
<p>你应该成功开启这三个权限：</p>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-5.png" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-5.png"></p>
</li>
<li><p>获取 <code>refresh_token</code></p>
<ul>
<li><em>本地获取</em> （需要 Node.js 和 npm 环境，安装和推荐配置请参考 <a href="https://cuojue.org/read/Cloudflare-Workers-OneDrive.html#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a>）上面执行如下命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx @beetcb/ms-graph-cli</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>根据你自己的情况选择合适的选项，并输入我们上面获取到的一系列 token 令牌配置等，其中 <code>redirect_url</code> 可以直接设置为 <code>http://localhost</code>。有关命令行工具的具体使用方法请参考：<a href="https://cuojue.org/go/#aHR0cHM6Ly9naXRodWIuY29tL2JlZXRjYi9tcy1ncmFwaC1jbGk=">beetcb/ms-graph-cli</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-1.svg" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-1.svg"></p>
<ul>
<li><em>在线获取</em></li>
</ul>
<p>访问：<a href="https://cuojue.org/go/#aHR0cHM6Ly9oZXltaW5kLmdpdGh1Yi5pby90b29scy9taWNyb3NvZnQtZ3JhcGgtYXBpLWF1dGg=">Microsoft Graph API Auth</a> 获取</p>
</li>
<li><p>最后，在我们的 OneDrive 中创建一个公共分享文件夹，比如 <code>/Public</code> 即可。<strong>建议不要直接分享根目录!</strong></p>
<p>最后，这么折腾完，我们应该成功拿到如下的几个凭证：</p>
<ul>
<li><code>refresh_token</code></li>
<li><code>client_id</code></li>
<li><code>client_secret</code></li>
<li><code>redirect_uri</code></li>
<li><code>base</code>：默认为 <code>/Public</code>。</li>
</ul>
<p><em>是，我知道很麻烦，但是这是微软，大家理解一下。🤷🏼‍♂️</em></p>
</li>
</ol>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3><p>Fork 再 clone 或者直接 clone <a href="https://cuojue.org/go/#aHR0cHM6Ly9naXRodWIuY29tL3NwZW5jZXJ3b29vL29uZWRyaXZlLWNmLWluZGV4">onedrive-cf-index</a>，并安装依赖 Node.js、<code>npm</code> 以及 <code>wrangler</code>。</p>
<p><em>强烈建议大家使用 Node version manager 比如 <a href="https://cuojue.org/go/#aHR0cHM6Ly9naXRodWIuY29tL3RqL24=">n</a> 或者 <a href="https://cuojue.org/go/#aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=">nvm</a> 安装 Node.js 和 <code>npm</code>，这样我们全局安装的 <code>wrangler</code> 就可以在我们的用户目录下安装保存配置文件了，也就不会遇到奇奇怪怪的权限问题了。</em></p>
<blockquote>
<p>以下直接用npm安装可能失败，请看本节可能遇到的问题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 CloudFlare Workers 官方编译部署工具</span><br><span class="line">npm i @cloudflare/wrangler -g</span><br><span class="line"></span><br><span class="line"># 使用 npm 安装依赖</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"># 使用 wrangler 登录 CloudFlare 账户</span><br><span class="line">wrangler login</span><br><span class="line"></span><br><span class="line"># 使用这一命令检查自己的登录状态</span><br><span class="line">wrangler whoami</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>打开 <a href="https://dash.cloudflare.com/login">https://dash.cloudflare.com/login</a> 登录 CloudFlare，选择自己的域名，<strong>再向下滚动一点，我们就能看到右侧栏处我们的 <code>account_id</code> 以及 <code>zone_id</code> 了。</strong> 同时，在 <code>Workers</code> -&gt; <code>Manage Workers</code> -&gt; <code>Create a Worker</code> 处创建一个 <strong>DRAFT</strong> worker。</p>
<p>修改我们的 <code>[wrangler.toml](&lt;https://cuojue.org/read/wrangler.toml&gt;)</code>：</p>
<ul>
<li><code>name</code>：就是我们刚刚创建的 draft worker 名称，我们的 Worker 默认会发布到这一域名下：<code>&lt;name&gt;.&lt;worker_subdomain&gt;.workers.dev</code>；</li>
<li><code>account_id</code>：我们的 Cloudflare Account ID；</li>
<li><code>zone_id</code>：我们的 Cloudflare Zone ID。</li>
</ul>
<p>创建叫做 <code>BUCKET</code> 的 Cloudflare Workers KV bucket：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建 KV bucket</span><br><span class="line">wrangler kv:namespace create &quot;BUCKET&quot;</span><br><span class="line"></span><br><span class="line"># ... 或者，创建包括预览功能的 KV bucket</span><br><span class="line">wrangler kv:namespace create &quot;BUCKET&quot; --preview</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>修改 <code>[wrangler.toml](&lt;https://cuojue.org/read/wrangler.toml&gt;)</code> 里面的 <code>kv_namespaces</code>：</p>
<ul>
<li><code>kv_namespaces</code>：我们的 Cloudflare KV namespace，仅需替换 <code>id</code> 和（或者）<code>preview_id</code> 即可。<em>如果不需要预览功能，那么移除 <code>preview_id</code> 即可。</em></li>
</ul>
<p>修改 <code>[src/config/default.js](&lt;https://cuojue.org/read/src/config/default.js&gt;)</code>：</p>
<ul>
<li><code>client_id</code>：刚刚获取的 OneDrive <code>client_id</code>；</li>
<li><code>base</code>：之前创建的 <code>base</code> 目录；</li>
<li>如果你部署常规国际版 OneDrive，那么忽略以下步骤即可；</li>
<li>如果你部署的是由世纪互联运营的中国版 OneDrive：<ul>
<li>修改 <code>type</code> 下的 <code>accountType</code> 为 <code>1</code>；</li>
<li>保持 <code>driveType</code> 不变；</li>
</ul>
</li>
<li>如果你部署的是 SharePoint 服务：<ul>
<li>保持 <code>accountType</code> 不变；</li>
<li>修改 <code>driveType</code> 下的 <code>type</code> 为 <code>1</code>；</li>
<li>并根据你的 SharePoint 服务修改 <code>hostName</code> 和 <code>sitePath</code>。</li>
</ul>
</li>
</ul>
<p>使用 <code>wrangler</code> 添加 Cloudflare Workers 环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加我们的 refresh_token 和 client_secret</span><br><span class="line">wrangler secret put REFRESH_TOKEN</span><br><span class="line"># ... 并在这里粘贴我们的 refresh_token</span><br><span class="line"></span><br><span class="line">wrangler secret put CLIENT_SECRET</span><br><span class="line"># ... 并在这里粘贴我们的 client_secret</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="本节可能遇到的问题"><a href="#本节可能遇到的问题" class="headerlink" title="本节可能遇到的问题"></a><strong>本节可能遇到的问题</strong></h3><p>如果你是用本地获取<code>refresh_token</code>的需要修改<code>redirect_uri</code>为<code>http://localhost</code></p>
<p><code>npm i @cloudflare/wrangler -g</code> 出错 <code>Error: EACCES: permission denied, access &#39;/usr/lib/node_modules&#39;</code>安装<code>wrangler</code>的时候权限不足，即使<code>sudo npm i @cloudflare/wrangler -g</code>也会出错这时候只能给它安装到当前项目了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @cloudflare/wrangler --save</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><em>注意，即使使用 <code>sudo npm install -g @cloudflare/wrangler --unsafe-perm=true --allow-root</code> 后面也会不能正常使用</em></p>
<h3 id="编译与部署"><a href="#编译与部署" class="headerlink" title="编译与部署"></a><strong>编译与部署</strong></h3><p>我们可以使用 <code>wrangler</code> 预览部署：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wrangler preview</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，我们即可使用如下命令发布 Cloudflare Worker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wrangler publish</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="本节可能遇到的问题-1"><a href="#本节可能遇到的问题-1" class="headerlink" title="本节可能遇到的问题"></a><strong>本节可能遇到的问题</strong></h3><ul>
<li><p>错误内容<code>getAccessToken</code>如果你确定上面填写的内容都正常，那么可能是遇到了<code>refresh_token</code>过长<code>secret</code>保存失败……</p>
<p>解决方法：使用KV来保存<code>refresh_token</code></p>
<p>首先还是一样的操作，拿到 refresh_token 之后，在 Cloudflare Workers → KV 里面的 BUCKET namespace 中创建一个新的 entry 就叫做 refresh_token，然后把你拿到的 refresh_token 粘进去：之后修改代码，在 <code>./src/auth/onedrive.js</code> 里面加一个获取 <code>refresh_token</code> 的代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-6.png" alt="https://cdn.jsdelivr.net/gh/naicfeng/cdn/blog/files/2021/03/Cloudflare-Workers-OneDrive-6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line">export async function getAccessToken() &#123;</span><br><span class="line">  const timestamp = () =&gt; &#123;</span><br><span class="line">    return Math.floor(Date.now() / 1000)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const refresh_token = await BUCKET.get(&#x27;refresh_token&#x27;)</span><br><span class="line"></span><br><span class="line">  // 之后所有的 config.refresh_token 都直接改为 refresh_token</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>顺便还要把其他原有定义了 <code>REFRESH_TOKEN</code> 的地方删掉（比如 <code>./src/config/default.js</code> 里面的 <code>refresh_token: REFRESH_TOKEN,</code> 一行）。</p>
<h2 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h2><h2 id="Cloudflare-Workers-部署"><a href="#Cloudflare-Workers-部署" class="headerlink" title="Cloudflare Workers 部署"></a><strong>Cloudflare Workers 部署</strong></h2><h3 id="新建-Worker"><a href="#新建-Worker" class="headerlink" title="新建 Worker"></a><strong>新建 Worker</strong></h3><p><a href="https://camo.githubusercontent.com/50b04b6a98ee695c02d52a26a646eb1c0e3338ed6642f4b07b348f897089b491/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f35747354756b6c5a554457534969782e706e67">https://camo.githubusercontent.com/50b04b6a98ee695c02d52a26a646eb1c0e3338ed6642f4b07b348f897089b491/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f35747354756b6c5a554457534969782e706e67</a></p>
<h3 id="粘贴代码"><a href="#粘贴代码" class="headerlink" title="粘贴代码"></a><strong>粘贴代码</strong></h3><p><a href="https://github.com/ukuq/onepoint/blob/master/ncc/ncc_cf-worker.js">https://github.com/ukuq/onepoint/blob/master/ncc/ncc_cf-worker.js</a></p>
<p>或者 <a href="https://raw.githubusercontent.com/ukuq/onepoint/master/ncc/ncc_cf-worker.js">https://raw.githubusercontent.com/ukuq/onepoint/master/ncc/ncc_cf-worker.js</a></p>
<p>代码较多，保存可能要费点时间，不要心急！</p>
<p><a href="https://camo.githubusercontent.com/e19691a1efdd0dadd25970103d1a1c91768d724ab3e7cc5e5ef013c3b75492bc/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f39327879464c4b35644f72576b34732e706e67">https://camo.githubusercontent.com/e19691a1efdd0dadd25970103d1a1c91768d724ab3e7cc5e5ef013c3b75492bc/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f39327879464c4b35644f72576b34732e706e67</a></p>
<h3 id="返回上一级，新建KV桶，名字随意"><a href="#返回上一级，新建KV桶，名字随意" class="headerlink" title="返回上一级，新建KV桶，名字随意"></a><strong>返回上一级，新建KV桶，名字随意</strong></h3><p><a href="https://camo.githubusercontent.com/abcb023b0bda788b2c062b01968a77735289f5803882dd1496435d33e09f5e55/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f457032726d62514e397931544644492e706e67">https://camo.githubusercontent.com/abcb023b0bda788b2c062b01968a77735289f5803882dd1496435d33e09f5e55/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f457032726d62514e397931544644492e706e67</a></p>
<p><a href="https://camo.githubusercontent.com/98a503d63007fae2b85cde5294d101eb8b7251ee94d4196889dd2fbd95171951/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f57666e79706f74676d4348755071682e706e67">https://camo.githubusercontent.com/98a503d63007fae2b85cde5294d101eb8b7251ee94d4196889dd2fbd95171951/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f57666e79706f74676d4348755071682e706e67</a></p>
<h3 id="绑定KV桶，变量名设置为OPCONFIG"><a href="#绑定KV桶，变量名设置为OPCONFIG" class="headerlink" title="绑定KV桶，变量名设置为OPCONFIG"></a><strong>绑定KV桶，变量名设置为OPCONFIG</strong></h3><p><a href="https://camo.githubusercontent.com/8e5dddca8fe5239593862f7bea91e9e44a9eab7ac608f56d115037d04e1fb8e4/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f57364d4f6d6c5259546935336f515a2e706e67">https://camo.githubusercontent.com/8e5dddca8fe5239593862f7bea91e9e44a9eab7ac608f56d115037d04e1fb8e4/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31392f57364d4f6d6c5259546935336f515a2e706e67</a></p>
</li>
</ul>
<h2 id="样式、内容的自定义"><a href="#样式、内容的自定义" class="headerlink" title="样式、内容的自定义"></a><strong>样式、内容的自定义</strong></h2><ul>
<li>我们 <strong>应该</strong> 更改默认「着落页面」，直接修改 <code>src/folderView.js</code>#L51-L55) 中 <code>intro</code> 的 HTML 即可；</li>
<li>我们也 <strong>应该</strong> 更改页面的 header，直接修改 <code>src/render/htmlWrapper.js</code>#L24 即可；</li>
<li>样式 CSS 文件位于 <code>themes/spencer.css</code>，可以根据自己需要自定义此文件，同时也需要更新 <code>src/render/htmlWrapper.js</code>#L3 文件中的 commit HASH；</li>
<li>我们还可以自定义 Markdown 渲染 CSS 样式、PrismJS 代码高亮样式，等等等。</li>
</ul>
<h2 id="如果遇到图片无法显示缩略图"><a href="#如果遇到图片无法显示缩略图" class="headerlink" title="如果遇到图片无法显示缩略图"></a><strong>如果遇到图片无法显示缩略图</strong></h2><blockquote>
<p>如果使用的不是个人版OneDrive，下面带Crop的选项可能无法正常显示缩略图</p>
</blockquote>
<p><a href="https://www.notion.so/a53334ceb0b049f59dc901bbb6fe3a7a">无标题</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://wuyang.ws/***.jpg?proxied&amp;thumbnail=c300x400&gt;  #正常</span><br><span class="line">&lt;https://wuyang.ws/***.jpg?proxied&amp;thumbnail=c300x400_Crop&gt;  #不可用</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<hr>
<p>最后，感谢作者 <a href="https://cuojue.org/go/#aHR0cHM6Ly9ibG9nLnNwZW5jZXJ3b28uY29tLw==">Spencer Woo</a>. 为我们带来如此强大的程序！</p>
]]></content>
      <tags>
        <tag>onedrive</tag>
        <tag>cloudflare</tag>
        <tag>目录程序</tag>
      </tags>
  </entry>
  <entry>
    <title>7ED Static CDN——公共静态服务加速</title>
    <url>/posts/48470/</url>
    <content><![CDATA[<p>感觉自己的网站远行不够快，打开很迟钝，那么肯定有部分原因是静态文件导致的。<br>勿埋我心向你介绍一个静态文件加速服务——7ED.NET</p>
<p>对应地址：<a href="https://cdn.con.sh/">https://cdn.con.sh/</a> | <a href="https://7ed.net/">https://7ed.net/</a></p>
<h2 id="一、公共CDN服务使用"><a href="#一、公共CDN服务使用" class="headerlink" title="一、公共CDN服务使用"></a>一、公共CDN服务使用</h2><ol>
<li><p>Google Fonts 大陆地区加速</p>
<table>
<thead>
<tr>
<th align="center">原网址</th>
<th>fonts.googleapis.com</th>
</tr>
</thead>
<tbody><tr>
<td align="center">替换为</td>
<td>use.sevencdn.com</td>
</tr>
<tr>
<td align="center">例如</td>
<td><a href="https://use.sevencdn.com/css?family=Unica+One&amp;display=swap">https://use.sevencdn.com/css?family=Unica+One&amp;display=swap</a></td>
</tr>
</tbody></table>
</li>
<li><p>CDNJS 大陆地区加速</p>
<table>
<thead>
<tr>
<th align="center">原网址</th>
<th>cdnjs.cloudflare.com</th>
</tr>
</thead>
<tbody><tr>
<td align="center">替换为</td>
<td>use.sevencdn.com</td>
</tr>
<tr>
<td align="center">例如</td>
<td><a href="https://use.sevencdn.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js">https://use.sevencdn.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js</a></td>
</tr>
</tbody></table>
</li>
<li><p>Google Libraries 大陆地区加速</p>
<table>
<thead>
<tr>
<th align="center">原网址</th>
<th>*.gravatar.com</th>
</tr>
</thead>
<tbody><tr>
<td align="center">替换为</td>
<td>use.sevencdn.com</td>
</tr>
<tr>
<td align="center">例如</td>
<td><a href="https://use.sevencdn.com/avatar/767fc9c115a1b989744c755db47feb60&amp;s=128">https://use.sevencdn.com/avatar/767fc9c115a1b989744c755db47feb60&amp;s=128</a></td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h2 id="二、Github-Raw加速使用"><a href="#二、Github-Raw加速使用" class="headerlink" title="二、Github Raw加速使用"></a>二、Github Raw加速使用</h2><p>GITHUB 是个良心网站，在某种情况下可以当作一个网盘使用（强烈不推荐），但官方速度略慢。可以用7ED服务，以加快大陆地区用户访问。</p>
<ol>
<li><p>如何使用？</p>
<table>
<thead>
<tr>
<th align="center">原网址</th>
<th>raw.githubusercontent.com</th>
</tr>
</thead>
<tbody><tr>
<td align="center">替换为</td>
<td>raw.sevencdn.com</td>
</tr>
<tr>
<td align="center">例如</td>
<td><a href="https://raw.sevencdn.com/imagehosted/images/master/2019/06/20190612115457.png">https://raw.sevencdn.com/imagehosted/images/master/2019/06/20190612115457.png</a></td>
</tr>
</tbody></table>
</li>
<li><p>例子展示<br><a href="https://raw.sevencdn.com/imagehosted/images/master/2019/06/20190612115457.png"><img src="" alt="img"></a></p>
</li>
</ol>
<blockquote>
<p><strong>建议：其实关于GitHub，使用Jsdelivr也是一个非常好的选择，而且服务更加的稳定。</strong></p>
</blockquote>
<hr>
<h2 id="三、图像加速服务"><a href="#三、图像加速服务" class="headerlink" title="三、图像加速服务"></a>三、图像加速服务</h2><p>加快储存在海外的图片在大陆地区的加载速度，支持 PNG, JPG, GIF, BMP 等格式的图片。<br>比如：SM.MS、Imgur图床等等。<br>支持又拍云图片处理格式，分隔符为 <code>!</code>，例如 <code>!/BOTH/500X300</code> 将图片裁剪为长 500PX 宽 300PX。</p>
<blockquote>
<p><strong>意外之喜：最近SM.MS非会员外链似乎好像打不开了，该服务刚好可以解决该问题。</strong></p>
</blockquote>
<ol>
<li><p>如何使用？</p>
<table>
<thead>
<tr>
<th align="center">原网址</th>
<th><a href="https://i.imgur.com/3QrPToe.jpg">https://i.imgur.com/3QrPToe.jpg</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center">加前缀</td>
<td>i.sevencdn.com</td>
</tr>
<tr>
<td align="center">例如</td>
<td><a href="https://i.sevencdn.com/i.imgur.com/3QrPToe.jpg">https://i.sevencdn.com/i.imgur.com/3QrPToe.jpg</a></td>
</tr>
</tbody></table>
</li>
<li><p>例子展示(使用SM.MS图床)</p>
<table>
<thead>
<tr>
<th align="center">未加速</th>
<th align="center">已加速</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://i.loli.net/2020/12/10/jNPxyeDvh4mospb.png"><img src="" alt="img"></a></td>
<td align="center"><a href="https://i.sevencdn.com/i.loli.net/2020/12/10/jNPxyeDvh4mospb.png"><img src="" alt="img"></a></td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h2 id="四、创建开放图形图像"><a href="#四、创建开放图形图像" class="headerlink" title="四、创建开放图形图像"></a>四、创建开放图形图像</h2><p>根据文字（<strong>仅支持英文及 EMOJI</strong>），自动创建漂亮的头图。</p>
<ol>
<li><p>如何使用？</p>
<table>
<thead>
<tr>
<th align="center">用法</th>
<th><code>https://i.sevencdn.com/og/[主题，dark/light]/[文字大小，数字]/[文字]</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">例如</td>
<td><a href="https://i.sevencdn.com/og/dark/120/">https://i.sevencdn.com/og/dark/120/📌www.qian.blue</a></td>
</tr>
</tbody></table>
</li>
<li><p>例子展示<br><a href="https://i.sevencdn.com/og/dark/120/%F0%9F%93%8Cwww.qian.blue"><img src="" alt="img"></a></p>
</li>
</ol>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总的来说，该服务对于开发人员或者建站人士是非常不错。</p>
<p>该服务属于公益活动，<strong>请勿滥用和过度开发</strong>。</p>
<p>感觉不错的话可以在勿埋我心评论区留言，记得多多访问~</p>
]]></content>
      <tags>
        <tag>免费</tag>
        <tag>CDN加速</tag>
      </tags>
  </entry>
  <entry>
    <title>如何白嫖属于自己的免费网站</title>
    <url>/posts/20777/</url>
    <content><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><strong>如何做到白嫖免费搭建呢？</strong>服务器使用别人的就可以啦，比如<a href="https://pages.github.com/"><strong>GitHub Pages</strong></a>~</p>
<p><strong>网站增加文章的话还得懂网页开发？</strong>当然不需要啦，使用<a href="https://hexo.io/"><strong>Hexo</strong></a>帮你搭建一套个人网站就可以啦~</p>
<p><strong>增加网站内容会不会比较麻烦？</strong>这都啥时代啦，使用Markdown工具<a href="https://typora.io/"><strong>Typora</strong></a>发布内容非常方便哦~</p>
<p>刚才提到了三个关键词，解释如下：</p>
<table>
<thead>
<tr>
<th align="left">名词</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GitHub Pages</td>
<td align="left">我们访问的任意网站都是放在服务器上的，通过域名或者说网址为我们提供服务，GitHub Pages就是为我们提供域名和服务器的，域名为GitHub.io的子域名</td>
</tr>
<tr>
<td align="left">Hexo</td>
<td align="left">有了服务器还需要有一套网页的模板，还需要开发网页？Hexo提供了丰富的网页模板和插件，帮助我们更好的个性化和维护自己的网站</td>
</tr>
<tr>
<td align="left">Typora</td>
<td align="left">增加网页的特点离不开文章内容的编写，文字、图片、视频、音乐等等，一个高效的编写工具尤为重要，Typora是一个文档编辑软件，基于Markdown语法开发保证了编写的效率，另外支持实时渲染，所见即所得，从而脱颖而出，成为目前最亮眼的Markdown文档编辑工具</td>
</tr>
</tbody></table>
<p>使用GitHub+Hexo+Typora搭建的免费网站，演示如下：</p>
<p>==为了方便理解，这里以后会放一个演示视频，先放这里占个位置，后期补上来(●ˇ∀ˇ●)==</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>GitHub提供了<strong>pages</strong>服务，即静态网页访问服务。因此咱们只需要按照GitHub的要求，创建一个GitHub pages仓库，就相当于拥有一个搭建网站的服务器啦。</p>
<p>而有了服务器咱们还需要些代码来完成网页的开发，小白表示太不友好了/(ㄒoㄒ)/~~。幸好有大神帮我们开发好了一套友好的框架叫<strong>Hexo</strong>，咱们主要学会安装部署，再学会Markdown文章高效编写就可以啦。</p>
<p>当然使用Gitee或者Coding也支持pages服务，如果觉得GitHub慢的小伙伴也可以用这两个哦，只是个人习惯了GitHub，也是全世界代码分享的平台（男性交友平台），不想放弃啊🤭。</p>
<p>另外Hexo也有替代产品，如果不喜欢折腾，想快速搭建的也可以使用<a href="https://gridea.dev/">gridea</a>来快速搭建博客，适合非开发人员或爱好者，使用gridea可以参考<a href="https://yharea.com/433/">这篇文章</a>。</p>
<p>下面咱们回归正题，使用GitHub Pages+Hexo开始搭建（折腾）吧，说不定等gridea各方面都完备了，就转过去了🤭。</p>
<h3 id="免费的服务器-GitHub"><a href="#免费的服务器-GitHub" class="headerlink" title="免费的服务器-GitHub"></a>免费的服务器-GitHub</h3><ol>
<li><p>创建GitHub账号，<a href="https://github.com/">注册地址</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223145014702.png" alt="注册页面"></p>
<p><strong>注册页面</strong></p>
<p>填好自己得个人信息，注意Username使用英文；</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/v2-7872012db459db8c8bab2793f7f79101_1440w.jpg" alt="信息填写"></p>
<p><strong>信息填写</strong></p>
<p>选择免费的版本，并且点击继续，填写个人的一些信息后，点击Submit完成注册。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223144550429.png" alt="注册成功后的界面"></p>
<p><strong>注册成功后的界面</strong></p>
<p>注册成功后，看到以上的界面信息就表示注册成功了。</p>
</li>
<li><p>创建GitHub Page仓库</p>
<p>点击右上角的加号选择New repository来创建一个GitHub Pages</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223144754011.png" alt="创建仓库"></p>
<p><strong>创建仓库</strong></p>
<p>创建仓库的名称（也作为将来的域名），注意图中的要求，仓库名称必须是<strong>用户名.github.io</strong>，其中用户名是注册时填写的Username字段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223150133862.png" alt="填写仓库名称"></p>
<p><strong>填写仓库名称</strong></p>
<p>然后点击最下面的Create repository创建仓库就可以了。</p>
</li>
<li><p>安装Git工具</p>
<p>Git是一个版本管理工具，可以方便的使用Git命令管理你的仓库。</p>
<p><a href="https://git-scm.com/download/win">下载Git命令</a></p>
<p>如果是64位的windows可以选择图中相关的安装文件，下载后安装即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223151401927.png" alt="Git工具下载"></p>
<p><strong>Git工具下载</strong></p>
</li>
</ol>
<p>下载并安装完成后，打开Git Bash应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223151528087.png" alt="Git Bash应用"></p>
<p><strong>Git Bash应用</strong></p>
<p>打开后，如图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223151623811.png" alt="Git Bash命令行"></p>
<p><strong>Git Bash命令行</strong></p>
<p>在命令行中输入全局配置，user.name和user.email配置信息</p>
<p>bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成ssh密钥文件，提示内容时直接回车即可：</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>创建成功后，大概是这个样子，注意红色框框的文件，需要打开，把内容拷贝到GitHub上去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223152128655.png" alt="image-20210223152128655"></p>
<p><strong>image-20210223152128655</strong></p>
<p>打开<a href="https://link.zhihu.com/?target=https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223152525778.png" alt="新增SSH Key"></p>
<p><strong>新增SSH Key</strong></p>
<p>标题Title可以随便写，增加成功后在Git Bash命令行中，输入</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>

<p>输入后，得到红框中的内容说明SSH Key设置成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223152757219.png" alt="SSH Key设置成功信息"></p>
<p><strong>SSH Key设置成功信息</strong></p>
<p>设置SSH Key的原因是，当我们编写好文章后，需要通过Git命令把内容推送给GitHub服务器上，这就需要账号密码验证，我们刚上传了id_rsa.pub的内容是公钥，私钥在咱们电脑上，这样在提交时就可以通过非对称加密的公钥与私钥来完成账号的验证了，就能检测提交代码者的身份是合法的了。</p>
<h3 id="搭建Hexo静态网站"><a href="#搭建Hexo静态网站" class="headerlink" title="搭建Hexo静态网站"></a>搭建Hexo静态网站</h3><ol>
<li><p>nodejs安装</p>
<p>Hexo基于nodejs的，下载nodejs：<a href="https://nodejs.org/en/download/%EF%BC%8C%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">https://nodejs.org/en/download/，安装成功输入命令查看是否安装成功</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223153525207.png" alt="查看node安装是否成功"></p>
<p><strong>查看node安装是否成功</strong></p>
</li>
<li><p>Hexo安装</p>
<p>hexo-cli安装</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>创建blog</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>以上的命令在当前目录下创建了一个blog目录，其中包含了Hexo的相关信息</p>
</li>
<li><p>hexo测试</p>
<p>hexo的基本命令如下：</p>
<p>通过hexo new “test”来创建一篇新的名字叫test的文章</p>
<p>通过hexo g命令generate进行构建，生成静态网页</p>
<p>通过hexo s命令在本地创建一个server服务，默认是localhost:4000</p>
<p>通过hexo d命令deploy部署静态网页到GitHub或其他你想发布的地方</p>
<p>可以通过hexo g和hexo s，然后在浏览器中输入local host:4000检查是否已经可以看到你的网页了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>构建时候，如果出现LF will be replaced的警告，可以通过以下的命令解决：</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<p>这条命令是禁用自动转换，这个不设置后面上传时会出现警告</p>
</li>
<li><p>测试发布</p>
<p>打开创建blog根目录下的_config.yml配置文件，修改deploy字段</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/aibittek/aibittek.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>注意repo填写的是仓库地址，可以进入仓库进行复制粘贴过来，防止写错了部署不成功，branch是版本分支的意思，按照下图中左侧可以查看分支名称，有可能新版本分支是main哦，小心一点</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223154908917.png" alt="复制仓库地址"></p>
<p><strong>复制仓库地址</strong></p>
</li>
</ol>
<p>安装提交git部署的插件</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>输入命令进行部署</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>其中clean是清除之前构建的内容，也可以通过一条命令完成以上的步骤</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>

<p>部署成功后，会把hexo g构建的静态网页部署到_config.yml，deploy填写的repo仓库中，现在通过网页浏览你的网站吧，通过<strong>用户名.github.io</strong>来访问哦。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="绑定个性域名"><a href="#绑定个性域名" class="headerlink" title="绑定个性域名"></a>绑定个性域名</h3><p>你一定觉得使用github.io域名不够酷，想要一个自己的域名吧🤭</p>
<p>可以通过申请一个域名，把原本访问<strong>用户名.github.io</strong>改为访问你自己的域名即可，需要<strong>域名申请和域名绑定</strong>。</p>
<h4 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h4><p>可以到<a href="https://www.dnspod.cn/">DNSPod</a>申请一个喜欢的域名，或者任何其他你想要购买域名的地方。</p>
<p>选择DNSPod的原因是之前一直在用DNSPod的DDNS服务，花生咳这个服务用的我已经一口老血都咳出来了。DNSPod目前也是被腾讯收购了，当然阿里云之类的也可以，也是支持DDNS服务的，并提供API接口。点击上面的DNSPod链接，切换到域名一栏点击购买即可。</p>
<h4 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h4><p>有两处需要设置，假设上一节你已经选择好了域名，域名叫kui.ge，那么先到你的GitHub上，进入用户名.github.io这个仓库，点击右侧的settings</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223160605182.png" alt="设置域名绑定"></p>
<p><strong>设置域名绑定</strong></p>
<p>然后往下拉，找到GitHub Pages设置一栏，按照如下的方式填写即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223160749616.png" alt="个性化网页设置"></p>
<p><strong>个性化网页设置</strong></p>
<p>设置成功后，就使用你的新域名进行访问静态网页了。</p>
<p>但是如果我们直接在浏览器输入kui.ge的话，其实也是想访问<strong>你的用户名.github.io</strong>的，怎么办呢？在域名注册商处DNS解析的地方使用CNAME填写以下内容即可：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223161233437.png" alt="CNAME域名绑定"></p>
<p><strong>CNAME域名绑定</strong></p>
<p>CNAME后面填写的是你的GitHub的用户名.github.io.，注意后面还有个点，@记录后面填写的IP地址，这个地址可以通过<code>ping 你的用户名.github.io</code>来获得。</p>
<p>最后还要在你的博客目录下，增加一个CNAME文件，内容就写你的域名即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223161658525.png" alt="CNAME域名文件"></p>
<p><strong>CNAME域名文件</strong></p>
<p>完成以上的步骤后，在blog目录下，执行以下命令，对新修改的内容进行部署发布</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>

<p>发布成功后，使用你自己的域名来访问就可以访问到GitHub Pages里面的静态网页啦，演示如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223161857758.png" alt="个性化域名访问GitHub Pages演示"></p>
<p><strong>个性化域名访问GitHub Pages演示</strong></p>
<h3 id="高效发布文章"><a href="#高效发布文章" class="headerlink" title="高效发布文章"></a>高效发布文章</h3><h4 id="Typora图床编辑"><a href="#Typora图床编辑" class="headerlink" title="Typora图床编辑"></a>Typora图床编辑</h4><p>网站搭建好之后，是不是就想着发布分享自己的文章内容了呢，那么就要选择一款高效的工具，这里推荐的是Typora Markdown工具，不好意思不是推荐，我想强制你用这个😄。因为实在是太好用了，可以在写的同时渲染出结果，所见即所得，还有很多的优点，这里就不一一介绍啦。</p>
<p>下载地址：<a href="https://typora.io/">https://typora.io/</a></p>
<p>例子：使用hexo new “name”可以在source/_ports目录下创建出来name.md的Markdown文件，然后双击通过Typora打开进行创作就可以啦。</p>
<h4 id="图床PicGo"><a href="#图床PicGo" class="headerlink" title="图床PicGo"></a>图床PicGo</h4><p>咱们在写文章的时候，会用到图片，音乐和视频，你应该不希望这些数据都保存到你的GitHub中吧，否则随着文章的增多内容会增大很多，数据同步的话也变得困难。</p>
<p>一般的像网易云音乐，B站视频等都提供了外部链接，咱们可以把这些媒体资源信息放到对应的音乐视频网站上，减小自己网站的大小，然后通过提供的外部链接放到自己的文章里来就可以了。</p>
<p><strong>图片也一样，可以使用专门提供图片存储地址的服务，这个服务被翻译成图床，英文叫Image Host</strong></p>
<p>有很多软件提供了图床的功能，而PicGo则是提供聚合的图床的工具，我们可以看到支持了很多图床工具的设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223163843008.png" alt="PicGo图床支持"></p>
<p><strong>PicGo图床支持</strong></p>
<p>接下来需要做这几步骤：</p>
<ol>
<li>Github创建一个新的仓库用来存放图片</li>
<li>Typora中设置PicGo应用，设置成功后，粘贴图片时会调用PicGo进行自动上传；</li>
<li>下载安装PicGo，推荐使用app带界面的更加直观，配置PicGo在接收到数据后上传到哪里，这里我们要设置上传到咱们在GitHub上创建出来的专门放图片的仓库里</li>
<li>由于PicGo把图片自动上传到GitHub上需要权限，因此在PicGo中填写GitHub中的token来授权</li>
</ol>
<p>Github创建仓库就不用说了，Typora中下载PicGo app，然后把下载的应用路径填写进去，再把上面的几个勾勾打上即可，Typora就能在插入图片时自动把图片交给PicGo上传啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223164847344.png" alt="Typora的偏好设置"></p>
<p><strong>Typora的偏好设置</strong></p>
<p>打开PicGo设置上传到的地址：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223165040077.png" alt="PicGo上传设置"></p>
<p><strong>PicGo上传设置</strong></p>
<p>其中repo是你建立的仓库名称，branch是图片上传到哪个分支，token待会从GitHub获取，path是保存到这个分支的哪个目录下，customUrl使用了CDN加速，你自己的可以这么写<a href="https://cdn.jsdelivr.net/gh/aibittek/ImageHost%EF%BC%8C%E5%85%B6%E4%B8%ADaibittek/ImageHost%E6%94%B9%E6%88%90%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84repo%E5%8D%B3%E5%8F%AF%E3%80%82">https://cdn.jsdelivr.net/gh/aibittek/ImageHost，其中aibittek/ImageHost改成你自己的repo即可。</a></p>
<p>我使用的是githubPlus，上面其实有一个GitHub图床了，单有时候会上传失败，选择githubPlus插件，上传图片错误的概率会小一点，可以在插件设置里搜索githubPlus，然后下载就可以了，然后把以上的这些内容填写到githubPlus这些框框中，最后不要忘记设为默认图床哦。</p>
<p>还差最后一步token获取，登录GitHub-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;Generate new token，在Note中取一个名字，然后repo勾上，最后会生成一个token，这个token令牌要注意保存下，只显示一次，并把token存放到PicGo的githubPlus的token一栏点击确定就可以啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223165904550.png" alt="token获取步骤"></p>
<p><strong>token获取步骤</strong></p>
<p>设置好之后，在Typora里随便粘贴一张图片会发现正在上传，然后点击GitHub上的图床仓库，看图片是不是已经上传成功了呢。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223170113124.png" alt="上传成功验证"></p>
<p><strong>上传成功验证</strong></p>
<p>这个是上面这张图粘贴到Typora中的时候的自动上传效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223170213582.png" alt="上传过程"></p>
<p><strong>上传过程</strong></p>
<h3 id="美化网站内容"><a href="#美化网站内容" class="headerlink" title="美化网站内容"></a>美化网站内容</h3><h4 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h4><p>可以通过 <a href="https://hexo.io/themes">https://hexo.io/themes</a> 在搜索框中选择自己喜欢的主题，我选择的是这个主题Matery</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223171205653.png" alt="Matery主题"></p>
<p><strong>Matery主题</strong></p>
<p>主题下载地址：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p>
<p>下载之后解压，把hexo-theme-matery目录放到博客的themes目录下即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223171352328.png" alt="matery主题"></p>
<p><strong>matery主题</strong></p>
<p>修改根目录下的_config.yaml配置文件，使得新增加的主题生效</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-matery</span></span><br></pre></td></tr></table></figure>

<p>通过以下命令构建部署之后，访问网页查看结果是不是已经焕然一新了呢😄</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>

<h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>当然主题还有很多优化设置，比如主页怎么显示，动画怎么展示等等，这些matery已经都提供了修改方法，在源码的Readme文件中的配置一栏，这里就不详述了，可根据自己的需求在文档的配置章节，根据自己的喜好进行自定义修改，传送门：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p>
<h4 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h4><p>以上文档中提到了支持的评论系统，但是没有具体说明如何支持，这里咱们介绍下。</p>
<p>目前不需要服务端的评论系统有两个用的比较多的，一个是valine，一个是Gitalk。</p>
<p>valine使用了LeanCloud访问速度快，无需搭建服务端，也不需要用户登录，就可以随意评论，但是担心不能长久使用，所以我使用了Gitalk，也是基于GitHub的，本质上借助了issue的功能。</p>
<p>既然选择了Gitalk，就开始搭建评论系统的环境吧，需要以下几步：</p>
<ol>
<li>GitHub开启授权</li>
<li>Gitalk网页配置</li>
<li>GitalkBUG修复</li>
</ol>
<h4 id="GitHub开启授权"><a href="#GitHub开启授权" class="headerlink" title="GitHub开启授权"></a>GitHub开启授权</h4><p>通过Settings-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App创建一个授权，我这里已经创建好了一个叫kui.ge的授权</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223173530412.png" alt="开启授权操作路径"></p>
<p><strong>开启授权操作路径</strong></p>
<p>看下我的授权是怎么写的</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223173639200.png" alt="授权内容填写"></p>
<p><strong>授权内容填写</strong></p>
<p>注意，如果你的域名已经转到了自定义域名，这里填写的是你的新域名，如果没有，填写的callback URL应该是你的<strong>用户名.github.io</strong></p>
<p>填写好之后，点击确认，会得到Client ID和Client secrets，注意保存Client secrets，只显示一次：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223173822448.png" alt="获取Client ID和Client secrets"></p>
<p><strong>获取Client ID和Client secrets</strong></p>
<h4 id="Gitalk网页配置"><a href="#Gitalk网页配置" class="headerlink" title="Gitalk网页配置"></a>Gitalk网页配置</h4><p>打开网站源码的themes/_config.yml配置文件，找到gitalk配置如下：</p>
<blockquote>
<p>注意如果不是这个主题，可能没有集成Gitalk，需要按照Gitalk的要求进行配置，<a href="https://github.com/gitalk/gitalk">源码及文档地址</a></p>
</blockquote>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> the Gitalk config，default disabled</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Gitalk 评论模块的配置，默认为不激活</span></span><br><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  owner: aibittek #填写你OAuth App的用户名</span><br><span class="line">  repo: aibittek.github.io #填写你自己的</span><br><span class="line">  oauth:</span><br><span class="line">    clientId: #填写上面获取到的</span><br><span class="line">    clientSecret: #填写上面获取到的</span><br><span class="line">  admin: aibittek #填写你自己的，github用户名</span><br><span class="line">  proxy: https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</span><br></pre></td></tr></table></figure>

<p>按照以上填写就可以了，多了一个proxy，是为了解决近期的一个BUG的，参考下一章节。</p>
<h4 id="Gitalk-BUG修复"><a href="#Gitalk-BUG修复" class="headerlink" title="Gitalk BUG修复"></a>Gitalk BUG修复</h4><p>最近使用Gitalk的都出现了不能评论的问题，具体原因可参考<a href="https://github.com/gitalk/gitalk/issues/429">issue</a></p>
<p>错误提示：<strong>Error: Request failed with status code 403</strong></p>
<p>错误原因：<a href="https://mp.weixin.qq.com/s/Lwl9rf95EqlTYLfconjflQ">https://mp.weixin.qq.com/s/Lwl9rf95EqlTYLfconjflQ</a></p>
<p>解决办法：在Gitalk构造时增加CORS proxy，然后在配置中增加这个代理。</p>
<p>刚才在配置中已经增加了proxy的字段了，后面的网址就是CORS proxy，也可以通过cloudflare自己创建一个worker，通过Gitalk提供的请求要求搭建一个，也可以像我一样白嫖人家的😄</p>
<blockquote>
<p>注意：Gitalk有安全漏洞，从而导致GitHub获取到全局的读写权限，最差的可能是你的GitHub全站可能会被人删除跑路/(ㄒoㄒ)/~~，具体说明如下：<a href="https://www.v2ex.com/t/535608">https://www.v2ex.com/t/535608</a></p>
</blockquote>
<p>打开gitalk.ejs代码，增加以下一行即可，完结撒花解决这个BUG了</p>
<p>js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy: <span class="string">&#x27;&lt;%- theme.gitalk.proxy %&gt;&#x27;</span>,</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223175045009.png" alt="构造增加proxy字段"></p>
<p><strong>构造增加proxy字段</strong></p>
<p>重新构建部署后，打开网站看看是不是可以评论啦</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223175227501.png" alt="评论界面"></p>
<p><strong>评论界面</strong></p>
<p>如果不能够登录，需要登录授权后才能登录哦。</p>
<p>另外还可能出现一些其他奇怪的问题，大多的可能性和GitHub开启授权的时候填写的内容错误有关，需要注意callback URL的填写不是仓库的地址，而是github.io的静态网页访问的地址，但是如果你做了自定义域名，就要填写自定义域名的地址了，比如说我的就改成了<a href="https://kui.ge/">https://kui.ge</a></p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="优化访问速度"><a href="#优化访问速度" class="headerlink" title="优化访问速度"></a>优化访问速度</h3><p>GitHub国内的访问速度比较慢，另外GitHub也禁止了百度爬虫，导致百度不能收录GitHub内容，这些问题通过这一章节都可以得到解决。</p>
<ul>
<li>1、申请<a href="https://www.cloudflare.com/">Cloudflare账号</a>，点击右上角的<strong>添加站点</strong>按钮，输入自己的域名，如下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222140210567.png" alt="Cloudflare添加站点"></p>
<p><strong>Cloudflare添加站点</strong></p>
<ul>
<li>2、到自己的域名服务器上修改DNS为Cloudflare的DNS</li>
</ul>
<p>不同的域名注册商略有不同，参考如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222140044197.png" alt="修改域名DNS服务商到cloudflare"></p>
<p><strong>修改域名DNS服务商到cloudflare</strong></p>
<ul>
<li>3、把自己的域名DNS解析转到Cloudflare</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222135814969.png" alt="域名DNS转到Cloudflare"></p>
<p><strong>域名DNS转到Cloudflare</strong></p>
<ul>
<li><p>4、确认激活状态</p>
<p>进入注册Cloudflare的邮箱，查看激活状态。成功激活Cloudflare的邮箱参考如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222140648526.png" alt="Cloudflare激活提示邮件"></p>
<p><strong>Cloudflare激活提示邮件</strong></p>
</li>
<li><p>5、确定状态激活成功</p>
<p>如下所示，进入<a href="https://dash.cloudflare.com/">看板</a>查看概述，已经激活了。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222140754636.png" alt="image-20210222140754636"></p>
<p><strong>image-20210222140754636</strong></p>
<ul>
<li><p>6、访问自己的网站，访问速度明显加快</p>
<p>以下是参考，打开浏览器的F12调试窗口，设置Disable cache，查看Finish大概3秒钟基本数据加载完毕，之前需要7-8秒钟的时间</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222142007780.png" alt="网页在不开缓存的情况下加载显示速度"></p>
<p><strong>网页在不开缓存的情况下加载显示速度</strong></p>
<ul>
<li>7、使用工具查看最终的访问路由是否正确指向了Cloudflare</li>
</ul>
<p>通过<a href="https://tools.ipip.net/traceroute.php">在线路由查询网址</a>，输入自己想查询的域名，看看经过的路由是不是最终到达了Cloudflare。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222144656971.png" alt="Cloudflare访问路由验证"></p>
<p><strong>Cloudflare访问路由验证</strong></p>
<p><strong>其他的一些设置</strong></p>
<p>DNSSEC设置，点击启用后，在域名服务商处填写DS记录，大概10多分钟到1个小时后启动成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222155007186.png" alt="DNSSEC设置"></p>
<p><strong>DNSSEC设置</strong></p>
<p>SSL/TLS的端到端加密</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222155107313.png" alt="设置端到端的加密访问策略"></p>
<p><strong>设置端到端的加密访问策略</strong></p>
<h3 id="搜索引擎收录"><a href="#搜索引擎收录" class="headerlink" title="搜索引擎收录"></a>搜索引擎收录</h3><h4 id="Google-Analytics统计功能"><a href="#Google-Analytics统计功能" class="headerlink" title="Google Analytics统计功能"></a>Google Analytics统计功能</h4><p>打开<a href="https://analytics.google.com/">Google Analytics</a>链接，登录自己的谷歌账号，按提示添加服务，重要的地方如下，打开高级选项，选择创建Universal Analytics媒体资源，把要统计分析的网址填写上去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222165210139.png" alt="设置媒体资源"></p>
<p><strong>设置媒体资源</strong></p>
<p>得到跟踪ID</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222165652588.png" alt="获取跟踪ID"></p>
<p><strong>获取跟踪ID</strong></p>
<p>增加统计功能</p>
<p>在Hexo的主题配置文件_config.yml中查找googleAnalytics完成跟踪ID的添加，按照以下参考Google Analytics统计功能</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add google analytics configuration</span></span><br><span class="line"><span class="comment"># 添加 Google Analytics 配置</span></span><br><span class="line"><span class="attr">googleAnalytics:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">UA-xxxxxxxx-1</span></span><br></pre></td></tr></table></figure>

<h4 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h4><h5 id="收录域名提交"><a href="#收录域名提交" class="headerlink" title="收录域名提交"></a>收录域名提交</h5><ol>
<li><p>登录<a href="https://search.google.com/search-console/about">谷歌搜索排名网址</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222222819218.png" alt="收录域名提交"></p>
<p><strong>收录域名提交</strong></p>
</li>
<li><p>获取网站验证码</p>
<p>点击继续后，弹出谷歌网站验证码，点击复制，并把这个值按照图中的要求增加到域名的DNS记录中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223213459248.png" alt="获取网站验证码"></p>
<p><strong>获取网站验证码</strong></p>
</li>
<li><p>登录域名增加TXT解析记录</p>
<p>增加一条TXT记录，name为@，内容为以上谷歌提供的值，我这里kui.ge的域名DNS解析已经转入了Cloudflare，因此在Cloudflare的TXT解析记录如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222223329909.png" alt="TXT解析记录"></p>
<p><strong>TXT解析记录</strong></p>
</li>
<li><p>点击验证，提示验证成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222223553295.png" alt="验证成功界面"></p>
<p><strong>验证成功界面</strong></p>
</li>
<li><p>前往资源页面进行管理</p>
<p>点击站点地图，把博客根目录下构建生成的sitemap.xml的URL地址填写进去帮忙收录，可以看到谷歌识别到了24个有效访问链接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222225246537.png" alt="站点地图提交"></p>
<p><strong>站点地图提交</strong></p>
</li>
<li><p>查看收录结果</p>
<p>使用<code>site:kui.ge</code>便可以查看收录结果，一般24小时内就能够查阅到结果，使用谷歌这个功能需要科学上网的哦</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223094704695.png" alt="谷歌成功收录结果"></p>
<p><strong>谷歌成功收录结果</strong></p>
</li>
</ol>
<h5 id="Sitemap谷歌收录"><a href="#Sitemap谷歌收录" class="headerlink" title="Sitemap谷歌收录"></a>Sitemap谷歌收录</h5><ul>
<li><p>安装插件</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
<p>修改根节点_config.xml，添加以下内容：</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h4><p>提交百度有网页直接提交、手动提交、主动推送，自动推送和sitemap五种方式，各自的优缺点可以看<a href="https://zhuanlan.zhihu.com/p/129740968">这篇博文</a>。</p>
<h5 id="网页直接提交"><a href="#网页直接提交" class="headerlink" title="网页直接提交"></a>网页直接提交</h5><p>在百度搜索框搜索域名，然后点击提交网址，直接提交给百度即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222184206912.png" alt="网页提交指南"></p>
<p><strong>网页提交指南</strong></p>
<h5 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h5><p>登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击<a href="https://links.jianshu.com/go?to=https://ziyuan.baidu.com/site/siteadd">添加网站</a>，按提示操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222172445482.png" alt="添加站点"></p>
<p><strong>添加站点</strong></p>
<blockquote>
<p>注意：GitHub禁止了百度爬虫，因此需要确认是否完成了上一章节的Cloudflare设置</p>
</blockquote>
<p>HTML标签验证</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222173807500.png" alt="HTML标签验证"></p>
<p><strong>HTML标签验证</strong></p>
<p>先不要点击验证，找到Hexo主题的head.ejs文件，把上图的代码加入进来，然后<code>hexo clean &amp;&amp; hexo g -d</code>部署成功之后，再点击上面的完成验证。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222181525160.png" alt="添加baidu-site-verification"></p>
<p><strong>添加baidu-site-verification</strong></p>
<p>如果使用的是Next主题可以复制百度上图中提供的content值，在Next主题的_config.yml中搜索 <code>baidu_site_verification</code>填入即可。</p>
<h5 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h5><p>GitHub禁止百度爬虫访问的补救办法，并能够及时把新创建的文件提交给百度收录，也能保护原创文章，推荐。</p>
<ul>
<li><strong>安装hexo-baidu-url-submit插件</strong></li>
</ul>
<p>首先，在Hexo根目录下，安装本插件：</p>
<p>undefined</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>

<p><strong>请注意， 本插件的配置文件中包含秘钥， 请把您的Hexo博客源文件托管到私有仓库里。</strong></p>
<ul>
<li><strong>配置_config.yml文件</strong></li>
</ul>
<p>同样在根目录下，把以下内容配置到<code>_config.yml</code>文件中:</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">10</span>                 <span class="comment">## 比如10，代表提交最新的10个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">kui.ge</span>                 <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span>         <span class="comment">## 请注意这是您的秘钥，请不要发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span>         <span class="comment">## 文本文档的地址，新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure>

<p>your_token可以通过登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>，找到自动提交中的主动推送，找到token，填写进入即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222174736408.png" alt="主动推送token获取"></p>
<p><strong>主动推送token获取</strong></p>
<ul>
<li><strong>检查url</strong></li>
</ul>
<p>其次，记得查看<code>_config.yml</code>文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如:</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://kui.ge</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:title/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>加入deploy</strong></li>
</ul>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/aibittek/aibittek.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure>

<p>执行hexo d的时候，新的链接就会被推送了。</p>
<p>成功推送的显示结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223180208395.png" alt="成功推送的显示结果"></p>
<p><strong>成功推送的显示结果</strong></p>
<p><strong>实现原理</strong></p>
<p>推送功能的实现，分为两部分：</p>
<p>新链接的产生，<code>hexo g</code>会产生一个文本文件，里面包含最新的链接</p>
<p>新链接的提交，<code>hexo d</code>会从上述文件中读取链接，提交至百度搜索引擎。</p>
<h5 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h5><p><code>hexo-theme-matery/_config.yml</code> 默认打开，如下：</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 百度搜索资源平台提交链接</span></span><br><span class="line"><span class="attr">baiduPush:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="Sitemap百度收录"><a href="#Sitemap百度收录" class="headerlink" title="Sitemap百度收录"></a>Sitemap百度收录</h5><ul>
<li><p>安装插件</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
<p>修改根节点_config.xml，添加以下内容：</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="查看百度收录结果"><a href="#查看百度收录结果" class="headerlink" title="查看百度收录结果"></a>查看百度收录结果</h5><p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223094905172.png" alt="这是反例，1天了还没收录，还是各种手段都一起上的结果"></p>
<p><strong>这是反例，1天了还没收录，还是各种手段都一起上的结果</strong></p>
<p>此时我的心情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223095236095.png" alt="不要管哥的发型"></p>
<p><strong>不要管哥的发型</strong></p>
<h4 id="必应收录"><a href="#必应收录" class="headerlink" title="必应收录"></a>必应收录</h4><h5 id="收录方法"><a href="#收录方法" class="headerlink" title="收录方法"></a>收录方法</h5><p>点击<a href="https://www.bing.com/webmasters">必应收录网址</a>，使用谷歌账号登录，会自动检测谷歌收录服务，点击直接导入即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222225637845.png" alt="必应使用谷歌收录导入"></p>
<p><strong>必应使用谷歌收录导入</strong></p>
<p>Sitemap网站地图也要提交一遍，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222225807576.png" alt="Sitemap提交"></p>
<p><strong>Sitemap提交</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210222225910444.png" alt="提交sitemap.xml网站地图"></p>
<p><strong>提交sitemap.xml网站地图</strong></p>
<h5 id="收录结果"><a href="#收录结果" class="headerlink" title="收录结果"></a>收录结果</h5><p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223095416086.png" alt="必应收录结果"></p>
<p><strong>必应收录结果</strong></p>
<p>没有对比就没有伤害，百度我把网页提交、手动提交、自动提交、自动推送、sitemap、robots.txt能加的都加上了，目前还得不到收录，谷歌和必应基本上半天就有结果/(ㄒoㄒ)/~~</p>
<h4 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h4><h5 id="修改-url-格式"><a href="#修改-url-格式" class="headerlink" title="修改 url 格式"></a>修改 url 格式</h5><blockquote>
<p>seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面</p>
</blockquote>
<p>但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，修改 hexo 配置文件：</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:title/</span></span><br></pre></td></tr></table></figure>

<h5 id="nofollow设置"><a href="#nofollow设置" class="headerlink" title="nofollow设置"></a>nofollow设置</h5><p>外链越多，搜索引擎给此站点的权重就越低，即排位越后。为了提高权重，可以禁止搜索引擎跟进外链，添加 nofollow 属性就可以做到。</p>
<p>hexo 博客根目录安装插件</p>
<p>shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-nofollow --save</span><br></pre></td></tr></table></figure>

<p>编辑 hexo 配置文件，添加：</p>
<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># post：仅处理文章内容，site：处理全站所有页面</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;exclude1.com&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;exclude2.com&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="增加robots-txt"><a href="#增加robots-txt" class="headerlink" title="增加robots.txt"></a>增加robots.txt</h5><p>在 source 目录下添加 robots.txt ，编写爬虫规则，参考如下</p>
<p>txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /tags/</span><br><span class="line">Allow: /categories/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /lib/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line">Disallow: /old/</span><br><span class="line"></span><br><span class="line">Sitemap: http://kui.ge/sitemap.xml</span><br><span class="line">Sitemap: http://kui.ge/baidusitemap.xml</span><br></pre></td></tr></table></figure>

<h4 id="收录工具"><a href="#收录工具" class="headerlink" title="收录工具"></a>收录工具</h4><p>对于这么多的搜索引擎，使用命令的方式或者分别登录不同平台的搜索引擎进行提交不太方便，有没有聚合的能在一个地方对所有的所有引擎提交收录呢，整理了网页版本和软件版本，有需要的可以学习使用下哦，效率更高。</p>
<h5 id="网页版本"><a href="#网页版本" class="headerlink" title="网页版本"></a>网页版本</h5><p><a href="https://www.sousuoyinqingtijiao.com/">https://www.sousuoyinqingtijiao.com/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/aibittek/ImageHost/img/image-20210223100423764.png" alt="image-20210223100423764"></p>
<p><strong>image-20210223100423764</strong></p>
<h5 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a>站长工具</h5><p>有了网站免不了要进行维护，查看用户访问数据，以便有针对的满足用户的需求。</p>
<p>不仅可以通过谷歌分析、百度分析等分析引擎，也可以使用<a href="https://tool.chinaz.com/">站长工具</a>可以比较方便的查看网站被收录，访问数据的信息情况。</p>
]]></content>
      <tags>
        <tag>Github</tag>
        <tag>自建网站</tag>
      </tags>
  </entry>
  <entry>
    <title>利用闲置小鸡挖矿</title>
    <url>/posts/39413/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着虚拟货币牛市的到来，各种挖矿方法也层出不穷，今天就详细说说如何利用手头里闲置的VPS挖矿的方法，目前CPU挖矿比较主流的币种就是门罗币。先看看什么是门罗币：</p>
<blockquote>
<p>门罗币（XMR）是一个创建于2014年4月开源加密货币，它着重于隐私、分权和可扩展性。与自比特币衍生的许多加密货币不同，Monero基于CryptoNote协议，并在区块链模糊化方面有显著的算法差异。Monero的模块化代码结构得到了比特币核心维护者之一的Wladimir J. van der Laan的赞赏。Monero致力于成为可代替的不可追踪的电子货币。相比比特币及其分叉，Monero具有更高程度的匿名性。</p>
</blockquote>
<p>[start-plane type=”1″]接下来进入挖矿正题[/start-plane]</p>
<h2 id="第一步：准备工作-需要以下几样工具"><a href="#第一步：准备工作-需要以下几样工具" class="headerlink" title="第一步：准备工作(需要以下几样工具)"></a>第一步：准备工作(需要以下几样工具)</h2><ol>
<li>一个门罗币钱包</li>
<li>一台闲置的VPS(本教程使用的VPS为腾讯云轻量2核4G6M80G小鸡，操作系统为centos7)</li>
<li>一个矿池（本次使用的是猫池:<a href="https://c3pool.com/cn/%EF%BC%89(%E5%85%A8%E7%90%83XMR%E7%9F%BF%E6%B1%A0%E6%80%BB%E8%A7%88:https://miningpoolstats.stream/monero)">https://c3pool.com/cn/）(全球XMR矿池总览:https://miningpoolstats.stream/monero)</a></li>
</ol>
<h2 id="第二步：创建钱包-本次使用的钱包为mymonero钱包"><a href="#第二步：创建钱包-本次使用的钱包为mymonero钱包" class="headerlink" title="第二步：创建钱包(本次使用的钱包为mymonero钱包)"></a>第二步：创建钱包(本次使用的钱包为mymonero钱包)</h2><h3 id="1-打开mymonero官网，点击Create-new-wallet-创建一个新钱包"><a href="#1-打开mymonero官网，点击Create-new-wallet-创建一个新钱包" class="headerlink" title="1.打开mymonero官网，点击Create new wallet(创建一个新钱包)"></a>1.打开<a href="https://www.aff.vin/?golink=aHR0cHM6Ly93YWxsZXQubXltb25lcm8uY29tLw==">mymonero官网</a>，点击Create new wallet(创建一个新钱包)</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-01.create-new-wallet.png" alt="%title插图%num"></p>
<h3 id="2-这里会提示注意事项，选中GOT-IT，然后右上角Next进入下一步"><a href="#2-这里会提示注意事项，选中GOT-IT，然后右上角Next进入下一步" class="headerlink" title="2.这里会提示注意事项，选中GOT IT，然后右上角Next进入下一步"></a>2.这里会提示注意事项，选中GOT IT，然后右上角Next进入下一步</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-02.got-it.png" alt="%title插图%num"></p>
<h3 id="3-保存好助记词-以后登录钱包需要用到，建议手抄-，然后点击右上角的Next进入下一步"><a href="#3-保存好助记词-以后登录钱包需要用到，建议手抄-，然后点击右上角的Next进入下一步" class="headerlink" title="3.保存好助记词(以后登录钱包需要用到，建议手抄)，然后点击右上角的Next进入下一步"></a>3.保存好助记词(以后登录钱包需要用到，建议手抄)，然后点击右上角的Next进入下一步</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-03.write-down-mnemonic.png" alt="%title插图%num"></p>
<h3 id="4-验证助记符，把第二步保存的助记词的前七位，按照图片中显示的顺序依次选中，然后点击右上角的确定-Confirm"><a href="#4-验证助记符，把第二步保存的助记词的前七位，按照图片中显示的顺序依次选中，然后点击右上角的确定-Confirm" class="headerlink" title="4.验证助记符，把第二步保存的助记词的前七位，按照图片中显示的顺序依次选中，然后点击右上角的确定(Confirm)"></a>4.验证助记符，把第二步保存的助记词的前七位，按照图片中显示的顺序依次选中，然后点击右上角的确定(Confirm)</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-04.verify-mnemonics.png" alt="%title插图%num"></p>
<h3 id="5-到这里，钱包就算创建完成了，点击钱包就能显示钱包地址和其它内容"><a href="#5-到这里，钱包就算创建完成了，点击钱包就能显示钱包地址和其它内容" class="headerlink" title="5.到这里，钱包就算创建完成了，点击钱包就能显示钱包地址和其它内容"></a>5.到这里，钱包就算创建完成了，点击钱包就能显示钱包地址和其它内容</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-05.over.png" alt="%title插图%num"></p>
<h2 id="第三步：设置挖矿"><a href="#第三步：设置挖矿" class="headerlink" title="第三步：设置挖矿"></a>第三步：设置挖矿</h2><h3 id="1-运行一键挖矿命令"><a href="#1-运行一键挖矿命令" class="headerlink" title="1.运行一键挖矿命令"></a>1.运行一键挖矿命令</h3><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s -L http://download.c3pool.com/xmrig_setup/raw/master/setup_c3pool_miner.sh | LC_ALL=en_US.UTF-8 bash -s 你的XMR地址</span><br></pre></td></tr></table></figure>

<p>命令运行完毕，就自动开始挖了</p>
<h3 id="2-限制CPU"><a href="#2-限制CPU" class="headerlink" title="2.限制CPU"></a>2.限制CPU</h3><p>默认情况下，挖矿程序是100%占用CPU的性能，所以需要对CPU的占用做一些限制。这一步没有具体的比例，根据不同厂商对CPU的限制来设置百分比，原则上腾讯云的轻量服务器可以满载运行，但是保险起见，我这里设置了单核90%。</p>
<h4 id="1-安装CPULimit"><a href="#1-安装CPULimit" class="headerlink" title="(1). 安装CPULimit"></a>(1). 安装CPULimit</h4><p><strong>CentOS:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install cpulimit</span><br></pre></td></tr></table></figure>

<p><strong>Debian/Ubuntu:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install cpulimit</span><br></pre></td></tr></table></figure>

<p><strong>如果没有包，也不能编译安装，可以安装EPEL源:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装EPEL源</span><br><span class="line"></span><br><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line">#重新创建本地仓库缓存</span><br><span class="line"></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line">#然后yum下就可以了</span><br><span class="line"></span><br><span class="line">yum install cpulimit</span><br></pre></td></tr></table></figure>

<h4 id="2-使用CPULimit"><a href="#2-使用CPULimit" class="headerlink" title="(2). 使用CPULimit"></a>(2). 使用CPULimit</h4><p><strong>命令格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpulimit -l 限制百分比 -p 进程号</span><br><span class="line"></span><br><span class="line">cpulimit -e 进程名 -l 限制百分比</span><br></pre></td></tr></table></figure>

<p><strong>查找占用高的进程命令</strong></p>
<p>查找挖矿进程，直接top命令即可查看。如下：</p>
<p>PID：14967（进程号）</p>
<p>COMMAND：xmrig（进程名）</p>
<p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-07.top.png" alt="%title插图%num"></p>
<p>这里双核占用180，单核已经被限制到了90%，如果你没限制过，这里肯定是满载运行。</p>
<p><strong>安装Screen：</strong></p>
<p>因为要时刻监控这个进程，所以你需要用到screen。如果提示screen: command not found 命令不存在可以执行：</p>
<p><strong>CentOS:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure>

<p><strong>Debian/Ubuntu:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install screen</span><br></pre></td></tr></table></figure>

<p><strong>使用实例</strong></p>
<p>输入以下命令执行CPU的限制:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -S xmrig #新建会话</span><br><span class="line"></span><br><span class="line">cpulimit -l 180 -p 14967 #利用pid限制程序运行的cpu</span><br><span class="line"></span><br><span class="line">cpulimit -e xmrig -l 180 #利用进程名限制程序运行的cpu</span><br></pre></td></tr></table></figure>

<p>之后，按下CTRL+A+D 退出程序。</p>
<p><em>注意：只限制CPU的一个核心占用设置为90%，如果是两个核心你需要限制到180%</em></p>
<p><strong>效果</strong> </p>
<p>过几分钟，CPU使用就会限制到90左右。这时候可以查看腾讯云的后台管理</p>
<p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-10.cpu.png" alt="%title插图%num"></p>
<h4 id="3-其它查看进程号的方法"><a href="#3-其它查看进程号的方法" class="headerlink" title="(3).其它查看进程号的方法"></a>(3).其它查看进程号的方法</h4><p>查看具体进程的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux|grep xmrig</span><br></pre></td></tr></table></figure>

<p>第一个红框标注的就是我们要找的，可以和top命令对比下</p>
<p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-11.process.png" alt="%title插图%num"></p>
<p>然后，用前面的命令限制即可。</p>
<p><strong>至此，你的VPS就能在后台自由的挖矿了，哪怕关闭SSH都不受影响。</strong></p>
<h2 id="第四步：看看挖矿的收益情况"><a href="#第四步：看看挖矿的收益情况" class="headerlink" title="第四步：看看挖矿的收益情况"></a>第四步：看看挖矿的收益情况</h2><p>算力和收益情况直接在<a href="https://www.aff.vin/?golink=aHR0cHM6Ly9jM3Bvb2wuY29tL2NuLw==">猫池</a>的网页上查看，猫池是机枪池，并不是指定就去挖xmr了，他可能在挖山寨币，网页上会显示换算到xmr的算力，因此他的算力可能比直接挖xmr要高很多很多。<br>腾讯云轻量Intel 2h4g 算力1.2kh/s左右，日收益0.5RMB左右，AMD的机器算力应该更高。</p>
<h3 id="1-输入你的XMR地址，回车，稍等片刻就能看到收益了。"><a href="#1-输入你的XMR地址，回车，稍等片刻就能看到收益了。" class="headerlink" title="1.输入你的XMR地址，回车，稍等片刻就能看到收益了。"></a>1.输入你的XMR地址，回车，稍等片刻就能看到收益了。</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-08.address.png" alt="%title插图%num"></p>
<h3 id="2-收益效果"><a href="#2-收益效果" class="headerlink" title="2.收益效果"></a>2.收益效果</h3><p><img src="https://cdn.jsdelivr.net/gh/cnias/affvin/2021/monero-09.income.png" alt="%title插图%num"></p>
<h2 id="第五步：卸载脚本"><a href="#第五步：卸载脚本" class="headerlink" title="第五步：卸载脚本"></a>第五步：卸载脚本</h2><p>既然有了挖矿的方法，如果不想挖了怎么办？一键命令搞定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s -L http://download.c3pool.com/xmrig_setup/raw/master/uninstall_c3pool_miner.sh | bash -s</span><br></pre></td></tr></table></figure>

<p><strong>最后，祝大家挖矿愉快，财源滚滚！</strong></p>
]]></content>
      <tags>
        <tag>挖矿</tag>
      </tags>
  </entry>
  <entry>
    <title>office全局管理面板搭建</title>
    <url>/posts/36978/</url>
    <content><![CDATA[<h1 id="o365"><a href="#o365" class="headerlink" title="o365"></a>o365</h1><p>O365管理系统是一个以java语言开发的基于Microsoft Graph Restful API的多全局管理系统，理论上支持任何Office全局的管理(A1,A3,A1P,E3,E5等)，你可以很方便的使用它来批量添加，批量删除，批量启用，批量禁用，搜索和查看用户，生成邀请码，邀请朋友注册，提升和收回管理员权限，更新密钥，查看订阅，分配订阅(创新用户时)，查看单全局或多全局报告，登录同时需要微信许可（此功能默认关闭）</p>
<h2 id="最低环境需求"><a href="#最低环境需求" class="headerlink" title="最低环境需求"></a>最低环境需求</h2><table>
<thead>
<tr>
<th>类型</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>1C</td>
</tr>
<tr>
<td>RAM</td>
<td>0.75G</td>
</tr>
<tr>
<td>硬盘</td>
<td>5GB</td>
</tr>
</tbody></table>
<h2 id="体验o365-in-heroku"><a href="#体验o365-in-heroku" class="headerlink" title="体验o365 in heroku"></a>体验o365 in heroku</h2><p>o365已部署于heroku,你可以访问以下路径体验最新版的o365,你也可以将工程fork到自己的仓库用自己的heroku账号进行部署（推荐）</p>
<p><a href="https://oo365.herokuapp.com/">https://oo365.herokuapp.com</a></p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="首页预览"><a href="#首页预览" class="headerlink" title="首页预览"></a>首页预览</h3><p><a href="https://github.com/vanyouseea/o365/blob/master/pic/001.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/001.PNG" alt="alt 首页"></a> 登录后请根据首页介绍，先创建APP，然后赋予以下7个权限，需要注意的是，API权限请务必选择<strong>应用程序</strong></p>
<table>
<thead>
<tr>
<th>API名</th>
<th>大致作用</th>
</tr>
</thead>
<tbody><tr>
<td>Application.ReadWrite.All</td>
<td>用于新增密钥的功能</td>
</tr>
<tr>
<td>Application.ReadWrite.OwnedBy</td>
<td>用于新增密钥的功能</td>
</tr>
<tr>
<td>Directory.ReadWrite.All</td>
<td>用于订阅，域名，用户管理的功能</td>
</tr>
<tr>
<td>RoleManagement.ReadWrite.Directory</td>
<td>用于特权角色的管理</td>
</tr>
<tr>
<td>User.ManageIdentities.All</td>
<td>用于用户的管理</td>
</tr>
<tr>
<td>User.ReadWrite.All</td>
<td>用于用户的管理</td>
</tr>
<tr>
<td>Reports.Read.All</td>
<td>用于生成Onedrive,Exchange详细报告</td>
</tr>
</tbody></table>
<h3 id="配置和报告-gt-Office配置"><a href="#配置和报告-gt-Office配置" class="headerlink" title="[配置和报告] -&gt; Office配置"></a>[配置和报告] -&gt; Office配置</h3><ul>
<li><strong>新增</strong><br>将刚才得到的3个要素填入 <a href="https://github.com/vanyouseea/o365/blob/master/pic/002.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/002.PNG" alt="alt 填入APP信息"></a><br>PS 配置根据备注排序，如果你想要有序，可以设置备注</li>
<li><strong>删除</strong>，<strong>修改</strong>，<strong>刷新</strong>不做介绍</li>
<li><strong>导入</strong><br>如果不想麻烦，也可以使用导入功能，先下载模板，填写好信息后，可以批量导入<br><a href="https://github.com/vanyouseea/o365/blob/master/pic/003.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/003.PNG" alt="alt 导入"></a></li>
<li><strong>导出</strong><br>将所有APP信息导出为csv文件</li>
<li><strong>切换全局</strong><br>选中一行后，点击切换全局，O365很多的TAB工作的前提是需要有一个当前全局为是的APP，被选中的行将会以浅蓝色标记<br><a href="https://github.com/vanyouseea/o365/blob/master/pic/004.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/004.PNG" alt="alt 切换全局"></a></li>
<li><strong>更新密钥</strong><br>将创建一个过期时间为2099-12-31的新密钥，成功后会替换现有密钥，若不想更改现有密钥，请取消<br><a href="https://github.com/vanyouseea/o365/blob/master/pic/005.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/005.PNG" alt="alt 更新密钥"></a></li>
<li><strong>校验</strong><br>校验只验证APP 3要素的正确性(<strong>不包含权限的校验</strong>)</li>
<li><strong>生成报告</strong><br>选一行后，点击此按钮，会生成总览报告，此报告可以在Office总览报告中找到<br><a href="https://github.com/vanyouseea/o365/blob/master/pic/006.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/006.PNG" alt="alt 更新密钥"></a></li>
<li><strong>On/Off</strong><br>显示/隐藏APPID和密钥</li>
<li><strong>帮助</strong><br>有什么问题，你可以尝试点击帮助了解更多</li>
</ul>
<h3 id="用户-gt-管理用户"><a href="#用户-gt-管理用户" class="headerlink" title="[用户] -&gt; 管理用户"></a>[用户] -&gt; 管理用户</h3><p><a href="https://github.com/vanyouseea/o365/blob/master/pic/007.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/007.PNG" alt="alt 用户首页"></a></p>
<ul>
<li><strong>添加</strong><br><a href="https://github.com/vanyouseea/o365/blob/master/pic/007.5.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/007.5.PNG" alt="alt 添加"></a></li>
<li><strong>批量添加</strong><br>批量添加有2种策略，一种是随机5字符，另外一种是自增长数字<br><a href="https://github.com/vanyouseea/o365/blob/master/pic/008.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/008.PNG" alt="alt 批量添加"></a></li>
<li><strong>删除</strong>，<strong>刷新</strong>不做介绍</li>
<li><strong>启用</strong>，<strong>禁用</strong><br>分别为启用和禁用选中的用户</li>
<li><strong>提权</strong>，<strong>撤权</strong><br>分别为提升或撤销一个用户为全局管理员<br>同时他们支持更多角色的权限赋予与收回， 你可以在[配置和报告] -&gt; 系统配置中修改关键字DEFAULT_ADMIN_ROLE_ID的值为其他的admin的role，比如通过这种方式，你可以提升一个用户为用户管理员<br><a href="https://github.com/vanyouseea/o365/blob/master/pic/009.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/009.PNG" alt="alt 批量添加"></a></li>
<li><strong>搜索</strong><br>可以搜索名字和邮箱前缀</li>
<li><strong>帮助</strong><br>有什么问题，你可以尝试点击帮助了解更多</li>
</ul>
<h3 id="用户-gt-查看特权用户"><a href="#用户-gt-查看特权用户" class="headerlink" title="[用户] -&gt; 查看特权用户"></a>[用户] -&gt; 查看特权用户</h3><p><a href="https://github.com/vanyouseea/o365/blob/master/pic/010.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/010.PNG" alt="alt 查看特权用户"></a></p>
<h3 id="许可证-gt-查看许可证"><a href="#许可证-gt-查看许可证" class="headerlink" title="[许可证] -&gt; 查看许可证"></a>[许可证] -&gt; 查看许可证</h3><p><a href="https://github.com/vanyouseea/o365/blob/master/pic/011.PNG"><img src="https://github.com/vanyouseea/o365/raw/master/pic/011.PNG" alt="alt 查看许可证"></a></p>
<h3 id="配置和报告-gt-Office总览报告"><a href="#配置和报告-gt-Office总览报告" class="headerlink" title="[配置和报告] -&gt; Office总览报告"></a>[配置和报告] -&gt; Office总览报告</h3><ul>
<li><p>手动执行</p>
<p>生成所有全局的总览报告，此报告包含总用户数，管理员数和SPO可用性</p>
<p><img src="https://github.com/vanyouseea/o365/raw/master/pic/012.PNG" alt="alt 查看许可证"></p>
<ul>
<li>灰色代表无效全局</li>
<li>红色代表代表全局无管理员或者无管理员存活的全局</li>
<li>橙色代表SPO为0的全局</li>
</ul>
</li>
<li><p><strong>下载Exchange报告</strong><br>生成选中全局的Exchange报告，此报告包含了所有用户的邮件使用情况</p>
</li>
<li><p><strong>下载Onedrive报告</strong><br>生成选中全局的Onedrive报告，此报告包含了所有用户的Onedrive使用情况<br>由于微软更新了隐私策略，以上2个报告中的用户的信息和url会以乱码代替，如果想要查看真实的用户，请以管理员账号登录<a href="https://admin.microsoft.com/#/homepage">https://admin.microsoft.com/#/homepage</a> 选择<strong>设置</strong>-&gt;<strong>组织设置</strong>-&gt;<strong>报告</strong>，取消勾选 <strong>在所有报告中，显示用户、组和站点的已取消识别的名称</strong>即可显示真实信息</p>
</li>
</ul>
<h3 id="配置和报告-gt-系统配置"><a href="#配置和报告-gt-系统配置" class="headerlink" title="[配置和报告] -&gt; 系统配置"></a>[配置和报告] -&gt; 系统配置</h3><p>WX_CALLBACK_IND<br>WX_CALLBACK_TOKEN<br>WX_CORPID<br>WX_CORPSECRET<br>WX_AGENTID<br>WX_CALLBACK_AESKEY<br>以上6个参数的设置请参考word文档, <a href="https://github.com/vanyouseea/o365/blob/master/docs/%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%93%8D%E5%BA%94.docx">https://github.com/vanyouseea/o365/blob/master/docs/%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%93%8D%E5%BA%94.docx</a><br><strong>请谨慎使用，如果未通过，请立即把WX_CALLBACK_IND设为N，避免把自己关外面</strong></p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>基于v1.7.1版的docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull vanyouseea/o365</span><br><span class="line">docker run -d -p 9527:9527 vanyouseea/o365</span><br><span class="line"></span><br><span class="line">#如果你之前使用过，但是不想手动迁移数据，那么可以这样做，/root/o365/data是你本地的文件夹</span><br><span class="line">#建议使用这种方法，以后你如果想要迁移数据，直接拷贝/root/o365/data文件就行了</span><br><span class="line">docker run -d -p 9527:9527 -v /root/o365/data:/data vanyouseea/o365</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>onedrive</tag>
        <tag>全局管理</tag>
      </tags>
  </entry>
  <entry>
    <title>微软OneDrive网盘免费升级到25T容量教程</title>
    <url>/posts/36110/</url>
    <content><![CDATA[<p><strong>说明：</strong>之前老有人提到<code>OneDrive 5T</code>不够用，这里博主就分享个免费升级<code>25T</code>的方法，也是微软很早就出的一个政策，部分订阅的<code>OneDrive</code>网盘使用量超过<code>90%</code>的可免费申请提高容量到<code>25T</code>，博主也是很早就申请了，这里就大概说下，有需求的可以升级下。</p>
<h2 id="申请需知"><a href="#申请需知" class="headerlink" title="申请需知"></a>申请需知</h2><p>支持升级到<code>OneDrive 25T</code>的订阅如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Office 365 企业版 E3</span><br><span class="line">Office 365 企业版 E5</span><br><span class="line">OneDrive for Business 计划 2</span><br><span class="line">SharePoint Online 计划 2</span><br><span class="line">Office 365 企业版 E3</span><br><span class="line">Office 365 企业版 E5</span><br><span class="line">Office 365 A1</span><br><span class="line">Office 365 A3</span><br><span class="line">Office 365 A5</span><br><span class="line">Office 365 美国政府版 G3</span><br><span class="line">Office 365 美国政府版 G5</span><br><span class="line">Office 365 非营利版 E3</span><br><span class="line">Office 365 非赢利组织版 E5</span><br><span class="line">Microsoft 365 企业版 E3</span><br><span class="line">Microsoft 365 企业版 E5</span><br><span class="line">Microsoft 365 A3</span><br><span class="line">Microsoft 365 A5</span><br><span class="line">Microsoft 365 美国政府版 G3</span><br><span class="line">Microsoft 365 美国政府版 G5</span><br><span class="line">Microsoft 365 非营利组织版 E3</span><br><span class="line">Microsoft 365 非营利组织版 E5</span><br></pre></td></tr></table></figure>

<p>升级规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果用户已使用5TB存储空间的至少90%容量，Microsoft最多会将OneDrive中的默认存储空间增加到每用户25 TB（如有需要，管理员可以设置更低的每用户存储空间限制）。</span><br><span class="line"></span><br><span class="line">对于已使用25 TB OneDrive存储空间的至少90%的任何用户，将向各个用户分配25TB SharePoint团队网站作为额外的云存储空间。此额外存储空间以额度方式提供给组织。</span><br></pre></td></tr></table></figure>

<h2 id="申请方法"><a href="#申请方法" class="headerlink" title="申请方法"></a>申请方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提示：以下申请操作都需要全局管理员操作，如果需求大，也可以给自己其它的账号也升级到25T。</span><br></pre></td></tr></table></figure>

<p>首先让自己或其中一个子账号的<code>5T</code>网盘使用量超过<code>90%</code>，占比还不够的可以通过复制粘贴的形式快速占到<code>90%</code>以上。<br><a href="https://www.moerats.com/usr/picture/onedrive_25(1).png"><img src="https://www.moerats.com/usr/picture/onedrive_25(1).png" alt="请输入图片描述"></a><br>这里估计有人会觉得复制粘贴很慢，其实要是网络好的话，随便上传个几十<code>M</code>的文件复制粘贴，十几分钟就可以做到从<code>0</code>到<code>4.5T</code>。</p>
<p>然后管理员登录后台→<a href="https://admin.microsoft.com/Adminportal/Home">传送门</a>，点击左侧支持-新建服务请求。<br><a href="https://www.moerats.com/usr/picture/onedrive_25(2).png"><img src="https://www.moerats.com/usr/picture/onedrive_25(2).png" alt="请输入图片描述"></a><br>然后在帮助框写上类似下面一句话。<br><a href="https://www.moerats.com/usr/picture/onedrive_25(3).png"><img src="https://www.moerats.com/usr/picture/onedrive_25(3).png" alt="请输入图片描述"></a><br>然后填上管理员邮箱，附件上传几张该账号容量超过<code>90%</code>的截图，包括账户信息。<br><a href="https://www.moerats.com/usr/picture/onedrive_25(4).png"><img src="https://www.moerats.com/usr/picture/onedrive_25(4).png" alt="请输入图片描述"></a><br>最后发送即可，截图不规范的，中途可能会有工作人员打电话要你重新发图片给他。</p>
<p>最后等一天，成功的邮件就会发给你，然后这时候你就照着邮件给的方法自行升级到<code>25T</code>。<br><a href="https://www.moerats.com/usr/picture/onedrive_25(5).png"><img src="https://www.moerats.com/usr/picture/onedrive_25(5).png" alt="请输入图片描述"></a></p>
<h2 id="升级方法"><a href="#升级方法" class="headerlink" title="升级方法"></a>升级方法</h2><p>1、我们先安装最新的<code>SharePoint Online Management Shell</code>→<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=35588">下载地址</a>。<br>2、点击电脑左下角开始按钮，搜索<code>PowerShell</code>，然后单击<code>Windows PowerShell</code>，此时会弹出一个命令框。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提示：如果用PowerShell操作失败的，可以使用SharePoint Online Management Shell操作。</span><br></pre></td></tr></table></figure>

<p>先检查下<code>SharePoint Online</code>是否安装成功，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-Module -Name Microsoft.Online.SharePoint.PowerShell -ListAvailable | Select Name,Version</span><br><span class="line"></span><br><span class="line">#如果输出以下信息则安装成功</span><br><span class="line">Name                                   Version</span><br><span class="line">----                                   -------</span><br><span class="line">Microsoft.Online.SharePoint.PowerShell 16.0.9021.0</span><br></pre></td></tr></table></figure>

<p>接下来依次输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#adminUPN为管理员邮箱，orgName为你设置的组织名</span><br><span class="line">$adminUPN=&quot;admin@moerats.onmicrosoft.com&quot;</span><br><span class="line">$orgName=&quot;moerats&quot;</span><br><span class="line">#该步会弹出一个窗口，会要求你输入邮箱密码</span><br><span class="line">$userCredential = Get-Credential -UserName $adminUPN -Message &quot;Type the password.&quot;</span><br><span class="line">Connect-SPOService -Url https://$orgName-admin.sharepoint.com -Credential $userCredential</span><br><span class="line">#这里默认修改为25T，将后面的地址改成你要修改的OneDrive网盘地址，地址仿照下面的即可</span><br><span class="line">Set-SPOSite -Identity https://moerats-my.sharepoint.com/personal/moerats_admin_onmicrosoft_com -StorageQuota 26214400</span><br></pre></td></tr></table></figure>

<p>此时我们会发现容量已经升级到了<code>25T</code>。<br><a href="https://www.moerats.com/usr/picture/onedrive_25(6).png"><img src="https://www.moerats.com/usr/picture/onedrive_25(6).png" alt="请输入图片描述"></a><br>最后要注意的是，网盘使用量至少要保留<code>4.5T</code>以上，不然随时可能会变成<code>5T</code>。当然如果你<code>25T</code>使用量达到了<code>90%</code>，还可以再次用同样办法申请<code>25TB SharePoint</code>团队网站，但不会增加自身的<code>OneDrive</code>网盘容量了。</p>
]]></content>
      <tags>
        <tag>升级</tag>
        <tag>OneDrive</tag>
      </tags>
  </entry>
  <entry>
    <title>用Telegram Bot轻松上传文件到自己的云端硬盘</title>
    <url>/posts/1647/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次要上传档案</p>
<p>都要开启Google云端硬盘</p>
<p>还要登入才能使用</p>
<p>有没有更快的方式呢？</p>
<p>当然有</p>
<p>但要写程序</p>
<p>对于现代忙碌的人实在太痛苦了</p>
<p>程序就让我帮你写吧</p>
<p>你们只要复制贴上就可以完成</p>
<h1 id="实作"><a href="#实作" class="headerlink" title="实作"></a>实作</h1><h2 id="前置作业"><a href="#前置作业" class="headerlink" title="前置作业"></a>前置作业</h2><p>1.拥有一个Telegram帐号</p>
<p>2.拥有一个Heroku帐号</p>
<p>3.拥有一个Google帐号</p>
<p>*Heroku APP名称建议与Telegram Bot名称相同，较好管理</p>
<h2 id="第一步到Github"><a href="#第一步到Github" class="headerlink" title="第一步到Github"></a>第一步到Github</h2><p><a href="https://github.com/SAOJSM/TG-UPLOAD-FILE-TO-GDRIVE"><strong>点我前往</strong></a></p>
<h2 id="第二步找到Deploying内的紫色按钮按下，并登入Heroku"><a href="#第二步找到Deploying内的紫色按钮按下，并登入Heroku" class="headerlink" title="第二步找到Deploying内的紫色按钮按下，并登入Heroku"></a>第二步找到Deploying内的紫色按钮按下，并登入Heroku</h2><p>如下图↓</p>
<p><img src="https://eggs.eggsmemory.workers.dev/TGBOT%20GDRIVE/Deploying.jpg" alt="img"></p>
<h2 id="第三步-开始部属程序"><a href="#第三步-开始部属程序" class="headerlink" title="第三步 开始部属程序"></a>第三步 开始部属程序</h2><h3 id="1-到Telegram官网新增APP"><a href="#1-到Telegram官网新增APP" class="headerlink" title="1.到Telegram官网新增APP"></a>1.到Telegram官网新增APP</h3><p><strong><a href="https://my.telegram.org/apps">点我前往</a></strong></p>
<h3 id="2-复制api-id、api-hash到Heroku对应字段（每一格都有中文说明）"><a href="#2-复制api-id、api-hash到Heroku对应字段（每一格都有中文说明）" class="headerlink" title="2.复制api_id、api_hash到Heroku对应字段（每一格都有中文说明）"></a>2.复制api_id、api_hash到Heroku对应字段（每一格都有中文说明）</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3-到BotFather新增机器人"><a href="#3-到BotFather新增机器人" class="headerlink" title="3.到BotFather新增机器人"></a>3.到BotFather新增机器人</h3><p><strong><a href="https://my.telegram.org/apps">点我前往</a></strong></p>
<h3 id="4-複製token-直接點擊即可複製-貼到Heroku對應欄位-每一格都有中文說明"><a href="#4-複製token-直接點擊即可複製-貼到Heroku對應欄位-每一格都有中文說明" class="headerlink" title="4.複製token(直接點擊即可複製)貼到Heroku對應欄位(每一格都有中文說明)"></a>4.複製token(直接點擊即可複製)貼到Heroku對應欄位(每一格都有中文說明)</h3><h3 id="5-取得自己的Telegramid"><a href="#5-取得自己的Telegramid" class="headerlink" title="5.取得自己的Telegramid"></a>5.取得自己的Telegramid</h3><p><a href="https://t.me/userinfobot"><strong>點我前往</strong></a></p>
<p>點擊Start後複製Id後面的數字貼到Heroku對應欄位(每一格都有中文說明)</p>
<h3 id="5-取得Support-Chat-Link"><a href="#5-取得Support-Chat-Link" class="headerlink" title="5.取得Support Chat Link"></a>5.取得Support Chat Link</h3><p><strong><a href="https://my.telegram.org/apps">點我前往</a></strong></p>
<p>複製BotFather回應中t.me開頭的網址貼到Heroku對應欄位(每一格都有中文說明)</p>
<h3 id="6-點選Deploy-app，等待完成"><a href="#6-點選Deploy-app，等待完成" class="headerlink" title="6.點選Deploy app，等待完成"></a>6.點選Deploy app，等待完成</h3><h3 id="7-讓APP開始運作"><a href="#7-讓APP開始運作" class="headerlink" title="7.讓APP開始運作"></a>7.讓APP開始運作</h3><p>點選Manage APP → Resources → 找到Free Dynos內指令最後方的鉛筆 → 點擊鉛筆並將開關開啟 →點選Confirm即可</p>
<h3 id="8-紀錄-Bot-指令方便快速操作"><a href="#8-紀錄-Bot-指令方便快速操作" class="headerlink" title="8.紀錄 Bot 指令方便快速操作"></a>8.紀錄 Bot 指令方便快速操作</h3><p>回到Bot Father → 輸入 /mybots → 選擇你新增的機器人 → 點選 Edit Bot → 點選 Edit Commands</p>
<p>貼上下方指令(紅字部分)再按下Enter</p>
<p>start - 無用指令<br>help - 查看幫助<br>auth - 授權Bot取得Google Drive權限<br>setfolder - 指定上傳資料夾<br>copy - 拷貝雲端硬碟檔案<br>revoke - 撤銷Bot權限<br>del - 刪除雲端硬碟檔案</p>
<h3 id="9-授权机器人"><a href="#9-授权机器人" class="headerlink" title="9.授权机器人"></a>9.授权机器人</h3><p>点击Bot Father在新增完给你的响应中的链接（同Support Chat Link）</p>
<p>输入 /auth 点击 Bot 给你的链接</p>
<p>登入Google并同意权限</p>
<p>将授权码贴给Bot即可</p>
<h3 id="10-指定上传文件夹（可选）"><a href="#10-指定上传文件夹（可选）" class="headerlink" title="10.指定上传文件夹（可选）"></a>10.指定上传文件夹（可选）</h3><p>把Google云端硬盘文件夹的网址整个复制下来，贴在/setfolder后面（记得空一格）</p>
<p>格式：/setfolder云端硬盘文件夹网址</p>
<p>*红字部分替换为你的云端硬盘文件夹</p>
<p>*若不指定就会直接上传到根目录</p>
<h3 id="11-完成"><a href="#11-完成" class="headerlink" title="11.完成"></a>11.完成</h3><p>之后可以直接转传到Telegram档案给机器人</p>
<p>或是上传档案、音档、影片给机器人</p>
<p>也可以把链接直接给机器人</p>
<p>它就会帮你（下载后）上传到云端硬盘了</p>
<p>*请把机器人当作人，不要一次丢太多档案给它，很容易造成程序崩溃</p>
]]></content>
      <tags>
        <tag>转存</tag>
        <tag>heroku</tag>
        <tag>Google drive</tag>
      </tags>
  </entry>
  <entry>
    <title>无需申请,手动把Onedrive for business容量扩充到25T</title>
    <url>/posts/34536/</url>
    <content><![CDATA[<p>● 2021.2.2日反馈 开发者的E5已经不能后台升级25T了，一些之前升级的也变回了5T</p>
<p>且工单向客服申请也不再接受扩容请求</p>
<hr>
<p>  今天有小伙伴告知，现在Onedrive for business升级25T不要需要向客服申请了，管理员可以直接在后台操作即可，博主在自己的的E3上尝试了一下的确如此，全程在在后台操作即可，不需要工单申请，不需要PS命令行操作，有管理员的小伙伴也去试试吧。</p>
<p>  根据以往的资料，支持升级到OneDrive 25T的订阅如下：（其他订阅的也可以试试说不定有惊喜）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Office 365 企业版 E3Office 365 企业版 E5OneDrive for Business 计划 2SharePoint Online 计划 2Office 365 企业版 E3Office 365 企业版 E5Office 365 A1Office 365 A3Office 365 A5Office 365 美国政府版 G3Office 365 美国政府版 G5Office 365 非营利版 E3Office 365 非赢利组织版 E5Microsoft 365 企业版 E3Microsoft 365 企业版 E5Microsoft 365 A3Microsoft 365 A5Microsoft 365 美国政府版 G3Microsoft 365 美国政府版 G5Microsoft 365 非营利组织版 E3Microsoft 365 非营利组织版 E5</span><br></pre></td></tr></table></figure>



<hr>
<p>话不多说，上管理员账号。</p>
<p>升级规则如下：</p>
<p>如果<strong>用户已使用5TB存储空间的至少90%容量</strong>，Microsoft最多会将OneDrive中的默认存储空间增加到每用户25 TB（如有需要，管理员可以设置更低的每用户存储空间限制）。</p>
<p>提示：如果你租户上还没有一个使用量超过4.5T的账号，可以通过多次复制快速达到4.5T</p>
<p>升级前截图：</p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/46101617778690.png" alt="img"></p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/88211617778690.png" alt="img"></p>
<hr>
<p>升级具体操作：</p>
<p>1）登录管理员后台，<a href="https://admin.microsoft.com/%EF%BC%8C%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8B%E8%A7%92%E7%9A%84%E9%9C%80%E8%A6%81%E5%B8%AE%E5%8A%A9">https://admin.microsoft.com/，点击右下角的需要帮助</a></p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/28141617778691.png" alt="img"></p>
<p>2）搜索“OneDrive Storage limited to 5TB”，根据要求填写信息，UPN为需要升级的账号，运行测试。</p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/69561617778691.png" alt="img"></p>
<p>3）测试结果会提示“未配置额度增加超过5T”,点击更新配置即可。</p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/19621617778692.png" alt="img"></p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/13321617778692.png" alt="img"></p>
<p>4）重新打开这个用户的资料，编辑onedrive容量，你会发现可以修改成25T了。</p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/59181617778693.png" alt="img"></p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/52341617778693.png" alt="img"></p>
<p>成功升级25T，相比以前需要向客服申请、需要Powershell更改的操作现在简单多了。</p>
<p>另外，子账号在网页端查看已使用容量的方法是把onedrive链接后面的onedrive.aspx改为storman.aspx</p>
<p>例如：<a href="https://m4a1-my.sharepoint.com/personal/xxx_xxx_me/_layouts/15/storman.aspx">https://m4a1-my.sharepoint.com/personal/xxx_xxx_me/_layouts/15/storman.aspx</a></p>
<p><img src="https://blog.jialezi.net/admin/editor/php/upload/45231617778694.png" alt="img"></p>
]]></content>
      <tags>
        <tag>升级</tag>
        <tag>OneDrive</tag>
      </tags>
  </entry>
  <entry>
    <title>一个支持部署在Heroku上的Telegram搜图机器人</title>
    <url>/posts/63489/</url>
    <content><![CDATA[<p>一个聚合搜索图片的tg机器人,用于搜图、搜番、搜本子，支持部署在heroku上。</p>
<p>项目地址：<a href="https://github.com/666wcy/seach_photo-telegram-bot-heroku">seach_photo-telegram-bot-heroku</a></p>
<p>search手快打错了…懒得重建项目了，就这样，不影响</p>
<p>2020.01.29：修复逻辑，不使用1小时后休眠，打开链接后唤醒。</p>
<p><strong>新建后请先打开一次链接唤醒机器人</strong></p>
<p>还是写一下安装教程，既然写教程，就要写详细一点，</p>
<p><strong>目前支持的网站：</strong></p>
<p><a href="https://saucenao.com/">saucenao</a></p>
<p><a href="https://trace.moe/">WhatAnime</a></p>
<p><a href="https://ascii2d.net/">ascii2d</a></p>
<p><a href="http://www.iqdb.org/">iqdb</a></p>
<h1 id="Heroku-部署"><a href="#Heroku-部署" class="headerlink" title="Heroku 部署"></a>Heroku 部署</h1><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><p>一个heroku账号<br>Telegram bot api</p>
<h2 id="Telegram-bot-api-申请"><a href="#Telegram-bot-api-申请" class="headerlink" title="Telegram bot api 申请"></a>Telegram bot api 申请</h2><p><strong>1.打开telegram</strong></p>
<p><strong>2.添加 @BotFather</strong></p>
<p><strong>3.发送指令</strong></p>
<p><code>/newbot</code><br>输入机器人名字<br>输入机器人用户名(英文，以 bot 结尾)</p>
<p><a href="https://cdn.jsdelivr.net/gh/666wcy/img_share@main/img/%E8%8E%B7%E5%8F%96API.4v7mbmqmyc60.png"><img src="https://cdn.jsdelivr.net/gh/666wcy/img_share@main/img/%E8%8E%B7%E5%8F%96API.4v7mbmqmyc60.png" alt="img"></a></p>
<p><strong>4.此时你已经得到一个Telegram bot的API</strong></p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>登录heroku账号;若浏览器中已登录heroku则跳过这一步</p>
<p>打开<a href="https://github.com/666wcy/seach_photo-telegram-bot-heroku">项目地址</a></p>
<p>点击项目地址网页下面的图标(非本页)</p>
<p>[<a href="https://www.herokucdn.com/deploy/button.svg"><img src="https://www.herokucdn.com/deploy/button.svg" alt="Deploy"></a></p>
<p><a href="https://www.herokucdn.com/deploy/button.svg">Deploy</a></p>
<p>]</p>
<p>此时会新建一个 Heroku APP</p>
<p><strong>App name</strong> 随意填写，注意是英文</p>
<p><strong>Choose a region</strong> 是应用的位置，自己选择即可</p>
<p><strong>TELEGRAM_TOKEN</strong> 填写刚才获取的API</p>
<p>填写完成后</p>
<p>点击 <strong>Deploy app</strong></p>
<p>等待安装</p>
<p>安装完成后打开容器链接唤醒bot</p>
<p>如果bot无反应，访问 <strong>容器网址/bot</strong> 这个网址检查bot信息</p>
<p>heroku的部署到此结束</p>
<h1 id="Python-环境下部署"><a href="#Python-环境下部署" class="headerlink" title="Python 环境下部署"></a>Python 环境下部署</h1><p><strong>下载项目</strong></p>
<p><strong>修改 bot.py</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token = os.environ[&#x27;TELEGRAM_TOKEN&#x27;]</span><br><span class="line">#删除上面这一句代码</span><br><span class="line">session = requests.session()</span><br><span class="line">bot = telebot.TeleBot(token)</span><br><span class="line">#将token换成你的API,API两边加上双引号(英文模式)</span><br></pre></td></tr></table></figure>

<p><strong>安装所需的第三方库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p><strong>运行机器人</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python bot.py</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 bot.py</span><br></pre></td></tr></table></figure>

<h1 id="TG搜图结果"><a href="#TG搜图结果" class="headerlink" title="TG搜图结果"></a>TG搜图结果</h1><p><a href="https://cdn.jsdelivr.net/gh/666wcy/img_share@main/img/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.6ej91xxyd1s0.png"><img src="https://cdn.jsdelivr.net/gh/666wcy/img_share@main/img/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.6ej91xxyd1s0.png" alt="img"></a></p>
<p><a href="https://cdn.jsdelivr.net/gh/666wcy/img_share@main/img/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.1nvos6yzqtmo.png"><img src="https://cdn.jsdelivr.net/gh/666wcy/img_share@main/img/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.1nvos6yzqtmo.png" alt="img"></a></p>
<p>项目灵感:<a href="https://github.com/Tsuk1ko/CQ-picfinder-robot">CQ-picfinder-robot</a></p>
<p>感谢：<a href="https://github.com/akashin/TelegramBot">TelegramBot</a></p>
]]></content>
      <tags>
        <tag>heroku</tag>
        <tag>telegram</tag>
        <tag>搜图</tag>
      </tags>
  </entry>
  <entry>
    <title>Nazurin - 基于 Telegram, Heroku, MEGA 及 Firebase 的图片收藏自动工作流</title>
    <url>/posts/49122/</url>
    <content><![CDATA[<p><a href="https://github.com/y-young/nazurin/blob/master/README.md">English</a> | <a href="https://github.com/y-young/nazurin/">Github</a></p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>对于大多数 ACG 爱好者来说，在网络上收集各种画师作品、壁纸、宣传图、插画等图片想必是一件乐此不疲的事情；然而近年来图片来源不断丰富，已从最原始的 Pixiv、Danbooru、Moebooru 类图站扩展至 Twitter、Telegram Channel、QQ 群，乃至酷安酷图（?)、网易云音乐动态（??），高效的多渠道自动收图工作流已成为必需。</p>
<p>此外，如何在多渠道来源中获取高质量的原始数据，如何管理和安全保存数据也至关重要。例如下图，Pixiv 上删除作品的情况已不再是少数，虽说仍可通过其他手段恢复，但恢复数据的成本显然高于即时归档的成本。<del>数据丢失对于收集控来说是无法忍受的痛苦，所以去中心化刻不容缓（</del></p>
<p><a href="https://blog.gpx.moe/2020/07/20/nazurin/background.jpg"><img src="https://blog.gpx.moe/2020/07/20/nazurin/background.jpg" alt="Pixiv 收藏夹中被删除的图片"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://thwiki.cc/%E5%A8%9C%E5%85%B9%E7%8E%B2">小さな小さな賢将</a>，是一个能从多种来源收集 ACG 相关插画并完成自动化工作流的 Telegram 机器人。</p>
<p>（名字并不是 TYPO，只是为了避免重名）</p>
<p><del>其实这个项目 1 月份就在做了但咕到现在才写文章</del></p>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>获取<a href="https://blog.gpx.moe/2020/07/20/nazurin/#supported-sites">多种来源</a>的图片</li>
<li>从支持的网站下载原图</li>
<li>将图片添加到收藏，完成自动化工作流</li>
<li>将图片保存在 Telegram Channel 中</li>
<li>将图片文件上传到 <a href="https://mega.co.nz/">MEGA</a> 云盘、Google Drive 或保存在本地</li>
<li>将图片的元信息（如名称、标签）保存至多种类型的数据库</li>
</ul>
<h3 id="Supported-Sites"><a href="#Supported-Sites" class="headerlink" title="Supported Sites"></a>Supported Sites</h3><table>
<thead>
<tr>
<th>名称</th>
<th>URL</th>
<th>Bot 命令</th>
<th>图片收藏功能</th>
</tr>
</thead>
<tbody><tr>
<td>Pixiv</td>
<td><a href="https://www.pixiv.net/">https://www.pixiv.net/</a></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Danbooru</td>
<td><a href="https://danbooru.donmai.us/">https://danbooru.donmai.us/</a></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Safebooru</td>
<td><a href="https://safebooru.donmai.us/">https://safebooru.donmai.us/</a></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>yandere</td>
<td><a href="https://yande.re/">https://yande.re/</a></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Konachan</td>
<td><a href="https://konachan.com/">https://konachan.com/</a></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Lolibooru</td>
<td><a href="https://lolibooru.moe/">https://lolibooru.moe/</a></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>Zerochan</td>
<td><a href="https://www.zerochan.net/">https://www.zerochan.net/</a></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Gelbooru</td>
<td><a href="https://gelbooru.com/">https://gelbooru.com/</a></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>Twitter</td>
<td><a href="https://twitter.com/">https://twitter.com/</a></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>Bilibili 动态</td>
<td><a href="https://t.bilibili.com/">https://t.bilibili.com/</a></td>
<td></td>
<td>✔</td>
</tr>
</tbody></table>
<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><ul>
<li>Pixiv：收藏 &amp; 定期使用工具批量下载收藏夹</li>
<li>Danbooru &amp; Moebooru 类图站：分别注册账号并收藏 / 直接添加书签</li>
<li>Twitter：转推 / 直接下载 / 添加书签</li>
<li>Telegram Channel：转发至私人频道</li>
</ul>
<h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>以上所有来源均分享 / 转发至 Telegram Bot，Bot 在云端完成以下工作：</p>
<ul>
<li>将原消息转发至 Gallery Channel 以便后续查看</li>
<li>在来源站收藏图片（仅 Pixiv）</li>
<li>下载“原图”，即能够获取到的最高分辨率文件</li>
<li>将原图以文件形式发送至 Album Channel 作为备份点之一</li>
<li>上传原图文件至 MEGA 云盘</li>
</ul>
<p>PS: 对于其他来源的图片如已知原始地址仍可按上述方法操作，搜图功能仍在计划中</p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><a href="https://blog.gpx.moe/2020/07/20/nazurin/architecture.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/architecture.png" alt="Architecture"></a></p>
<h3 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h3><p>项目初期设想用 Electron 构建 UI 界面，用 Python 运行后端服务器，藉此学习 Electron 和 Python 的使用，然而此架构在通讯和程序启动方面都存在一定不足；考虑到 Telegram 已成为收图的重要来源之一，且官方提供了丰富的 API 以供使用，故使用 Telegram Bot 功能、将聊天界面作为 UI 使用。</p>
<p>此外，Telegram 还提供了云端永久存储及多端同步功能，可作为原始文件的备份点之一。</p>
<p><a href="https://blog.gpx.moe/2020/07/20/nazurin/telegram1.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/telegram1.png" alt="Why Telegram"></a></p>
<h3 id="Heroku"><a href="#Heroku" class="headerlink" title="Heroku"></a>Heroku</h3><p><a href="https://blog.gpx.moe/2020/07/20/nazurin/heroku.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/heroku.png" alt="Heroku Dynos"></a></p>
<p>由于手上并没有现成的服务器，对于如此轻量的应用来说单独购买一台 VPS 又太过奢侈，于是几年前白嫖的 Heroku 平台便派上了用场。</p>
<p>Heroku 是基于容器的 PaaS 平台，在本地使用 Git 推送源码后，在云端完成构建，最终运行在一个轻量级的容器（Dyno）中。对于免费账户，Dyno 在闲置 30 分钟后会自动休眠，但受到网络请求后会自动启动，以节省资源。由于使用了 Webhook，这一特性对于本项目来说并无大碍；免费账户每个月 550 小时的运行时间也是绰绰有余。</p>
<h3 id="MEGA"><a href="#MEGA" class="headerlink" title="MEGA"></a>MEGA</h3><p><a href="https://blog.gpx.moe/2020/07/20/nazurin/mega.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/mega.png" alt="MEGA 安全性"></a></p>
<blockquote>
<p>人人的隐私与家庭、住宅、通信不得被任意干涉……。 人人有权享受法律保护，不受这种干涉或攻击……。</p>
<p><strong>世界人权宣言</strong>第十二条</p>
</blockquote>
<p>图片收藏工作流中重要的一环便是文件的归档存储，云端备份需要一定的稳定性和存储空间，此外还有安全性等多方面因素。MEGA 作为一家主打安全性的公司，采用了端对端加密设计，提供 15GB 的免费存储空间，官方虽没有提供 Python SDK，但有开源库可用。</p>
<h3 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h3><p>由于 Dyno 的自动休眠机制及 PixivPy 的自身设计，Pixiv API 无法保持登录状态，一段时间后使用机器人时都会重新登录，然而 Pixiv 的异地登录邮件提醒并不能关闭，一个月内将会产生几十封垃圾邮件；此外，Pixiv 的 Access Token 有效期仅为 1 小时，若 Bot 运行时间过长则登录凭据失效无法正常工作。</p>
<p>Pixiv 使用的是 RESTful API，为解决这些问题需要保存 Access Token 及 Refresh Token，然而 Heroku Dyno 的 <a href="https://devcenter.heroku.com/articles/dynos#ephemeral-filesystem">Ephemeral filesystem</a> 直接否决了本地数据库的方案。鉴于 Heroku 自身的数据库服务存在诸多限制，转而使用 Firebase——Google 的 BaaS 服务。</p>
<p>Cloud Firestore 是 Firebase 平台中的云托管 NoSQL 数据库服务，以集合-文档的结构存储数据，免费方案数据总量限制为 1GB，每日读取及写入次数限制均在 1 万次以上，完全满足需求。</p>
<p>连接了 Firebase 以后便可将 Pixiv 的登录凭据缓存到 Firestore 数据库中，省去了登录时间，如 Access Token 过期则使用 Refresh Token 进行更新；针对 MEGA 网盘每次登录及查找文件夹耗时过长的问题，同样使用此方法进行解决。粗略估算，此次优化过后 Bot 的冷启动响应时间可降低至原来的一半左右。</p>
<p><a href="https://blog.gpx.moe/2020/07/20/nazurin/firestore-cache.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/firestore-cache.png" alt="Firestore Cache"></a></p>
<h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><h3 id="Deploy-on-Heroku"><a href="#Deploy-on-Heroku" class="headerlink" title="Deploy on Heroku"></a>Deploy on Heroku</h3><ol>
<li>使用 ‘Deploy to Heroku’ 按钮：<a href="https://heroku.com/deploy?template=https://github.com/y-young/nazurin">Deploy to Heroku</a></li>
<li>手动部署：<br>根据根目录下和 <code>sites</code> 目录下各来源站点的 <code>config.py</code> 文件，在 Heroku 后台设置所需的环境变量，克隆 <a href="https://github.com/y-young/nazurin">Git 仓库</a> 并 push 到 Heroku 即可开始使用，关于 Heroku 的使用见 <a href="https://devcenter.heroku.com/articles/git">官方文档</a>。</li>
</ol>
<h3 id="Deploy-on-your-own-server"><a href="#Deploy-on-your-own-server" class="headerlink" title="Deploy on your own server"></a>Deploy on your own server</h3><blockquote>
<p>Tips: 安装之前可在 <code>requirements.txt</code> 中注释掉不用的依赖</p>
</blockquote>
<ol>
<li>安装所有依赖：<code>pip install -r requirements.txt</code></li>
<li>设置所需的环境变量，或手动修改 <code>config.py</code></li>
<li>启动：<code>python bot.py</code></li>
</ol>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><ul>
<li><p><code>ENV</code></p>
<p>默认为 <code>production</code>，使用 Webhook；开发环境可设置为 <code>production</code> 以使用轮询模式</p>
</li>
<li><p><code>TOKEN</code></p>
<p>Telegram Bot 的 API token，可通过 <a href="https://t.me/BotFather">@BotFather</a> 获取</p>
</li>
<li><p><code>WEBHOOK_URL</code></p>
<p>提交给 Telegram 服务器的 Webhook URL，详见 <a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki/Webhooks">python-telegram-bot 的文档</a></p>
</li>
<li><p><code>PORT</code></p>
<p>Webhook 端口，如果部署在 Heroku 上则无需手动设置</p>
</li>
<li><p><code>STORAGE</code></p>
<p>字符串，由 <code>eval</code> 转换为 list</p>
<p>使用的存储方式，默认为 <code>[]</code>，即仅使用 <code>DOWNLOAD_DIR</code> 作为本地存储。设置为 <code>[&#39;Mega&#39;]</code> 以使用 MEGA。</p>
<p>可通过在 <code>storage</code> 下创建一个文件来实现其他存储方式，文件中的对象必须有一个名为 <code>store</code> 的成员函数。</p>
</li>
<li><p><code>DOWNLOAD_DIR</code></p>
<p>本地目录，用于存放下载的原图，如果不存在将自动创建</p>
</li>
<li><p><code>STORAGE_DIR</code></p>
<p>归档存储目录，如 MEGA 云盘的远程目录，原图将被存储到这里，如果不存在将自动创建</p>
</li>
<li><p><code>ALBUM_ID</code></p>
<p>用于存放原图<strong>文件</strong>的 Telegram Channel ID</p>
</li>
<li><p><code>GALLERY_ID</code></p>
<p>用于存放转发消息的 Telegram Channel ID，发送给 Bot 的消息中如果带有可被识别的图站链接，则视作图片收藏请求，消息将会被转发到这个 Channel</p>
</li>
<li><p><code>ADMIN_ID</code></p>
<p>管理员的 Telegram 用户 ID（<strong>不是</strong>用户名），Bot 的所有功能仅限管理员使用</p>
<blockquote>
<p>提示：</p>
<ol>
<li>Telegram 的 User 和 Channel ID 可通过 <a href="https://t.me/getidsbot">@GetIDs Bot</a> 获取</li>
<li>需要将机器人设置为 Channel 管理员</li>
</ol>
</blockquote>
</li>
<li><p><code>DATABASE</code></p>
<p>使用的数据库，支持的数据库类型如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>驱动</th>
<th>URL</th>
<th>配置值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>TinyDB</td>
<td><a href="https://tinydb.readthedocs.io/en/stable/index.html">https://tinydb.readthedocs.io/en/stable/index.html</a></td>
<td><code>Local</code></td>
<td>默认选项</td>
</tr>
<tr>
<td>Firestore</td>
<td><a href="https://firebase.google.com/products/firestore">https://firebase.google.com/products/firestore</a></td>
<td><code>Firebase</code></td>
<td></td>
</tr>
<tr>
<td>MongoDB</td>
<td><a href="https://www.mongodb.com/">https://www.mongodb.com/</a></td>
<td><code>Mongo</code></td>
<td>支持 MongoDB Atlas</td>
</tr>
<tr>
<td>Cloudant</td>
<td><a href="https://www.ibm.com/cloud/cloudant">https://www.ibm.com/cloud/cloudant</a></td>
<td><code>Cloudant</code></td>
<td></td>
</tr>
</tbody></table>
<p>也可依照 Firebase 的例子实现自己的数据库驱动，将文件放置在 <code>database</code> 目录下，将此选项设置为数据库驱动的类名即可。</p>
<ul>
<li><p><code>GOOGLE_APPLICATION_CREDENTIALS</code></p>
<p>Firebase SDK 的登录凭据，详见 <a href="https://firebase.google.com/docs/admin/setup#initialize_the_sdk">Firebase 文档</a></p>
<p>如果部署在 Heroku 上不希望上传 <code>service-account-file.json</code>，可将文件路径以文件内容代替</p>
</li>
<li><p><code>MONGO_URI</code></p>
<p>MongoDB <a href="https://docs.mongodb.com/manual/reference/connection-string/">connection string</a>，<strong>必须</strong>指定数据库。</p>
<p>eg: <code>mongodb://username:password@localhost:27017/database</code>，默认为 <code>mongodb://localhost:27017/nazurin</code>。</p>
</li>
<li><p><code>CLOUDANT_USER</code> &amp; <code>CLOUDANT_APIKEY</code> &amp; <code>CLOUDANT_DB</code></p>
<p>Cloudant 用户名、API key 和数据库名，使用 IAM 验证方式，默认数据库为 <code>nazurin</code>。</p>
</li>
<li><p><code>PIXIV_USER</code> &amp; <code>PIXIV_PASS</code></p>
<p>Pixiv 登录邮箱或用户名，以及密码（理论上如果在 Firebase 中已存有 Access Token 和 Refresh Token，删去此条配置也能正常工作）</p>
</li>
<li><p><code>MEGA_USER</code> &amp; <code>MEGA_PASS</code></p>
<p>MEGA 登录邮箱及密码（备注同上）</p>
</li>
</ul>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p><a href="https://blog.gpx.moe/2020/07/20/nazurin/commands.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/commands.png" alt="可用命令"></a></p>
<ul>
<li><code>/pixiv &lt;id&gt;</code> - 浏览 Pixiv 画作</li>
<li><code>/pixiv_download &lt;id&gt;</code> - 下载 Pixiv 画作</li>
<li><code>/danbooru &lt;id&gt;</code> - 浏览 Danbooru Post</li>
<li><code>/danbooru_download &lt;id&gt;</code> - 下载 Danbooru Post</li>
<li><code>/yandere &lt;id&gt;</code> - 浏览 Yandere Post</li>
<li><code>/yandere_download &lt;id&gt;</code> - 下载 Yandere Post</li>
<li><code>/konachan &lt;id&gt;</code> - 浏览 Konachan Post</li>
<li><code>/konachan_download &lt;id&gt;</code> - 下载 Konachan Post</li>
<li><code>/zerochan &lt;id&gt;</code> - 浏览 Zerochan Post</li>
<li><code>/zerochan_download &lt;id&gt;</code> - 下载 Zerochan Post</li>
<li><code>/bookmark &lt;id&gt;</code> - 收藏 Pixiv 画作</li>
</ul>
<h3 id="Collection-Update"><a href="#Collection-Update" class="headerlink" title="Collection Update"></a>Collection Update</h3><p><a href="https://blog.gpx.moe/2020/07/20/nazurin/gallery-update.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/gallery-update.png" alt="启动图片收藏自动工作流"></a></p>
<p>向 Bot 发送或转发一条带有 <a href="https://blog.gpx.moe/2020/07/20/nazurin/#supported-sites">支持的网站</a> 链接的消息（一条消息暂时只能处理一条链接），此后这条消息将会被转发至 <code>GALLERY</code> Channel，随后 Bot 将从图片来源站点下载最清晰的原图文件并发送至 <code>ALBUM</code> Channel，最后文件会被上传至 MEGA 云盘作为备份。</p>
<blockquote>
<p>Tips: 在手机上操作时可使用“分享”按钮，最后生成的分享信息带有链接即可。</p>
</blockquote>
<h3 id="MEGA-Encoding-Issues"><a href="#MEGA-Encoding-Issues" class="headerlink" title="MEGA Encoding Issues"></a>MEGA Encoding Issues</h3><p>猜测由于 Mega.py 的 API 方式和官方 SDK 略有不同，因此有时会出现编码问题，具体表现为文件名带有特殊字符时在 Android 和 iOS 客户端显示异常（如出现乱码或显示为 <code>BLANK</code>），且 MEGASync 无法同步该文件，但网页端显示正常，解决方法为：</p>
<ol>
<li>新建一个临时文件夹</li>
<li>设置该临时文件夹为 <code>STORAGE_DIR</code></li>
<li>定期登录 <strong>MEGA 网页端</strong>，将临时文件夹中的文件<strong>复制</strong>到目标文件夹完成归档</li>
</ol>
<p>（其实不定期登录也行，只在需要同步文件时操作一遍即可，注意不能使用“移动”操作）</p>
<blockquote>
<p>当然也可在源码中修改文件名格式，如设置为 pid 则无此问题</p>
</blockquote>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>优点：</p>
<ul>
<li><del>完全白嫖</del>完全使用免费 SaaS, PaaS 和 BaaS 服务，零成本</li>
<li>Telegram, Heroku, Firebase, MEGA 以及图片来源站点之间的网络连接稳定，不受用户本地网络影响</li>
</ul>
<p>个人中度使用体验：</p>
<p><del>总之就是很爽、非常爽</del></p>
<p>执行命令的响应时间较短，图片收藏的平均冷启动响应时间（从发送链接到 Bot 执行完成返回）约为 20 秒，Bot 在线时平均响应时间为 10 秒；支持同时处理多个请求，但 Heroku 对线程数量有一定限制；大文件的处理与 Pixiv 下载与 MEGA 上传速度有关，如执行时间过长会被 Heroku 中断，20MB 以下的文件基本无问题；</p>
<p>各类云服务使用情况：</p>
<p>Heroku 每个月的 Dyno Usage 从未超过 100 小时，基本在 40 小时左右</p>
<p><a href="https://blog.gpx.moe/2020/07/20/nazurin/heroku-usage.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/heroku-usage.png" alt="Heroku Dyno Hours 使用情况"></a></p>
<p>Firebase 更是不用说了，Google 给的免费配额实在慷慨，后期考虑把图片收藏信息也同步过去</p>
<p><a href="https://blog.gpx.moe/2020/07/20/nazurin/firestore-usage.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/firestore-usage.png" alt="Firestore 使用情况"></a></p>
<p>云盘的使用情况会因人而异，就算 MEGA 的 15GB 不够用也可以自己扩展其他存储方式，当然直接把 <code>DOWLOAD_DIR</code> 用作本地存储也没问题。</p>
<p>如下图所示，<code>STORAGE_DIR</code> 设置为 <code>Pictures</code>，<code>pics</code> 为总归档文件夹，<code>buffer</code> 为临时缓冲区，主要是方便检查；操作时先将 <code>Pictures</code> 文件夹内所有内容复制到 <code>buffer</code>，用 Android 客户端查看无误后移动至 <code>pics</code>，可以确保万无一失。</p>
<p><code>pics</code> 文件夹中大约有 3GB 文件是原先用 Pixiv 批量下载工具手动同步，其余均为自动工作流上传产生：</p>
<p><a href="https://blog.gpx.moe/2020/07/20/nazurin/mega-usage.png"><img src="https://blog.gpx.moe/2020/07/20/nazurin/mega-usage.png" alt="MEGA 使用情况"></a></p>
<h2 id="Issues-amp-Roadmap"><a href="#Issues-amp-Roadmap" class="headerlink" title="Issues &amp; Roadmap"></a>Issues &amp; Roadmap</h2><p>秉承开源精神，本项目现以 MIT 协议在 Github 开源，但仍有诸多不足之处：</p>
<ul>
<li>在桌面端的使用较为不便，未来可能考虑写个 Chrome 插件解决</li>
<li>可灵活配置的选项较少</li>
<li><del>图站 API 与 Bot 耦合过于紧密，正在构建一个插件系统来解耦</del>（已完成）</li>
<li><del>支持的存储方式和数据库类型较少（估计得引入插件系统才方便开发）</del>（插件系统已完成）</li>
<li>网络请求错误的处理还不够完善</li>
<li>考虑集成<del>智能</del>以图搜图功能</li>
<li><del>添加对 Pixiv 动图的支持</del>（已完成）</li>
<li>添加对 Pool 的支持</li>
</ul>
<p>总而言之，<strong>PR is welcome</strong></p>
<h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><ul>
<li><a href="https://telegram.org/">Telegram</a></li>
<li><a href="https://www.heroku.com/">Heroku</a></li>
<li><a href="https://mega.co.nz/">MEGA</a></li>
<li><a href="https://firebase.google.com/">Firebase</a></li>
<li><a href="https://github.com/python-telegram-bot/python-telegram-bot/">python-telegram-bot</a></li>
<li><a href="https://github.com/upbit/pixivpy">PixivPy</a></li>
<li><a href="https://github.com/odwyersoftware/mega.py">Mega.py</a></li>
<li><a href="https://github.com/LuqueDaniel/pybooru">Pybooru</a></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://core.telegram.org/bots/api">Telegram Bot API</a></li>
<li><a href="https://www.heroku.com/pricing">Pricing | Heroku</a></li>
<li><a href="https://devcenter.heroku.com/articles/dynos">Dynos and the Dyno Manager - Heroku Dev Center</a></li>
<li><a href="https://firebase.google.com/pricing">Firebase Pricing</a></li>
<li><a href="https://firebase.google.com/docs/firestore">Cloud Firestore | Firebase</a></li>
<li><a href="https://github.com/python-telegram-bot/python-telegram-bot/wiki">python-telegram-bot Wiki</a></li>
</ol>
]]></content>
      <tags>
        <tag>heroku</tag>
        <tag>telegram</tag>
        <tag>图片收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔下修改PHP参数，解决WordPress 占用内存不断上升的问题</title>
    <url>/posts/19914/</url>
    <content><![CDATA[<h2 id="调整PHP"><a href="#调整PHP" class="headerlink" title="调整PHP"></a>调整PHP</h2><h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><p>找到配置修改，然后把<code>max_execution_time</code>（最大脚本运行时间）这个值改低一些，默认是300，要根据自己的服务器配置来修改，改成60或者80左右，或者更低一些，多少合适你自己测试一下。</p>
<h3 id="性能调整"><a href="#性能调整" class="headerlink" title="性能调整"></a>性能调整</h3><p>找到性能调整选项，修改相应参数。</p>
<ul>
<li>max_children 允许创建的最大子进程数</li>
<li>start_servers 起始进程数（服务启动后初始进程数量）</li>
<li>min_spare_servers 最小空闲进程数（清理空闲进程后的保留数量）</li>
<li>max_spare_servers 最大空闲进程数（当空闲进程达到此值时清理）</li>
</ul>
<p>将这几个值改为如图所示：</p>
<p><a href="https://i.loli.net/2019/08/13/etjrD4JXY7So1ih.png"><img src="https://i.loli.net/2019/08/13/etjrD4JXY7So1ih.png" alt="img"></a></p>
<p>保存，重启PHP服务。</p>
<h2 id="增加Swap-虚拟内存"><a href="#增加Swap-虚拟内存" class="headerlink" title="增加Swap/虚拟内存"></a>增加Swap/虚拟内存</h2><p>增加Linux服务器的Swap/虚拟内存。</p>
<p>swap是Linux下的虚拟内存，设置适当的swap可增加服务器稳定性</p>
<p>建议swap容量在真实内存容量的1.5倍左右，若您的服务器内存大于4GB，可设1-2GB的固定值</p>
<p>swap文件默认保存在/www/swap，设置前请确保磁盘空间够用</p>
<p>若您不需要swap，请将容量设为0</p>
<p>OVZ虚拟架构机器不可用此功能</p>
<p>像我的vps内存才512 MB，我就把Swap设置为了512 MB，其实应该设置为1024 MB的，我的磁盘也不大，可能512也够了，不够再调。</p>
<p><a href="https://i.loli.net/2019/08/13/gOef9RcKTbdSJm2.png"><img src="https://i.loli.net/2019/08/13/gOef9RcKTbdSJm2.png" alt="img"></a></p>
]]></content>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>创建自己的随机图片api</title>
    <url>/posts/10250/</url>
    <content><![CDATA[<p>网上有很多共享随机图片api，但是有一些图又不是自己喜欢的，所以最近搭建了自己的图片api接口，自己的东西才是快乐对吧嘿嘿。</p>
<h2 id="创建图片链接"><a href="#创建图片链接" class="headerlink" title="创建图片链接"></a>创建图片链接</h2><p>上传生成方法很多，这里以利用picGo为例，也可以利用图床批量生产图片url<br>先利用picgo上传图片，然后在相册中可以全部选中并复制图片url。</p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/2.png"></p>
<p>随后新建一个img.txt(<strong>与php文件名同步</strong>）粘贴所有链接</p>
<h2 id="创建php文件"><a href="#创建php文件" class="headerlink" title="创建php文件"></a>创建php文件</h2><p>利用php搭建一个可以随机返回图片的api<br>首先要，在创建一个*.php文件</p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/3.png"></p>
<p>然后代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//存有美图链接的文件名img.txt</span><br><span class="line">$filename = &quot;img.txt&quot;;</span><br><span class="line">if(!file_exists($filename))&#123;</span><br><span class="line">    die(&#x27;文件不存在&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//从文本获取链接</span><br><span class="line">$pics = [];</span><br><span class="line">$fs = fopen($filename, &quot;r&quot;);</span><br><span class="line">while(!feof($fs))&#123;</span><br><span class="line">    $line=trim(fgets($fs));</span><br><span class="line">    if($line!=&#x27;&#x27;)&#123;</span><br><span class="line">        array_push($pics, $line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//从数组随机获取链接</span><br><span class="line">$pic = $pics[array_rand($pics)];</span><br><span class="line"> </span><br><span class="line">//返回指定格式</span><br><span class="line">$type=$_GET[&#x27;type&#x27;];</span><br><span class="line">switch($type)&#123;</span><br><span class="line"> </span><br><span class="line">//JSON返回</span><br><span class="line">case &#x27;json&#x27;:</span><br><span class="line">    header(&#x27;Content-type:text/json&#x27;);</span><br><span class="line">    die(json_encode([&#x27;pic&#x27;=&gt;$pic]));</span><br><span class="line"> </span><br><span class="line">default:</span><br><span class="line">    die(header(&quot;Location: $pic&quot;));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>复制上述代码，到php保存，记得对应填写txt文件名地方要修改，随后保存即可</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>网站记得要开启php功能。<br>上传到网站，txt和php文件要放在一起随后，<strong>访问php文件</strong>即可返回图片的url</p>
<p>例如 <a href="https://api.oldming.top/api/img.php">https://api.oldming.top/api/img.php</a></p>
<p>是不是很简单的方法，几分钟就可以完成大量的图片。</p>
<p>以下也分享几个api<br>漫图：<a href="https://api.haibara.cn/erciyuan/index.php">https://api.haibara.cn/erciyuan/index.php</a><br><a href="https://api.oldming.top/api/pic.php">https://api.oldming.top/api/pic.php</a><br>风景：<a href="https://api.haibara.cn/fengjing/index.php">https://api.haibara.cn/fengjing/index.php</a><br>动漫风景：<a href="https://api.haibara.cn/fengjing3/index.php">https://api.haibara.cn/fengjing3/index.php</a></p>
]]></content>
      <tags>
        <tag>随机图片</tag>
      </tags>
  </entry>
  <entry>
    <title>通过okteto搭建无服务器Cloudreve云端网盘</title>
    <url>/posts/12811/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>serverless Cloudreve service on okteto</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://hostloc.com/thread-844369-1-1.html">https://hostloc.com/thread-844369-1-1.html</a></li>
</ul>
<p><img src="https://cdn.1024.ee/wp-content/uploads/2021/05/mini_-2021-05-20-at-10.56.23-1280x649.png" alt="img"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>到 <a href="https://cloud.okteto.com/">https://cloud.okteto.com/</a> 通过github账号直接登陆，点击”Deploy”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">    cloudreve:</span><br><span class="line">        public: true</span><br><span class="line">        container_name: dreve</span><br><span class="line">        image: jialezi/cloudreve</span><br><span class="line">        ports:</span><br><span class="line">            - 5212:5212</span><br><span class="line">        volumes: </span><br><span class="line">            - /root/cloudreve</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.23.03.png" alt="img"></p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.30.10-1536x572.png" alt="img"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>用上图生成的”Endpoints”打开，并用初始管理员账号和密码登陆之后，加载OneDrive</strong></p>
<ul>
<li><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-20-at-11.04.25.png" alt="img"></li>
</ul>
<h2 id="加载OneDrive"><a href="#加载OneDrive" class="headerlink" title="加载OneDrive"></a>加载OneDrive</h2><ul>
<li><img src="https://cdn.1024.ee/wp-content/uploads/2021/05/mini_-2021-05-19-at-08.44.48-1280x966.png" alt="img"></li>
<li><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.39.04.png" alt="img"></li>
<li><img src="https://cdn.1024.ee/wp-content/uploads/2021/05/mini_-2021-05-19-at-08.40.27-1280x912.png" alt="img"></li>
<li><img src="https://cdn.1024.ee/wp-content/uploads/2021/05/mini_-2021-05-19-at-08.41.49-1280x823.png" alt="img"></li>
<li><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.58.09-1536x789.png" alt="img"></li>
</ul>
<p>上传之后，也可以在OneDrive自己的目录中看到</p>
<ul>
<li><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.53.48.png" alt="img"></li>
<li><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.54.08-1536x485.png" alt="img"></li>
</ul>
<h4 id="修改默认的存储地点，不然默认是本地存储"><a href="#修改默认的存储地点，不然默认是本地存储" class="headerlink" title="修改默认的存储地点，不然默认是本地存储"></a>修改默认的存储地点，不然默认是本地存储</h4><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.46.13.png" alt="img"></p>
<h4 id="打开WebDav访问"><a href="#打开WebDav访问" class="headerlink" title="打开WebDav访问"></a>打开WebDav访问</h4><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-08.58.02-1536x553.png" alt="img"></p>
<h2 id="需要加网页自动监测，不然15天没访问就被回收了"><a href="#需要加网页自动监测，不然15天没访问就被回收了" class="headerlink" title="需要加网页自动监测，不然15天没访问就被回收了"></a>需要加网页自动监测，不然15天没访问就被回收了</h2><p>用<a href="https://uptimerobot.com/">uptimerobot</a></p>
<ul>
<li><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/mini_-2021-05-19-at-09.07.57-1536x938.png" alt="img"></li>
</ul>
]]></content>
      <tags>
        <tag>免费</tag>
        <tag>目录程序</tag>
        <tag>Okteto</tag>
      </tags>
  </entry>
  <entry>
    <title>使用okteto搭建wordpress博客</title>
    <url>/posts/11812/</url>
    <content><![CDATA[<h2 id="登录okteto"><a href="#登录okteto" class="headerlink" title="登录okteto"></a>登录okteto</h2><h3 id="okteto地址：https-cloud-okteto-com"><a href="#okteto地址：https-cloud-okteto-com" class="headerlink" title="okteto地址：https://cloud.okteto.com"></a>okteto地址：<a href="https://cloud.okteto.com/">https://cloud.okteto.com</a></h3><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628067481637.png"></p>
<h3 id="使用GitHub登录"><a href="#使用GitHub登录" class="headerlink" title="使用GitHub登录"></a>使用GitHub登录</h3><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628067670224.png"></p>
<h2 id="部署word-press"><a href="#部署word-press" class="headerlink" title="部署word press"></a>部署word press</h2><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628067726830.png"><br><a href="https://cloudrevedgm-1300311678.cos.ap-chengdu.myqcloud.com//halo/image_1628067756055.png"><img src="https://cloudrevedgm-1300311678.cos.ap-chengdu.myqcloud.com//halo/image_1628067756055.png" alt="image.png"></a><br><strong>再②处填写以下</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">db:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">       <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">   <span class="attr">wordpress:</span></span><br><span class="line">     <span class="attr">depends_on:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8000:80&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="attr">db_data:</span> &#123;&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628067881857.png"><br><strong>如下图所示,即为安装成功</strong><br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628068006965.png"><br><strong>下图箭头所指的为博客地址，点击进入配置博客</strong><br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628068059654.png"></p>
<h2 id="配置word-press"><a href="#配置word-press" class="headerlink" title="配置word press"></a>配置word press</h2><h3 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h3><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628068211898.png"></p>
<h3 id="配置基本信息"><a href="#配置基本信息" class="headerlink" title="配置基本信息"></a>配置基本信息</h3><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628068373007.png"></p>
<h3 id="出现以下界面便表示搭建成功了"><a href="#出现以下界面便表示搭建成功了" class="headerlink" title="出现以下界面便表示搭建成功了"></a>出现以下界面便表示搭建成功了</h3><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628068434504.png"></p>
<h2 id="开启你的word-press之旅吧！"><a href="#开启你的word-press之旅吧！" class="headerlink" title="开启你的word press之旅吧！"></a>开启你的word press之旅吧！</h2><p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/image_1628068505237.png"></p>
]]></content>
      <tags>
        <tag>wordpress</tag>
        <tag>Okteto</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 CloudFlare Workers 搭建 telegram 频道镜像站</title>
    <url>/posts/21874/</url>
    <content><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li>2020-04-21：推荐食用 <a href="https://github.com/idealclover/Telegram-Channel-Mirror">Telegram-Channel-Mirror</a> 进行反代 telegram 频道</li>
</ul>
<h2 id="劝退三一连"><a href="#劝退三一连" class="headerlink" title="劝退三一连"></a>劝退<del>三</del>一连</h2><p>首先你要有个 Cloudflare 账户，这是必须的。关于 Cloudflare 的注册咱就不多说啦，不过咱倒是建议大家伙把域名的 DNS 解析放到 Cloudflare 上来，好处多多：有把 https 小绿锁、免费的 <del>加速</del> 减速 CDN （墙内）、域名访问统计等等可玩性比较高😋。需要注意的是 Cloudflare 的 Worker 一天 10 万次免费额度，也够咱喝一壶的啦，不用担心不够用。</p>
<h2 id="新建-Worker"><a href="#新建-Worker" class="headerlink" title="新建 Worker"></a>新建 Worker</h2><p>登录到 <a href="https://dash.cloudflare.com/">Cloudflare</a>的<del>大盘</del>面板，点击左上角的 <code>Menu</code> —-&gt; <code>Workers</code> 进入到 Workers 页面。新注册的用户会提示设置一个 <code>workers.dev</code> 顶级域名下的二级子域名，这个子域名设置好之后是不可更改的，之后你新创建的 Worker 就会使以这个域名而二级子域名开始的，类似于 <code>WorkerName.yousetdomain.workers.dev</code> 。<code>yousetdomain</code> 就是你要设置的二级子域名，<code>WorkerName</code> 可以自定义，默认是随机生成的。也可以给自己的域名添加一条 CNAME 到 <code>WorkerName.yousetdomain.workers.dev</code> ，这样使用自己的域名就可以访问到 <code>Worker</code> 了。</p>
<p>设置好二级子域名之后选择 free 套餐计划，然后进入到 Worker 管理界面，创建一个新的 <code>Worker</code> 然后在 <code>Script</code> 输入框里填入以下代码。<strong>俗话说代码写得好，同行抄到老</strong>，咱的 <code>worker.js</code> 代码是参考自 <a href="https://github.com/Siujoeng-Lau/Workers-Proxy">Workers-Proxy</a> ，不过咱去掉了一些无关紧要的代码，原代码是加入了辨别移动设备适配域名、屏蔽某些 IP 和国家的功能。对于咱的 telegram 频道镜像站来说，这都是多余的，于是就去掉了。</p>
<p><img src="https://p.k8s.li/20200326184802562.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Website you intended to retrieve for users.</span><br><span class="line">const upstream_me = &#x27;t.me&#x27;;</span><br><span class="line">const upstream_org = &#x27;telegram.org&#x27;;</span><br><span class="line"></span><br><span class="line">// Custom pathname for the upstream website.</span><br><span class="line">const upstream_path = &#x27;/s/rss_kubernetes&#x27;;</span><br><span class="line"></span><br><span class="line">// Whether to use HTTPS protocol for upstream address.</span><br><span class="line">const https = true;</span><br><span class="line"></span><br><span class="line">// Replace texts.</span><br><span class="line">const replace_dict = &#123;</span><br><span class="line">  $upstream: &#x27;$custom_domain&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addEventListener(&#x27;fetch&#x27;, event =&gt; &#123;</span><br><span class="line">  event.respondWith(fetchAndApply(event.request));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">async function fetchAndApply(request) &#123;</span><br><span class="line">  let response = null;</span><br><span class="line">  let url = new URL(request.url);</span><br><span class="line">  let url_hostname = url.hostname;</span><br><span class="line"></span><br><span class="line">  if (https == true) &#123;</span><br><span class="line">    url.protocol = &#x27;https:&#x27;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    url.protocol = &#x27;http:&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var upstream_domain = upstream_me;</span><br><span class="line"></span><br><span class="line">  // Check telegram.org</span><br><span class="line">  let pathname = url.pathname;</span><br><span class="line">  console.log(pathname);</span><br><span class="line">  if (pathname.startsWith(&#x27;/static&#x27;)) &#123;</span><br><span class="line">    console.log(&#x27;here&#x27;);</span><br><span class="line">    upstream_domain = upstream_org;</span><br><span class="line">    url.pathname = pathname.replace(&#x27;/static&#x27;, &#x27;&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (pathname == &#x27;/&#x27;) &#123;</span><br><span class="line">      url.pathname = upstream_path;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      url.pathname = upstream_path + url.pathname;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  url.host = upstream_domain;</span><br><span class="line"></span><br><span class="line">  let method = request.method;</span><br><span class="line">  let request_headers = request.headers;</span><br><span class="line">  let new_request_headers = new Headers(request_headers);</span><br><span class="line"></span><br><span class="line">  new_request_headers.set(&#x27;Host&#x27;, url.hostname);</span><br><span class="line">  new_request_headers.set(&#x27;Referer&#x27;, url.hostname);</span><br><span class="line"></span><br><span class="line">  let original_response = await fetch(url.href, &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    headers: new_request_headers</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  let response_headers = original_response.headers;</span><br><span class="line">  let status = original_response.status;</span><br><span class="line"></span><br><span class="line">  response = new Response(original_response.body, &#123;</span><br><span class="line">    status,</span><br><span class="line">    headers: response_headers</span><br><span class="line">  &#125;);</span><br><span class="line">  let text = await response.text();</span><br><span class="line"></span><br><span class="line">  // Modify it.</span><br><span class="line">  let modified = text.replace(</span><br><span class="line">    /telegram.org/g, &#x27;tg.k8s.li/static&#x27;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // Return modified response.</span><br><span class="line">  return new Response(modified, &#123;</span><br><span class="line">    status: response.status,</span><br><span class="line">    statusText: response.statusText,</span><br><span class="line">    headers: response.headers</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，像 <code>t.me</code> 域名下的站点，比如我的 <code>https://t.me/s/rss_kubernetes</code> ，它的 js 和 css 样式文件是使用的 telegram.org 域名。<del>所以我们需要在 <code>replace_dict</code> 那里定义好替换的正则表达式，</del>将 <code>https://t.me/s/rss_kubernetes</code>页面里的 <code>telegram.org</code> 同样进行反代才行，这需要为 telegram 建一个单独的 Worker 😑。这也是评论区 <a href="https://ichr.me/">ChrAlpha</a> 小伙伴提到的办法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu@blog:~$ curl https://t.me/s/rss_kubernetes | grep &quot;&lt;script src=&quot;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  141k  100  141k    0     0  85287      0  0:00:01  0:00:01 --:--:-- 85237</span><br><span class="line">    &lt;script src=&quot;//telegram.org/js/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//telegram.org/js/jquery-ui.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//telegram.org/js/widget-frame.js?29&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//telegram.org/js/telegram-web.js?8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>修改下处代码为，将<code>https://t.me/s/rss_kubernetes</code>页面里的 <code>telegram.org</code> 同样进行一次反代。这样访问到 <code>https://t.me/s/rss_kubernetes</code>页面时，把的 telegram.org 替换为另一个 Worker 的域名，比如我的 <code>telegram.k8srss.workers.dev</code> 。不过像频道里的图片、文件、视频等资源 telegram 是使用的 CDN ，而且有好几个域名……这点很僵硬，暂时找不到合适的办法。貌似一个 Worker 只能反代一个域名？如果汝有合适的办法，欢迎与咱交流，咱感激不尽😋</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let modified = text.replace(/telegram.org/g, &quot;telegram.k8srss.workers.dev&quot;)</span><br></pre></td></tr></table></figure>

<p>这样再使用 curl 访问测试一下，原来的 telegram.org 已经全部替换成 telegram.k8srss.workers.dev 了😂。现在墙内用户也可以无痛访问啦。在此感谢 <a href="https://ichr.me/">ChrAlpha</a> 小伙伴😂提出宝贵的建议。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/main&gt;</span><br><span class="line">    &lt;script src=&quot;//telegram.k8srss.workers.dev/js/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//telegram.k8srss.workers.dev/js/jquery-ui.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;//telegram.k8srss.workers.dev/js/widget-frame.js?29&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//telegram.k8srss.workers.dev/js/telegram-web.js?8&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- page generated in 121.26ms --&gt;</span><br></pre></td></tr></table></figure>

<p>这个文本替换功能很好玩儿，在 Cloudflare 官方的博客里还有个 demo <a href="https://cloudflareworkers.com/#c62c6c0002cb236166b794c440870cca:https://blog.cloudflare.com/introducing-cloudflare-workers">introducing-cloudflare-workers</a> 。使用这个功能咱有解锁了一个玩具，稍后再讲😂。</p>
<blockquote>
<p>Here is a worker which performs a site-wide search-and-replace, replacing the word “Worker” with “Minion”. <a href="https://cloudflareworkers.com/#c62c6c0002cb236166b794c440870cca:https://blog.cloudflare.com/introducing-cloudflare-workers">Try it out on this blog post.</a></p>
</blockquote>
<p><del>剽窃</del>修改好代码之后点击左下角的 <code>Save and Deploy</code> 然后 Preview 看看页面是否显示正常，如果显示正常恭喜你成功啦。</p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/20200326184802562.webp" alt="img"></p>
<p>如果你想使用这种办法反代其他频道，只需要把 <code>const upstream_path = &#39;/s/rss_kubernetes&#39;</code> 后的 rss_kubernetes 替换为你想要代理的 telegram 频道 username 即可。之所以加上 <code>upstream_path</code> 而不反代整个 <code>t.me</code> 是为了防止别人滥用，毕竟 10W 次不经薅😂</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>周四晚上睡觉前在推特上发了个推文，向大家请教了一下之前一个 Worker 里只能反代一个域名的问题。第二天 <a href="https://twitter.com/Echowxsy">@Echowxsy</a> 就回复咱了，而且还特意注册了 CouldFare 账号使用 Workers 帮咱测试了一下。在此非常感谢 <a href="https://twitter.com/Echowxsy">@Echowxsy</a> 帮咱。按照 <a href="https://twitter.com/Echowxsy">@Echowxsy</a> 小伙伴所说的：</p>
<blockquote>
<p>我没用过 CloudFlare，不过我看了一下你的blog，貌似可以用两个upstream实现这个功能。 在modified那里替换为当前worker的地址，然后在后面加上一个不会重复的路径，例如xxx。 然后在fetchAndApply里面判断，如果当前请求的pathname=/xxx，使用upstream2，否则使用upstream1。 理论上是可以实现的。</p>
<p>就是一个 Workers 可以做很多事情，他实际上就是 Node.js 代码。 然后这里是将 <a href="https://t.co/wTGzY4U6sD?amp=1">http://telegram.org/xxxx</a> 映射到 <a href="https://t.co/yQwEY2mzCP?amp=1">http://tg.k8s.li/static/xxxx</a> 。 然后在 Workers 里面判断，如果有 <code>/static</code> 则从 <a href="https://t.co/VYm4zCfwPr?amp=1">http://telegram.org</a> 获取，否则从 <a href="https://t.co/N4Ahg0VLN1?amp=1">http://t.me</a> 获取。</p>
</blockquote>
<p><code>此处引用</code> <a href="https://twitter.com/Echowxsy">@Echowxsy</a> 的 <a href="https://twitter.com/Echowxsy/status/1243407321989967874">推文</a></p>
<p>Woerker 首先我们获取完要反代的 <code>https://t.me/s/rss_kubernetes</code> 页面 html 源码，然后使用 replace 函数把 telegram.org 以及cdn[1-5].telesco.pe 等域名进行替换，替换为 /static 、/cdn[1-5] 等不同的 url 路径。然后将修改后的 html 页面返回给客户端。客户端客户端在请求 <code>/static</code> 时 Worker 就会去 <a href="https://t.co/VYm4zCfwPr?amp=1">http://telegram.org</a> 获取相应的资源返回给用户。这样就实现了一个 Worker 反代多个域名骚操作。修改后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const upstream_me = &#x27;t.me&#x27;;</span><br><span class="line">const upstream_org = &#x27;telegram.org&#x27;;</span><br><span class="line"></span><br><span class="line">// Custom pathname for the upstream website.</span><br><span class="line">const upstream_path = &#x27;/s/rss_kubernetes&#x27;;</span><br><span class="line"></span><br><span class="line">// Whether to use HTTPS protocol for upstream address.</span><br><span class="line">const https = true;</span><br><span class="line"></span><br><span class="line">// Replace texts.</span><br><span class="line">const replace_dict = &#123;</span><br><span class="line">  $upstream: &#x27;$custom_domain&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addEventListener(&#x27;fetch&#x27;, event =&gt; &#123;</span><br><span class="line">  event.respondWith(fetchAndApply(event.request));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">async function fetchAndApply(request) &#123;</span><br><span class="line">  let response = null;</span><br><span class="line">  let url = new URL(request.url);</span><br><span class="line">  let url_hostname = url.hostname;</span><br><span class="line"></span><br><span class="line">  if (https == true) &#123;</span><br><span class="line">    url.protocol = &#x27;https:&#x27;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    url.protocol = &#x27;http:&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var upstream_domain = upstream_me;</span><br><span class="line"></span><br><span class="line">  // Check telegram.org</span><br><span class="line">  let pathname = url.pathname;</span><br><span class="line">  console.log(pathname);</span><br><span class="line">  if (pathname.startsWith(&#x27;/static&#x27;)) &#123;</span><br><span class="line">    console.log(&#x27;here&#x27;);</span><br><span class="line">    upstream_domain = upstream_org;</span><br><span class="line">    url.pathname = pathname.replace(&#x27;/static&#x27;, &#x27;&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (pathname == &#x27;/&#x27;) &#123;</span><br><span class="line">      url.pathname = upstream_path;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      url.pathname = upstream_path + url.pathname;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  url.host = upstream_domain;</span><br><span class="line"></span><br><span class="line">  let method = request.method;</span><br><span class="line">  let request_headers = request.headers;</span><br><span class="line">  let new_request_headers = new Headers(request_headers);</span><br><span class="line"></span><br><span class="line">  new_request_headers.set(&#x27;Host&#x27;, url.hostname);</span><br><span class="line">  new_request_headers.set(&#x27;Referer&#x27;, url.hostname);</span><br><span class="line"></span><br><span class="line">  let original_response = await fetch(url.href, &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    headers: new_request_headers</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  let original_response_clone = original_response.clone();</span><br><span class="line">  let response_headers = original_response.headers;</span><br><span class="line">  let new_response_headers = new Headers(response_headers);</span><br><span class="line">  let status = original_response.status;</span><br><span class="line"></span><br><span class="line">  response = new Response(original_response_clone.body, &#123;</span><br><span class="line">    status,</span><br><span class="line">    headers: new_response_headers</span><br><span class="line">  &#125;);</span><br><span class="line">  let text = await response.text();</span><br><span class="line"></span><br><span class="line">  // Modify it.</span><br><span class="line">  let modified = text.replace(/telegram.org/g,&#x27;tg.k8s.li/static&#x27;);</span><br><span class="line"></span><br><span class="line">  // Return modified response.</span><br><span class="line">  return new Response(modified, &#123;</span><br><span class="line">    status: response.status,</span><br><span class="line">    statusText: response.statusText,</span><br><span class="line">    headers: response.headers</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>回到 Workers 的管理页面，点击 <code>rename</code> 即可修改 Worker 的三级子域名。不过咱还是不太喜欢 <code>WorkerName.yousetdomain.workers.dev</code> 这么长的域名，想使用咱自己的二级子域名访问。</p>
<p>首先回到域名管理的页面，进入到自己域名顶部那一栏里的 <code>Workers</code> ，在那里添加相应的路由即可。</p>
<p><img src="https://p.k8s.li/20200326191340166.png" alt="img"></p>
<p>点击 <code>Add Route</code> ，在 Route 那一栏输入好自己的域名，注意最后的 <code>/*</code> 也要加上，然后 Worker 选择刚刚创建的那个即可。接着再添加 <code>CNAME</code> 记录到自己的 <code>WorkerName.yousetdomain.workers.dev</code> ，这样就能使用自己的域名访问啦😋</p>
<p><img src="https://p.k8s.li/20200326191435923.png" alt="img"></p>
<h2 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h2><p>前文提到的文本替换功能帮咱解决了一个小问题。咱友链关注的一个博客 <a href="https://chanshiyu.com/#/">chanshiyu.com</a> 没有提供 RSS ，他是将博客内容放在 GitHub issue 上，所以只能通过 RSSHUB 来订阅 GitHub 的 issue 来获取博客的更新。但 RSSHUB 获取的是 GitHub issue 的链接而非原博客的链接，于是咱想了想就用 <code>Worker</code> 进行替换不得了。</p>
<p>通过 RSSHUB 获取到的 RSS 数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rss xmlns:atom=&quot;http://www.w3.org/2005/Atom&quot; version=&quot;2.0&quot;&gt;</span><br><span class="line">&lt;channel&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">&lt;![CDATA[ chanshiyucx/blog Issues ]]&gt;</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;link&gt;https://github.com/chanshiyucx/blog/issues&lt;/link&gt;</span><br><span class="line">&lt;atom:link href=&quot;http://rsshub.app/github/issue/chanshiyucx/blog&quot; rel=&quot;self&quot; type=&quot;application/rss+xml&quot;/&gt;</span><br><span class="line">&lt;description&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">chanshiyucx/blog Issues - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/description&gt;</span><br><span class="line">&lt;generator&gt;RSSHub&lt;/generator&gt;</span><br><span class="line">&lt;webMaster&gt;i@diygod.me (DIYgod)&lt;/webMaster&gt;</span><br><span class="line">&lt;language&gt;zh-cn&lt;/language&gt;</span><br><span class="line">&lt;lastBuildDate&gt;Thu, 26 Mar 2020 11:00:06 GMT&lt;/lastBuildDate&gt;</span><br><span class="line">&lt;ttl&gt;60&lt;/ttl&gt;</span><br><span class="line">&lt;item&gt;</span><br><span class="line">&lt;title&gt;</span><br><span class="line">&lt;![CDATA[ Telegram 电报机器人 ]]&gt;</span><br><span class="line">&lt;/title&gt;</span><br><span class="line">&lt;description&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/description&gt;</span><br><span class="line">&lt;pubDate&gt;Wed, 25 Mar 2020 03:54:04 GMT&lt;/pubDate&gt;</span><br><span class="line">&lt;guid isPermaLink=&quot;false&quot;&gt;https://github.com/chanshiyucx/blog/issues/108&lt;/guid&gt;</span><br><span class="line">&lt;link&gt;https://github.com/chanshiyucx/blog/issues/108&lt;/link&gt;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>&lt;guid isPermaLink=&quot;false&quot;&gt;</code> 和 <code>&lt;link&gt;</code> 中的链接 github.com/chanshiyucx/blog/issues/ 替换为 chanshiyu.com/#/post/ 即可。于是还是同样的方法新建一个 Worker，然后修改一下 <code>worker.js</code> 的代码就可以啦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Website you intended to retrieve for users.</span><br><span class="line">const upstream = &#x27;rsshub.app&#x27;</span><br><span class="line"></span><br><span class="line">// Custom pathname for the upstream website.</span><br><span class="line">const upstream_path = &#x27;/github/issue/chanshiyucx/blog&#x27;</span><br><span class="line"></span><br><span class="line">// Whether to use HTTPS protocol for upstream address.</span><br><span class="line">const https = true</span><br><span class="line"></span><br><span class="line">addEventListener(&#x27;fetch&#x27;, event =&gt; &#123;</span><br><span class="line">    event.respondWith(fetchAndApply(event.request));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">async function fetchAndApply(request) &#123;</span><br><span class="line"></span><br><span class="line">    let response = null;</span><br><span class="line">    let url = new URL(request.url);</span><br><span class="line">    let url_hostname = url.hostname;</span><br><span class="line"></span><br><span class="line">    if (https == true) &#123;</span><br><span class="line">        url.protocol = &#x27;https:&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        url.protocol = &#x27;http:&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var upstream_domain = upstream;</span><br><span class="line">    url.host = upstream_domain;</span><br><span class="line">    if (url.pathname == &#x27;/&#x27;) &#123;</span><br><span class="line">        url.pathname = upstream_path;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        url.pathname = upstream_path + url.pathname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let method = request.method;</span><br><span class="line">    let request_headers = request.headers;</span><br><span class="line">    let new_request_headers = new Headers(request_headers);</span><br><span class="line"></span><br><span class="line">    new_request_headers.set(&#x27;Host&#x27;, url.hostname);</span><br><span class="line">    new_request_headers.set(&#x27;Referer&#x27;, url.hostname);</span><br><span class="line"></span><br><span class="line">    let original_response = await fetch(url.href, &#123;</span><br><span class="line">        method: method,</span><br><span class="line">        headers: new_request_headers</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let original_response_clone = original_response.clone();</span><br><span class="line">    let original_text = null;</span><br><span class="line">    let response_headers = original_response.headers;</span><br><span class="line">    let new_response_headers = new Headers(response_headers);</span><br><span class="line">    let status = original_response.status;</span><br><span class="line"></span><br><span class="line">    const content_type = new_response_headers.get(&#x27;content-type&#x27;);</span><br><span class="line">    if (content_type.includes(&#x27;text/html&#x27;) &amp;&amp; content_type.includes(&#x27;UTF-8&#x27;)) &#123;</span><br><span class="line">        original_text = await replace_response_text(original_response_clone, upstream_domain, url_hostname);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        original_text = original_response_clone.body</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = new Response(original_text, &#123;</span><br><span class="line">        status,</span><br><span class="line">        headers: new_response_headers</span><br><span class="line">    &#125;)</span><br><span class="line">    let text = await response.text()</span><br><span class="line"></span><br><span class="line">// Modify it.</span><br><span class="line">    let modified = text.replace(/github.com\/chanshiyucx\/blog\/issues\//g, &quot;chanshiyu.com\/#\/post\/&quot;)</span><br><span class="line"></span><br><span class="line">// Return modified response.</span><br><span class="line">    return new Response(modified, &#123;</span><br><span class="line">        status: response.status,</span><br><span class="line">        statusText: response.statusText,</span><br><span class="line">        headers: response.headers</span><br><span class="line">    &#125;)</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署好 Worker 之后就可以使用 RSS 来订阅啦😋</p>
<p><img src="https://p.k8s.li/20200326193643610.png" alt="img"></p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
        <tag>telegram</tag>
      </tags>
  </entry>
  <entry>
    <title>用Cloudflare Worker搭建随机图片图床</title>
    <url>/posts/27776/</url>
    <content><![CDATA[<p>简而言之就是一个随机图床，你每次访问这个网址都会得到一张随机的图片:<br>DEMO站：<a href="https://www.tjsky.net/goto/?url=https://miaopic.tjsky.workers.dev/">https://miaopic.tjsky.workers.dev/</a></p>
<h1 id="注册CloudFlare"><a href="#注册CloudFlare" class="headerlink" title="注册CloudFlare"></a>注册CloudFlare</h1><p>注册地址（<a href="https://www.tjsky.net/goto/?url=https://dash.cloudflare.com/sign-up">https://dash.cloudflare.com/sign-up</a>）<br>输入您的电子邮箱地址和密码。单击 Create Account。<br>PS：CloudFlare有中文界面，在右上角切换</p>
<h1 id="Cloudflare-Workers部署"><a href="#Cloudflare-Workers部署" class="headerlink" title="Cloudflare Workers部署"></a>Cloudflare Workers部署</h1><ol>
<li>登录你的Cloudflare</li>
<li>在主页右侧找到【Workers】</li>
<li>点进【Workers】选择一个预设的子域，点击【set up】之后，我们选择免费套餐。</li>
<li>点进【Workers】，选择【创建Workers】</li>
<li>把这里的代码（<a href="https://www.tjsky.net/goto/?url=https://github.com/tjsky/randompic/blob/main/index.js">https://github.com/tjsky/randompic/blob/main/index.js</a>） 粘贴到页面右侧的输入框</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var background_urls = </span><br><span class="line">[</span><br><span class="line">&#x27;https://ww2.sinaimg.cn/large/be6ad69bgw1eys2ubi8loj218g0p0h3y.jpg&#x27;,</span><br><span class="line">&#x27;https://ww4.sinaimg.cn/large/be6ad69bgw1eys2ubqm6ij218g0p0ql4.jpg&#x27;,</span><br><span class="line">&#x27;https://ww3.sinaimg.cn/large/be6ad69bgw1eys2ubroxej218g0p0nki.jpg&#x27;,</span><br><span class="line">&#x27;https://ww3.sinaimg.cn/large/be6ad69bgw1eys2ubpohkj218g0p01a1.jpg&#x27;,</span><br><span class="line">&#x27;https://ww2.sinaimg.cn/large/be6ad69bgw1eys2ubkx6ij218g0p07ht.jpg&#x27;</span><br><span class="line"> /*需要随机到的图片的链接*/</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>修改代码中这部分网址为你想用来随机的图片的网址</p>
<ol>
<li>点击【保存并部署】按钮，</li>
<li>（非必须）单击你刚创建的Worker，选择重命名，起个好记好写的名字，比如pic</li>
<li>访问你的Worker的域名比如<code>pic.tjsky.workers.dev</code>就可以看到啦</li>
</ol>
<h1 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h1><ol>
<li>代码的这部分你可以在这里加一堆图片的链接，注意一下最后那一条图片网址没逗号，直接就是一个单引号结束。</li>
<li>要注意加的越多，代码运行所需的时长也越长，一般几百几千条都不会太对性能构成拖累。以及</li>
<li>如果你的论坛，扩展，软件对网络图片的网址有验证（要求网址必须是jpg，png结尾），你可以试试用类似<code>https://pic.tjsky.workers.dev/?.jpg</code>这样的网址</li>
</ol>
<h1 id="一些免费图床"><a href="#一些免费图床" class="headerlink" title="一些免费图床"></a>一些免费图床</h1><ol>
<li><a href="https://www.tjsky.net/goto/?url=https://sm.ms/">SM.MS</a>：老牌图床网站，服务器在美国，全球CDN加速，支持免费图片外链，稳定运行多年，上传下载速度都还可以。无需注册，支持原图，支持 HTTPS。</li>
<li><a href="https://www.tjsky.net/goto/?url=https://imgkr.com/">图壳</a>:国内的网站，不过速度很一般，貌似有限速</li>
<li><a href="https://www.tjsky.net/goto/?url=https://weibo.com/">新浪微博</a>:速度超级快几乎是现有图床是速度最快的，但是微博现在禁止外链了，导致需要自己用扩展设置一下 referer 策略来继续使用外链。</li>
<li><a href="https://www.tjsky.net/goto/?url=https://imgtu.com/">路过图床</a>:德国服务器，全球CND加速，速度一般，但胜在服务稳定</li>
<li><a href="https://www.tjsky.net/goto/?url=https://imgurl.org/">ImgURL</a>:CloudFlare全球CND加速，速度一般，服务比较稳定</li>
<li><a href="https://www.tjsky.net/goto/?url=https://gitee.com/">Gitee</a> &amp; <a href="https://www.tjsky.net/goto/?url=https://github.com/">github</a>，虽然他们是代码托管平台，但你可以往里塞图片，还能直链，不过毕竟不是专业图床，所以就别指望有图片处理功能。国内用户推荐用Gitee，国际用户推荐用gtihub。</li>
</ol>
]]></content>
      <tags>
        <tag>cloudflare</tag>
        <tag>随机图</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Azure学生订阅额度完全使用(薅干)指南教程</title>
    <url>/posts/56727/</url>
    <content><![CDATA[<p>Azure学生订阅包含有2个免费主机，但大部分人只会用到一个，而且默认情况下并不是真的完全免费。</p>
<p><strong>为什么不是完全免费呢？</strong></p>
<p>原因在于Azure的系统盘并不是像国内云是免费赠送的，他的系统盘也是要单独收费的，这就造成默认情况下创建好的b1s免费实例，实际使用中还会产生一些系统盘的费用。</p>
<p><strong>这个系统盘的费用能不能也节省掉？</strong></p>
<p>可以的，我们还有2个免费的64G磁盘，就是来给两个免费主机配套用的。</p>
<p><strong>如何使用这两个免费磁盘呢？</strong></p>
<p>linux主机默认情况下系统盘是30G，windows是120G，我们要做的就是把这个系统盘改成免费的64G的。</p>
<p>对于linux主机，可以直接创建，然后停止后修改磁盘大小。</p>
<p>对于windows，因为磁盘只能向上扩，不能缩小，所以windows的只能选择smalldisk系列的镜像，创建好后停止后修改磁盘大小。</p>
<p><strong>具体怎么操作？</strong></p>
<p>1）正常创建虚拟机，size选b1s，镜像选择上windows的搜索smalldisk，对于b1s实例建议选择windows server 2012 r2的。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB1Pe.mS6TpK1RjSZKPq6y3UpXaS.jpg" alt="img"></p>
<p>2）创建好虚拟机后，点虚拟机进去，顶部有几个操作按钮，点击停止。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB1_lknSW6qK1RjSZFmq6x0PFXaR.jpg" alt="img"></p>
<p>3）停止后，点击左边菜单的disks，进入磁盘页面，点击os disk下面的那个磁盘连接。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB1RkIdS9zqK1RjSZFLq6An2XXa3.jpg" alt="img"></p>
<p>4）进入后，点击configuration，将大小改为64，点击保存。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB1OE.gSY2pK1RjSZFsq6yNlXXaI.jpg" alt="img"></p>
<p>5）完成后回到虚拟机页面，点击start，启动虚拟机即可完成系统盘改为免费64G磁盘的目的。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB11RUoS7PoK1RjSZKbq6x1IXXav.jpg" alt="img"></p>
<p><strong>为什么订阅配额里面windows虚拟机的使用情况一直是0？</strong></p>
<p>订阅配额里面有2项关于b1s虚拟机配额的使用情况，如果你同时创建了一个b1s大小的linux虚拟机和一个b1s大小windows虚拟机，你可能会发现配额四种情况这里，B1s – BS Series一直增加，而且好像还超标了，像是2个b1s实例都算到这个上了，而另一个B1s – BS Series Windows却一直是0，始终未使用到。</p>
<p>这个问题是由于一个我们习惯性的操作引起的，azure上对于windows实例是要加收钱的，但他有一个选项，就是可以使用你现有的windows许可抵消，使用的方法也很简单，只要勾选一个选项就可以了。所以我们创建windows主机的时候为了省钱一般都会勾选这个选项。问题就在这里，为了能够使用到免费的b1s的windows实例，你创建虚拟机的时候不要去选这个，这样创建出来的windows虚拟机就会计算到B1s – BS Series Windows上。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB1Cy3kS7voK1RjSZFDq6xY3pXax.jpg" alt="img"></p>
<p>隔一段时间看看，如果连个b1s和p6磁盘的配额用上了，就说明免费配额你完全使用上了。</p>
<p><img src="https://ae01.alicdn.com/kf/HTB1onQlS3HqK1RjSZFPq6AwapXaH.jpg" alt="img"></p>
<p>至此，你就可以充分使用azure学生订阅提供的免费配额，一个linux跑点服务，一个windows挂机，很方便，以香港区的价格计算，光这两个完全免费的虚拟机每年的价值就两三百刀。</p>
]]></content>
      <tags>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title>Heroku可搭建项目整理</title>
    <url>/posts/24608/</url>
    <content><![CDATA[<h1 id="在线vscode"><a href="#在线vscode" class="headerlink" title="在线vscode"></a>在线vscode</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/bpmct/deploy-code-server/blob/main/guides/heroku.md   </span><br></pre></td></tr></table></figure>

<h1 id="bitwarden"><a href="#bitwarden" class="headerlink" title="bitwarden"></a>bitwarden</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/mutouxia/bitwardenrs_heroku  </span><br></pre></td></tr></table></figure>

<h1 id="搭建自己的搜索引擎（基于Google）"><a href="#搭建自己的搜索引擎（基于Google）" class="headerlink" title="搭建自己的搜索引擎（基于Google）"></a>搭建自己的搜索引擎（基于Google）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/benbusby/whoogle-search  </span><br></pre></td></tr></table></figure>

<h1 id="万能镜像站（可镜像几乎所有网站，部分网站支持登录）"><a href="#万能镜像站（可镜像几乎所有网站，部分网站支持登录）" class="headerlink" title="万能镜像站（可镜像几乎所有网站，部分网站支持登录）"></a>万能镜像站（可镜像几乎所有网站，部分网站支持登录）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/binary-person/womginx   </span><br></pre></td></tr></table></figure>

<h1 id="wordpress博客"><a href="#wordpress博客" class="headerlink" title="wordpress博客"></a>wordpress博客</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/philippheuer/wordpress-heroku   </span><br></pre></td></tr></table></figure>

<h1 id="onemanager"><a href="#onemanager" class="headerlink" title="onemanager"></a>onemanager</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/qkqpttgf/OneManager-php</span><br></pre></td></tr></table></figure>

<h1 id="hostloc签到"><a href="#hostloc签到" class="headerlink" title="hostloc签到"></a>hostloc签到</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/laogui2008/heroku_hostloc_get_points2</span><br></pre></td></tr></table></figure>

<h1 id="Office-全局管理程序-PHP"><a href="#Office-全局管理程序-PHP" class="headerlink" title="Office 全局管理程序(PHP)"></a>Office 全局管理程序(PHP)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/qkqpttgf/OfficeAdmin</span><br></pre></td></tr></table></figure>

<h1 id="cloudreve"><a href="#cloudreve" class="headerlink" title="cloudreve"></a>cloudreve</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/useblue/cloudreve-heroku</span><br></pre></td></tr></table></figure>

<h1 id="mega网盘挂载"><a href="#mega网盘挂载" class="headerlink" title="mega网盘挂载"></a>mega网盘挂载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/developeranaz/mega.nz-rclone-index-heroku</span><br></pre></td></tr></table></figure>

<h1 id="我的世界服务器"><a href="#我的世界服务器" class="headerlink" title="我的世界服务器"></a>我的世界服务器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/jkutner/heroku-buildpack-minecraft</span><br></pre></td></tr></table></figure>

<h1 id="rsshub"><a href="#rsshub" class="headerlink" title="rsshub"></a>rsshub</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/diygod/rsshub</span><br></pre></td></tr></table></figure>

<h1 id="有图比-dl（下载ytb视频）"><a href="#有图比-dl（下载ytb视频）" class="headerlink" title="有图比-dl（下载ytb视频）"></a>有图比-dl（下载ytb视频）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://elements.heroku.com/buttons/andrewstech/youtube-dl-api-server</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>heroku</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Heroku 上安装WordPress</title>
    <url>/posts/37060/</url>
    <content><![CDATA[<h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><p>打开<a href="https://github.com/aaro-n/heroku-wp">Github库</a>，点击下方的部署按钮，进行部署操作。</p>
<h2 id="自定义修改"><a href="#自定义修改" class="headerlink" title="自定义修改"></a>自定义修改</h2><h3 id="修改了那些内容"><a href="#修改了那些内容" class="headerlink" title="修改了那些内容"></a>修改了那些内容</h3><p>在<a href="https://github.com/xyu/heroku-wp/">原仓库</a>的做了以下修改：</p>
<ul>
<li>修改数据库证书，原仓库的证书已无法使用。</li>
<li>删除原仓库的 <a href="https://github.com/automattic/batcache">Batcache</a> 插件，代替为 <a href="https://wordpress.org/plugins/wp-fastest-cache/">WP Fastest Cache</a>，并且修改 Nginx 配置文件。</li>
<li>删除 AWS S3、SendGrid、Jetpack插件</li>
<li>删除 WordPress 默认安装主题和插件。</li>
<li>添加两个 Heroku 插件。</li>
<li>添加我常用的几个插件。</li>
<li>将 WordPress 安装包代替为中文版。</li>
</ul>
<h3 id="更新-WordPress-主程序"><a href="#更新-WordPress-主程序" class="headerlink" title="更新 WordPress 主程序"></a>更新 WordPress 主程序</h3><p><em>需要克隆 Github 库，Heroku要链接这个 Github 库。</em></p>
<p>首先查询<a href="https://cn.wordpress.org/download/releases/">最新版 WordPress</a>，修改 <a href="https://github.com/aaro-n/heroku-wp/blob/master/composer.json">composer.json</a>对应位置，修改版本号和下载地址。</p>
<p><img src="https://cf-image.676232.xyz/wp-content/uploads/2020/08/%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC%E5%8F%B7-1024x467.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行 composer update ，之后修改同步到 Github。</span><br></pre></td></tr></table></figure>

<h3 id="添加插件和主题"><a href="#添加插件和主题" class="headerlink" title="添加插件和主题"></a>添加插件和主题</h3><p>两种方法：</p>
<ol>
<li>修改 composer.json</li>
<li>将插件下载到 public/wp-content/plugins/ ，将主题下载到 public/wp-content/themes/ ，之后同步到 Github。</li>
</ol>
<p><em>如果你要修改插件和主题，要选用第二种方式。</em></p>
<h4 id="方案-1-安装"><a href="#方案-1-安装" class="headerlink" title="方案 1 安装"></a>方案 1 安装</h4><ul>
<li>打开<a href="https://cn.wordpress.org/plugins/">插件</a>网站和 <a href="https://wpackagist.org/">WordPress Packagist</a>，将插件名在 <a href="https://wpackagist.org/">WordPress Packagist</a> 搜索，选择对应版本号，将代码复制到对应位置，<em>注意：末尾有个英文状态下的逗号。</em></li>
</ul>
<p><img src="https://cf-image.676232.xyz/wp-content/uploads/2020/08/%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81-1024x472.png" alt="img">输入插件和主题名称</p>
<p><img src="https://cf-image.676232.xyz/wp-content/uploads/2020/08/%E6%8F%92%E4%BB%B6%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2-1024x406.png" alt="img">复制代码</p>
<p><img src="https://cf-image.676232.xyz/wp-content/uploads/2020/08/%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1024x849.png" alt="img">要添加到对应位置，还要注意最后的英文逗点。</p>
<ul>
<li>执行 <code>composer update</code> ，同步到 Github。</li>
</ul>
<h3 id="删除默认主题和插件"><a href="#删除默认主题和插件" class="headerlink" title="删除默认主题和插件"></a>删除默认主题和插件</h3><p>修改 <code>support/app_slug_compile.sh</code> ，主要添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf public.built/wp-content/plugins/akismet</span><br><span class="line">rm -rf public.built/wp-content/plugins/hello-dol*</span><br><span class="line"></span><br><span class="line">rm -rf public.built/wp-content/themes/twentyseventeen</span><br><span class="line">rm -rf public.built/wp-content/themes/twentynineteen</span><br></pre></td></tr></table></figure>

<p>之后同步到Github。</p>
<p>在 Heroku 上重新部署</p>
]]></content>
      <tags>
        <tag>heroku</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git上传文件到Github/Gitee</title>
    <url>/posts/41157/</url>
    <content><![CDATA[<h3 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h3><h4 id="0-创建repository"><a href="#0-创建repository" class="headerlink" title="0.创建repository"></a>0.创建repository</h4><p>无论是Github还是Gitee，上传文件前都要创建相应的仓库（repository）</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/1.png" alt="image-20200219224325936"></a></p>
<p>image-20200219224325936</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/2.png" alt="image-20200219224407034"></a></p>
<p>image-20200219224407034</p>
<h4 id="1-打开git-bash"><a href="#1-打开git-bash" class="headerlink" title="1.打开git bash"></a>1.打开git bash</h4><p>在需要上传的本地文件夹内右键打开git bash：</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/3.png" alt="image-20200219224731076"></a></p>
<p>image-20200219224731076</p>
<h4 id="2-git-init"><a href="#2-git-init" class="headerlink" title="2.git init"></a>2.git init</h4><p>输入git init 指令，在该文件夹中创建本地仓库：</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/4.png" alt="image-20200219224948161"></a></p>
<p>image-20200219224948161</p>
<h4 id="3-git-add"><a href="#3-git-add" class="headerlink" title="3.git add ."></a>3.git add .</h4><p>输入git add . 指令，添加该文件夹下的所有文件到本地仓库。”.”表示添加所有文件，如果想要添加个别文件可以把”.”替换为相应文件名。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/5.png" alt="image-20200219225312380"></a></p>
<p>image-20200219225312380</p>
<h4 id="4-git-commit-m-“注释”"><a href="#4-git-commit-m-“注释”" class="headerlink" title="4.git commit -m “注释”"></a>4.git commit -m “注释”</h4><p>输入git commit -m “first update” 指令，git commit -m作用为提交暂存区的文件（也就是上一步添加的文件），后面双引号内可以填写关于提交的注释信息，这里写的是“first update”。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/6.png" alt="image-20200219225836144"></a></p>
<p>image-20200219225836144</p>
<h4 id="5-git-remote-add-origin-远程仓库地址"><a href="#5-git-remote-add-origin-远程仓库地址" class="headerlink" title="5.git remote add origin 远程仓库地址"></a>5.git remote add origin 远程仓库地址</h4><p>输入git remote add origin <a href="https://github.com/AhuntSun/JavaScript-.git%E6%88%96">https://github.com/AhuntSun/JavaScript-.git或</a></p>
<p>git remote add origin <a href="https://gitee.com/ahuntsun/Test.git">https://gitee.com/ahuntsun/Test.git</a> 指令，建立本地仓库与远程仓库的关联，指令后面的地址为Github/Gitee上原有目标仓库或刚创建的仓库的地址。下以Gitee上的仓库为例。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/7.png" alt="image-20200219230327286"></a></p>
<p>image-20200219230327286</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/8.png" alt="image-20200219230352725"></a></p>
<p>image-20200219230352725</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/9.png" alt="image-20200219230509698"></a></p>
<p>image-20200219230509698</p>
<h4 id="6-git-pull-–rebase-origin-master"><a href="#6-git-pull-–rebase-origin-master" class="headerlink" title="6.git pull –rebase origin master"></a>6.<strong>git pull –rebase origin master</strong></h4><p>输入git pull –rebase origin master指令，将远程仓库的内容合并到本地仓库。如果远程仓库为空可以跳过这一步，如果远程仓库不为空，则必须进行这一步，否则会报错。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/10.png" alt="image-20200219231006483"></a></p>
<p>image-20200219231006483</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/11.png" alt="image-20200219231021740"></a></p>
<p>image-20200219231021740</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/12.png" alt="image-20200219231043888"></a></p>
<p>image-20200219231043888</p>
<h4 id="7-git-push-u-origin-master"><a href="#7-git-push-u-origin-master" class="headerlink" title="7.git push -u origin master"></a>7.git push -u origin master</h4><p>输入git push -u origin master指令，将本地仓库的文件推送到已经建立关联的远程仓库master分支中。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/13.png" alt="image-20200219231317187"></a></p>
<p>image-20200219231317187</p>
<p>执行问命令后可以在远程仓库中看到上传的本地文件：</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/14.png" alt="image-20200219231425353"></a></p>
<p>image-20200219231425353</p>
<p>如果远程仓库不为空，且没有进行第6步，执行第7步指令时会出现如下错误：</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/15.png" alt="image-20200219231725132"></a></p>
<p>image-20200219231725132</p>
<h4 id="8-git-status"><a href="#8-git-status" class="headerlink" title="8.git status"></a>8.git status</h4><p>最后可以输入git status指令查看本地仓库的状态，本步可以省略。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/git/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Github%E5%92%8CGitee/16.png" alt="image-20200219231946879"></a></p>
<p>image-20200219231946879</p>
<blockquote>
<p>将文件推送至Github也是一样的步骤。</p>
</blockquote>
<p>只要建立了该文件夹内的本地仓库与远程仓库的关联，之后上传该文件夹内的文件只需要输入步骤3、4、7的指令即可。</p>
]]></content>
      <tags>
        <tag>heroku</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>(新版)通过AutoRclone批量生成SA文件的究极保姆级教程</title>
    <url>/posts/50467/</url>
    <content><![CDATA[<p>本文更新于2021.12.7。</p>
<p>准备工作：一台能访问Google的VPS。本文所使用的VPS环境为DigitalOcean的Ubuntu 20.04。</p>
<p>Debian 9+，Centos 7+ 理论可行，但未测试。</p>
<p>DigitalOcean注册地址：<a href="https://m.do.co/c/76209bc8b100">https://m.do.co/c/76209bc8b100</a> （注册即可获得100刀的额度，可使用60天）</p>
<p>前言：自从GCP页面更改后，之前生成SA的教程都已失效，于是做一个教程帮助大家（本人能力有限，教程中难免有错误，还请各位谅解并指正）</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/28-1-1024x511.png" alt="img">更改后的GCP授权页面</p>
<p>教程正式开始：</p>
<p>一. 创建项目并获取相关授权文件</p>
<ol>
<li>浏览器打开: <a href="https://console.cloud.google.com/apis/library">https://console.cloud.google.com/apis/library</a></li>
</ol>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/1-2.png" alt="img"></p>
<p>\2. 第一次进入这个界面会弹出如上图的欢迎界面，同意之后点击同意并继续。</p>
<p>点击页面上方选择项目</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/2-2.png" alt="img"></p>
<p>\3. 点击新建项目并填写相关信息（根据图示一步一步来）</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/3-1.png" alt="img"></p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/4-1.png" alt="img">项目名称随意，点击创建</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/5-1.png" alt="img"></p>
<p>此时，已经创建好了一个全新的项目，我们继续。</p>
<p>\4. 开启相关API</p>
<p>一般情况下需要开启如下5个API</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Google Drive API</span><br><span class="line">Identity and Access Management (IAM) API</span><br><span class="line">Service Usage API</span><br><span class="line">Cloud Resource Manager API</span><br><span class="line">IAM Service Account Credentials API</span><br></pre></td></tr></table></figure>

<p>我只示例Google Drive API开启具体步骤，其余API步骤相同：</p>
<p>在“搜索API和服务”框内输入 drive，点击Google Drive API。</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/6-1.png" alt="img"></p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/7-1.png" alt="img">启用API</p>
<p>稍等片刻，Google Drive API就启动成功了。</p>
<p>然后点击左上角三条横线，找到 API与服务-库 搜索其余4个API并开启。（有的默认开启的就不用管了）</p>
<p>操作完成后，我们检验一下是否全部开启成功，</p>
<p>点击左上角三条横线，找到 API与服务-信息中心，在这里我们可以看到我们成功开启的所有API（除了刚刚开启的5个，其余的是默认开启的，不需要管）</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/11-1.png" alt="img"></p>
<p>确认5个API开启后，我们进行下一步</p>
<p>\5. 配置OAuth同意屏幕并创建客户端（按照图示一步一步来）</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/12-1-1024x726.png" alt="img"></p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/13-1.png" alt="img">点击外部-创建</p>
<p>应用名称、用户支持电子邮件、开发者联系信息随便填</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/14-1.png" alt="img"></p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/15-1.png" alt="img">填好后保存并继续</p>
<p>测试用户这一栏不用填直接保存并继续。</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/16-1.png" alt="img"></p>
<p>我们看到现在我们刚刚创建的应用还是测试版，测试版需要添加测试用户而且客户端ID和密码只有7天有效期，所以我们一定要发布应用，发布了之后客户端ID密码都是没有时间限制的。</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/17-1.png" alt="img"></p>
<p>至此，OAuth同意屏幕配置完成，接下来创建客户端ID和密码</p>
<p>点击凭据，</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/18-1.png" alt="img"></p>
<p>点击创建凭据-OAuth客户端 ID</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/19-1-1024x627.png" alt="img"></p>
<p>应用类型选择桌面应用，名称随意，完成后点击创建，</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/20-1.png" alt="img"></p>
<p>此时，客户端ID与密码创建完毕，可以记下来，以后使用方便，不想记也没事，以后还能看，</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/21-1.png" alt="img"></p>
<p>点击下载授权文件，并改名为 credentials.json</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/GA601UT3LPW1VUVTB9-1-1024x294.png" alt="img"></p>
<p>到此，我们成功获得了授权文件。</p>
<p>二、 通过AutoRclone项目创建SA</p>
<p>接下来需要到VPS上操作了，首先远程登陆好你的VPS。</p>
<ol>
<li>配置环境</li>
</ol>
<p>Ubuntu、Debian:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y update &amp;&amp; sudo apt-get -y upgrade &amp;&amp; sudo apt -y update &amp;&amp; sudo apt -y upgrade &amp;&amp; sudo apt install wget curl python3 python3-pip git unzip screen fuse -y</span><br></pre></td></tr></table></figure>

<p>Centos:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br><span class="line"></span><br><span class="line">yum install epel-release -y</span><br><span class="line"></span><br><span class="line">yum install wget curl python3 python3-pip git screen unzip sudo fuse fuse-devel -y </span><br></pre></td></tr></table></figure>

<p>安装完成后，试试输 python3 -V 和 pip3 -V 是否正确显示版本号，如果是则说明 python 配置正确，请继续下一步；如果不是，请自行配置 python 环境。</p>
<p>\2. 安装Node.js 12.18.3(可选，为gd-utils转存做准备，单纯生成sa不需要node环境)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash &amp;&amp; source ~/.bashrc &amp;&amp; nvm install 12.18.3 &amp;&amp; node -v &amp;&amp; npm -v</span><br></pre></td></tr></table></figure>



<p>\3. 安装rclone、AutoRclone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo git clone https://github.com/xyou365/AutoRclone &amp;&amp; cd AutoRclone &amp;&amp; sudo pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>\4. 将刚下载好的授权文件上传到AutoRclone根目录</p>
<p>上传可以使用宝塔面板或者xftp，这个不会的可以自行谷歌，</p>
<p><a href="https://www.google.com/search?q=ssh%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">https://www.google.com/search?q=ssh%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6</a></p>
<p>上传完成后继续操作，</p>
<p>\5. 生成SA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在AutoRclone根目录执行</span><br><span class="line"></span><br><span class="line">python3 gen_sa_accounts.py --quick-setup 1 --new-only</span><br></pre></td></tr></table></figure>

<p>这个命令的含义是创建一个项目并创建100个SA（对于99.9999%的人100个SA都够用了）</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/26-2-1024x132.png" alt="img"></p>
<p>执行上条命令后会出现一个链接，复制并在浏览器中打开，登陆你刚刚创建项目的Google账号（注意别弄错了）进行授权，</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/23-2.png" alt="img">点击高级-继续前往</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/24-2.png" alt="img">赋予权限</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/25-2.png" alt="img">复制返回码</p>
<p>复制返回码并粘贴到SSH终端，点击回车，等待SA生成完毕</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/26-1-1024x132.png" alt="img">SA生成完毕</p>
<p><img src="https://zzzweb.xyz/wp-content/uploads/2021/07/27-1-1024x493.png" alt="img">100个SA授权文件</p>
<p>我们可以执行 ls /root/AutoRclone/accounts ,发现里面有100个SA授权文件，至此SA已生成完毕。</p>
<p>温馨提示：SA授权文件非常重要，建议下载保存，丢失找回非常困难！</p>
]]></content>
      <tags>
        <tag>Google Drive</tag>
        <tag>AutoRclone</tag>
      </tags>
  </entry>
  <entry>
    <title>Vercel反向代理做CDN</title>
    <url>/posts/56727/</url>
    <content><![CDATA[<p>Vercel免费用户拥有每月100G的流量，一般来说是够用的，这个100G的话，虽然网页上号称无限，实际上合理使用政策里写的是100G，构建时间是100小时，一般我们可以用它托管静态网站，它还支持路由重写功能，因此我们可以实现反代，也就是类似于CDN的功能。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1、注册Vercel"><a href="#1、注册Vercel" class="headerlink" title="1、注册Vercel"></a>1、注册Vercel</h3><p>官方网站：<a href="https://vercel.com/">https://vercel.com</a><br>推荐使用Github账号登录 注：QQ邮箱注册不行，若Github绑定QQ邮箱，修改其他邮箱为主邮箱注册</p>
<h3 id="2、安装Nodejs"><a href="#2、安装Nodejs" class="headerlink" title="2、安装Nodejs"></a>2、安装Nodejs</h3><p>可参考以下网址：<br><a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a><br>注：我的版本12.18.3，高版本有些问题</p>
<h3 id="3、安装Vercel-CLI-需Nodejs"><a href="#3、安装Vercel-CLI-需Nodejs" class="headerlink" title="3、安装Vercel CLI(需Nodejs)"></a>3、安装Vercel CLI(需Nodejs)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制npm i -g vercel</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2021-2-5-01.jpg" alt="img"></p>
<h3 id="4、使用Vercel-CLI登录Vercel"><a href="#4、使用Vercel-CLI登录Vercel" class="headerlink" title="4、使用Vercel CLI登录Vercel"></a>4、使用Vercel CLI登录Vercel</h3><p>使用cmd终端执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制vercel login</span><br></pre></td></tr></table></figure>


<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2021-2-5-02.jpg" alt="img"><br>输入邮箱(如果你是使用Github登录的Vercel，那就输入绑定Github的邮箱)<br>回车后会发生一封验证邮件，点击邮件中的验证链接，即完成验证，接着回到Vercel CLI的终端</p>
<p>终端中会提示登录完成<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2021-2-5-03.jpg" alt="img"></p>
<h3 id="5、创建反代配置文件"><a href="#5、创建反代配置文件" class="headerlink" title="5、创建反代配置文件"></a>5、创建反代配置文件</h3><p>在一个合适的位置(最好新建一个文件夹)，里面新建一个文件，文件名可以随意<br>我的文件名是123.json<br>反代内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制&#123;</span><br><span class="line">  &quot;version&quot;: 2,</span><br><span class="line">  &quot;routes&quot;: [</span><br><span class="line">      &#123;&quot;src&quot;: &quot;/(.*)&quot;,&quot;dest&quot;: &quot;https://www.xxx.com/$1&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>将上面的<a href="https://www.xxx.com/%E6%94%B9%E4%B8%BA%E4%BD%A0%E6%83%B3%E8%A6%81%E5%8F%8D%E4%BB%A3%E7%9A%84URL">https://www.xxx.com/改为你想要反代的URL</a><br>将cd到之前新建文件夹（例如我的文件夹名cdn）的下面<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2021-2-5-04.jpg" alt="img"><br>在终端执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制vercel -A xxx.json --prod</span><br></pre></td></tr></table></figure>


<p>将上面的xxx.json改为你的文件名<br>按照提示输入回车<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2021-2-5-05.jpg" alt="img"><br>注：前两个可以直接回车，n代表没有同名项目，新建项目，cdntjys是新建项目名<br>等待一会就完成了</p>
<p>默认的是xxx.vercel.app的域名,也可以修改域名为xxx.now.sh<br>可以自定义域名，前往vercel官网网页修改<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2021-2-5-06.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>CDN</tag>
        <tag>Vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>一键DD脚本</title>
    <url>/posts/56727/</url>
    <content><![CDATA[<p>一键DD脚本，支持性好，更智能更全面，支持国内外各种VPS重装，特别是对国内各种访问国外资源慢的VPS安装有奇效。</p>
<hr>
<p>更新说明：<br>20211120：更新MoeClub新版,依赖更少,支持原版自定义密码安装,体验版可能有Bug.<br>20210909：支持debian11.<br>20210511：发现很多人不知道怎么DD甲骨文,使用支持uefi的镜像包即可.脚本已添加3个甲骨文专用选项23-25.<br>20210509：更新部分windows镜像,修正一处小问题.<br>20210127：更换部分windows镜像.<br>20210109：更新支持Ubuntu20.04安装,更新几个windows镜像.<br>20200708：更新自动为CN主机使用国内镜像源.</p>
<hr>
<p>安装重装系统的前提组件:<br>Debian/Ubuntu:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install -y xz-utils openssl gawk file wget screen &amp;&amp; screen -S os</span><br></pre></td></tr></table></figure>

<p>RedHat/CentOS:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y xz openssl gawk file glibc-common wget screen &amp;&amp; screen -S os</span><br></pre></td></tr></table></figure>

<p>如果出现异常，请刷新Mirrors缓存或更换镜像源。<br>RedHat/CentOS:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache &amp;&amp; yum update -y</span><br></pre></td></tr></table></figure>

<p>Debian/Ubuntu:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update -y &amp;&amp; apt dist-upgrade -y</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O AutoReinstall.sh https://git.io/betags &amp;&amp; chmod a+x AutoReinstall.sh &amp;&amp; bash AutoReinstall.sh</span><br></pre></td></tr></table></figure>

<p>新版体验：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O NewReinstall.sh https://git.io/newbetags &amp;&amp; chmod a+x NewReinstall.sh &amp;&amp; bash NewReinstall.sh</span><br></pre></td></tr></table></figure>

<p>如为CN主机，可能出现报错或不能下载脚本的问题，可执行以下命令开始安装.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O AutoReinstall.sh https://cdn.jsdelivr.net/gh/fcurrk/reinstall@master/AutoReinstall.sh &amp;&amp; chmod a+x AutoReinstall.sh &amp;&amp; bash AutoReinstall.sh</span><br></pre></td></tr></table></figure>

<p>新版体验：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O NewReinstall.sh https://cdn.jsdelivr.net/gh/fcurrk/reinstall@master/NewReinstall.sh &amp;&amp; chmod a+x NewReinstall.sh &amp;&amp; bash NewReinstall.sh</span><br></pre></td></tr></table></figure>

<p><a href="https://static.heitaosan.com/usr/uploads/2021/11/2224945253.png"><img src="https://static.heitaosan.com/usr/uploads/2021/11/2224945253.png" alt="20211130-1.png"></a><br>输入Y确认DD后主机自动获取IP，N则自行设置IP 输入N后会自动检测出主机现用IP，如果正确可以按Y确认使用，如不正确则按N自行按正确的输入。<br><a href="https://static.heitaosan.com/usr/uploads/2021/11/1906089596.png"><img src="https://static.heitaosan.com/usr/uploads/2021/11/1906089596.png" alt="20211130-2.png"></a></p>
<p>25合1的系统一键DD选择界面，输入99则使用自定义镜像。 以上系统密码不为默认密码的均为网络收集，如有疑虑使用自己的自定义镜像。</p>
<p>25合一系统密码：<br>1、CentOS 7.7 (已关闭防火墙及SELinux，默认密码Pwd@CentOS)<br>2、CentOS 7 (默认密码cxthhhhh.com)<br>3、CentOS 8 (默认密码cxthhhhh.com)<br>4、CentOS 6 (默认密码Minijer.com)<br>5、Debian 11 (默认密码Minijer.com)<br>6、Debian 10 (默认密码Minijer.com)<br>7、Debian 9 (默认密码Minijer.com)<br>8、Debian 8 (默认密码Minijer.com)<br>9、Ubuntu 20.04 (默认密码Minijer.com)<br>10、Ubuntu 18.04 (默认密码Minijer.com)<br>11、Ubuntu 16.04 (默认密码Minijer.com)<br>12、Windows Server 2019 (默认密码cxthhhhh.com)<br>13、Windows Server 2016 (默认密码cxthhhhh.com)<br>14、Windows Server 2012 (默认密码cxthhhhh.com)<br>15、Windows Server 2012 Lite (默认密码nat.ee)<br>16、Windows Server 2008 (默认密码cxthhhhh.com)<br>17、Windows Server 2008 Lite (默认密码nat.ee)<br>18、Windows Server 2003 (默认密码cxthhhhh.com)<br>19、Windows Server 2003 Lite (默认密码WinSrv2003x86-Chinese)<br>20、Windows 10 LTSC Lite (默认密码<a href="http://www.nat.ee/">www.nat.ee</a>)<br>21、Windows 7 x86 Lite (默认密码Windows7x86-Chinese)<br>22、Windows 7 Ent Lite (默认密码nat.ee)<br>23、Windows 7 Ent Lite (UEFI支持甲骨文)(默认密码nat.ee)<br>24、Windows Server 2008 Lite (UEFI支持甲骨文)(默认密码nat.ee)<br>25、Windows Server 2012 Lite (UEFI支持甲骨文)(默认密码nat.ee)<br>99、自定义镜像</p>
<hr>
<p>注意：<br>经测试在谷歌云原版系统基础上DD会出现自动获取的子网掩码为255.255.255.255,如出现这种情况需要手工输入改正为正确的如255.255.255.0,否则会安装完成主机可能会离线。<br>Oracle Cloud（甲骨文云）可选择23-25一键DD,注意基础系统最好选择Ubuntu，如原系统是CentOS可能无法成功。</p>
<p>特别感谢：Vicer、cxt、hiCasper等各位技术大佬的脚本，以及<code>git.beta.gs</code>的整理，站长只是脚本的”搬运工”。</p>
]]></content>
      <tags>
        <tag>DD系统</tag>
      </tags>
  </entry>
  <entry>
    <title>DDWindows一键脚本</title>
    <url>/posts/56727/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li><strong>无限制全自动dd安装Windows</strong></li>
<li><strong>突破没有VNC,没有救援模式,内存比dd包小的限制</strong></li>
<li><strong>使用Debian Live CD中的busybox做中间媒介,经过复杂的处理使本机的网络参数传进Windows操作系统中</strong></li>
<li><strong>即使没有DHCP能够让Windows获取网络参数,也能让Windows操作系统在开机的第一时间能够连通网络</strong></li>
</ul>
<p><strong>特别注意：OpenVZ构架不适用</strong></p>
<h2 id="安装运行库"><a href="#安装运行库" class="headerlink" title="安装运行库"></a>安装运行库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Debian/Ubuntu:</span><br><span class="line">apt-get install -y xz-utils openssl gawk file</span><br><span class="line"></span><br><span class="line">#RedHat/CentOS:</span><br><span class="line">yum install -y xz openssl gawk file</span><br></pre></td></tr></table></figure>

<p><strong>如果出现错误，运行以下代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Debian/Ubuntu:</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">#RedHat/CentOS:</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>

<h2 id="一键脚本"><a href="#一键脚本" class="headerlink" title="一键脚本"></a>一键脚本</h2><p><strong>示例脚本，补全DD包直连地址后运行即可；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;[Windows dd包直连地址]&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="精简版DD包"><a href="#精简版DD包" class="headerlink" title="精简版DD包"></a>精简版DD包</h2><p><strong>选择好版本，输入以下一键脚本即可</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DD Windows Server 2003 32位 精简版 [账户Administrator密码cxthhhhh.com]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win_Server2003_86_Administrator_cxthhhhh.com.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2008 R2 64位 精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win_Server2008R2_sp1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2012 R2 64位 精简版 [账户Administrator密码WinSrv2012r2x64-Chinese]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win_Server2012R2_64_Administrator_WinSrv2012r2x64-Chinese.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2019 Datacenter 64位 精简版 [账户Administrator密码WinSrv2019dc-Chinese]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win_Server2019_64_Administrator_WinSrv2019dc-Chinese.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows7 32位 精简版 [账户Administrator密码Windows7x86-Chinese]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win7_86_Administrator_Windows7x86-Chinese.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows7 sp1 64位 企业精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win7_sp1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line">#DD Windows8.1 64位 专业精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win8.1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line">#DD Windows8.1 64位 适量精简版 [账户Administrator密码Vicer]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win8.1_64_Administrator_Vicer.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows10 2016LTSB 64位 企业深度精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win10_2016LTSB_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows10 2019LTSC 64位 企业适量精简版 [账户Administrator密码Vicer]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Win10_2019LTSC_64_Administrator_Vicer.gz&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="完整版DD包"><a href="#完整版DD包" class="headerlink" title="完整版DD包"></a>完整版DD包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DD Windows Server 2012 R2 Datacenter 64位 完整版 [账户administrator密码Password147]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Whole/cn_windows2012r2_administrator_Password147.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2016 Datacenter 64位 完整版 [账户administrator密码Password147]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Whole/cn_windows2016_administrator_Password147.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2019 Datacenter 64位 完整版 [账户administrator密码Password147]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Whole/cn_windows2019_administrator_Password147.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows7 sp1 64位 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Whole/Win7_sp1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows8.1 64位 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Whole/Win8.1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows10 LTSC 64位 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Whole/Win10_LTSC_64_Administrator_nat.ee.gz&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="Oracle甲骨文"><a href="#Oracle甲骨文" class="headerlink" title="Oracle甲骨文"></a>Oracle甲骨文</h2><p><strong>此DD包仅适用于Oracle甲骨文DD Win使用 （注意：不适用于新出的ARM框架机型）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DD Windows7 sp1 64位 企业精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Oracle_Win7_sp1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows8.1 64位 企业精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Oracle_Win8.1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows10 2016LTSB 64位 企业深度精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Oracle_Win10_2016LTSB_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2008 R2 64位 精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Oracle_Win_Server2008R2_sp1_64_Administrator_nat.ee.gz&#x27;</span><br><span class="line"></span><br><span class="line"># DD Windows Server 2012 R2 64位 精简版 [账户Administrator密码nat.ee]</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh -dd &#x27;https://oss.sunpma.com/Windows/Oracle_Win_Server2012R2_64_Administrator_nat.ee.gz&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="OVH"><a href="#OVH" class="headerlink" title="OVH"></a>OVH</h2><p><strong>此DD包仅适用于OVH云服务器DD Win使用</strong><br><strong>说明：OVH需要使用网络参数进行安装，需要的可以参考下面的安装方法，博主并未进行测试，这里仅提供直链包；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DD Windows7 64位 精简版 [账户administrator密码www.80host.com]</span><br><span class="line">https://oss.sunpma.com/Windows/win/OVH_Win7_64_administrator_www.80host.com.gz</span><br></pre></td></tr></table></figure>

<h2 id="网络参数安装"><a href="#网络参数安装" class="headerlink" title="网络参数安装"></a>网络参数安装</h2><p><strong>比如GCP谷歌云Azure微软云OVH云服务器等需要指定网络参数安装的方式，示例为GCP谷歌云</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将X.X.X.X替换为自己的网络参数.</span><br><span class="line"># --ip-addr :IP Address/内网IP地址</span><br><span class="line"># --ip-mask :Netmask   /子网掩码</span><br><span class="line"># --ip-gate :Gateway   /网关</span><br><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh --ip-addr X.X.X.X --ip-mask X.X.X.X --ip-gate X.X.X.X -dd &#x27;DD包 直链地址&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>例：</strong><br>替换<code>--ip-addr</code>后面的<code>X.X.X.X</code>为你自己的内网IP即可；<br>在GCP谷歌云 <code>Debian</code> / <code>Ubuntu</code> 测试成功， <code>CentOS</code> 未测试；<br>账户：<code>Administrator</code> 密码：<code>nat.ee</code><br><strong>GCP谷歌云 香港</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh --ip-addr X.X.X.X --ip-mask 255.255.255.0 --ip-gate 10.170.0.1 -dd &#x27;https://oss.sunpma.com/Windows/Win7_sp1_64_Administrator_nat.ee.gz&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>GCP谷歌云-台湾</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -qO InstallNET.sh &#x27;https://moeclub.org/attachment/LinuxShell/InstallNET.sh&#x27; &amp;&amp; bash InstallNET.sh --ip-addr X.X.X.X --ip-mask 255.255.255.0 --ip-gate 10.140.0.1 -dd &#x27;https://oss.sunpma.com/Windows/Win7_sp1_64_Administrator_nat.ee.gz&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>连接上后如果遇到无法打开网页的情况，修改DNS即可</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8.8.8.8</span><br><span class="line">8.8.4.4</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DD系统</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux VPS使用Rclone挂载Google Drive为本地硬盘使用</title>
    <url>/posts/27099/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>Rclone</code>是一款命令行工具，支持在不同对象存储、网盘之间同步、上传、下载数据；<br>官网地址：<a href="https://rclone.org/">https://rclone.org</a></p>
<p>本教程适用于<code>Debian</code> / <code>Ubuntu</code>系统，如果你是<code>CentOS</code>或者其它<code>Linux</code>系统，请使用以下命令安装<code>rclone</code><br><code>CentOS</code> 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | sudo bash</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>Debian</code> / <code>Ubuntu</code> 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">unzip rclone-current-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">chmod 0777 ./rclone-*/rclone</span><br><span class="line"></span><br><span class="line">cp ./rclone-*/rclone /usr/bin/</span><br><span class="line"></span><br><span class="line">rm -rf ./rclone-*</span><br></pre></td></tr></table></figure>

<p>适用于<code>ARM</code>框架安装命令：（如甲骨文Oracle等）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://downloads.rclone.org/rclone-current-linux-arm64.zip</span><br><span class="line"></span><br><span class="line">unzip rclone-current-linux-arm64.zip</span><br><span class="line"></span><br><span class="line">chmod 0777 ./rclone-*/rclone</span><br><span class="line"></span><br><span class="line">cp ./rclone-*/rclone /usr/bin/</span><br><span class="line"></span><br><span class="line">rm -rf ./rclone-*</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装完成后输入以下命令开始配置<code>Rclone</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone config</span><br></pre></td></tr></table></figure>

<h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><p><strong>展开查看详情</strong></p>
<h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/rclone mount DriveName:Folder LocalFolder \</span><br><span class="line"> --umask 0000 \</span><br><span class="line"> --default-permissions \</span><br><span class="line"> --allow-non-empty \</span><br><span class="line"> --allow-other \</span><br><span class="line"> --transfers 1 \</span><br><span class="line"> --buffer-size 64M \</span><br><span class="line"> --low-level-retries 200</span><br><span class="line"></span><br><span class="line">## 上面代码是一个整体，全部复制后粘贴运行</span><br><span class="line"></span><br><span class="line">DriveName       # 配置时填写的name</span><br><span class="line">Folder          # 网盘里要挂载的文件夹名</span><br><span class="line">LocalFolder     # 本地要挂载的文件夹绝对路径</span><br><span class="line">## 例：/usr/bin/rclone mount GD:VPS /home/GoogleDrive \</span><br></pre></td></tr></table></figure>

<p>参数说明:<br><code>--transfers</code><br>该参数是最大同时传输任务数量，如果经常传输大文件，或CPU性能不佳，建议设置为单线程，也就是设置为“1”<br><code>--buffer-size</code><br>该参数为读取每个文件时的内存缓冲区大小，控制rclone上传和挂载的时候的内存占用<br><code>--low-level-retries</code><br>该参数为传输文件没速度的时候重试次数，没速度的时候，单个会自动睡眠10ms起，然后再重试</p>
<p>如果你还涉及到读取使用，比如使用H5ai等在线播放，就在后面多加上以下三条参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--dir-cache-time 12h</span><br><span class="line">--vfs-read-chunk-size 32M</span><br><span class="line">--vfs-read-chunk-size-limit 1G</span><br></pre></td></tr></table></figure>

<p>出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 如果出现如下错误</span><br><span class="line">Fatal error: failed to mount FUSE fs: fusermount: exec: &quot;fusermount&quot;: executable file not found in $PATH</span><br><span class="line"></span><br><span class="line">## 安装fuse即可</span><br><span class="line">apt install fuse</span><br></pre></td></tr></table></figure>

<p>挂载成功后，输入<code>df -h</code>命令查看是否挂载成功:<br><a href="https://sunpma.com/usr/uploads/2019/10/255241265.png"><img src="https://sunpma.com/usr/uploads/2019/10/255241265.png" alt="img"></a></p>
<h2 id="卸载磁盘"><a href="#卸载磁盘" class="headerlink" title="卸载磁盘"></a>卸载磁盘</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fusermount -qzu LocalFolder</span><br><span class="line"></span><br><span class="line">## LocalFolder为本地挂载文件夹绝对路径</span><br></pre></td></tr></table></figure>

<p><strong><code>Rclone</code>的具体操作命令可以参考：</strong><a href="https://sunpma.com/864.html">https://sunpma.com/864.html</a></p>
]]></content>
      <tags>
        <tag>VPS</tag>
        <tag>Rclone</tag>
      </tags>
  </entry>
  <entry>
    <title>修改微软全局sharepoint二级域名前缀</title>
    <url>/posts/38125/</url>
    <content><![CDATA[<h1 id="前话"><a href="#前话" class="headerlink" title="前话"></a><strong>前话</strong></h1><p>​        按照微软的说法：首次注册 Microsoft 365 时，你创建了一个 onmicrosoft.com 域。 即使你后来添加了自定义域，原始 onmicrosoft.com 域也将用于所有 SharePoint 和 OneDrive URL。如果我们当初自定义的域名不符合自己的心意，那么我们就可以安装下面的教程修改自定义域名。</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>​        这里说的修改域名是指将 SharePoint URL 从 如abc.sharepoint.com 更改为 zxc.sharepoint.com.</p>
<h2 id="第-1-步：验证新域名"><a href="#第-1-步：验证新域名" class="headerlink" title="第 1 步：验证新域名"></a>第 1 步：验证新域名</h2><p>​        1.检查你想要的新域的可用性。 例如，如果希望 SharePoint 和 OneDrive URL 以 zxc.sharepoint.com 开头，在浏览器中输入 <a href="https://zxc.sharepoint.com./">https://zxc.sharepoint.com。</a> 如果是404页面，那么这个域名可能可用。 如果提示登录或目录中找不到用户名的消息，就要换一个。 </p>
<p>​        2.<a href="https://aka.ms/SPORenameAddDomain">https://aka.ms/SPORenameAddDomain</a> 添加新的域名（必须使用该链接转到 Azure AD 管理中心的自定义域名页面，否则添加可能不成功）</p>
<p>​        3.选择 添加自定义域。在“自定义域名”框中，输入完整的新“.onmicrosoft.com”域，然后选择“添加域”。（该域必须是“onmicrosoft.com”域。 例如，如果要重命名为 zxc.sharepoint.com，则输入的域应为 zxc.onmicrosoft.com）</p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/1.PNG" alt="img"></p>
<p>​        4.在页面顶部的导航中，选择租户名称,返回到自定义域名页面。 确保添加的 onmicrosoft.com 域在列表中，并且状态显示为“已验证”。（值得注意的是，在365管理中心修改或者添加的回退域状态显示为“可用”而非“已验证”，如果状态不是“已验证”，则你将无法执行重命名操作，未进一步验证）</p>
<h2 id="第-2-步：使用-Microsoft-PowerShell-重命名域"><a href="#第-2-步：使用-Microsoft-PowerShell-重命名域" class="headerlink" title="第 2 步：使用 Microsoft PowerShell 重命名域"></a>第 2 步：使用 Microsoft PowerShell 重命名域</h2><p>​        1.必需 – 下载最新的 SharePoint Online 命令行管理程序。<a href="https://go.microsoft.com/fwlink/p/?LinkId=255251%EF%BC%88%E5%A6%82%E6%9E%9C%E5%AE%89%E8%A3%85%E8%BF%87%E6%97%A7%E7%89%88%E5%B0%B1%E9%9C%80%E8%A6%81%E5%85%88%E5%8D%B8%E8%BD%BD%EF%BC%8Cmac%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%99%E4%B8%AA%E7%A8%8B%E5%BA%8F%EF%BC%89">https://go.microsoft.com/fwlink/p/?LinkId=255251（如果安装过旧版就需要先卸载，mac不支持这个程序）</a></p>
<p>​        2.以全局管理员或 SharePoint 管理员身份连接到 SharePoint Online</p>
<p>命令为：Connect-SPOService -Url <a href="https://abc-admin.sharepoint.com(根据实际sharepoint网址修改)回车后输入管理员账户和密码./">https://abc-admin.sharepoint.com（根据实际sharepoint网址修改）回车后输入管理员账户和密码。</a></p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/2.PNG" alt="img"></p>
<p>​        3.重头戏，更改域名（必须是第一步3里面添加的已验证状态的域名前缀）</p>
<p>命令为：Start-SPOTenantRename -DomainName “zxc” -ScheduledDateTime “2021-12-31T10:25:00” （这里的datetime必须是24小时以后最长不超过30天，可以理解为排队时间，最快也要排队24小时才开始给你更改）</p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/3.PNG" alt="img"></p>
<p>​        上图示例中打码处填写修改后的域名（不需要带onmicrosoft.com）,方框处填写24小时，如你2022年1月3号21:30:00申请的，就填2022-01-04T21:30:00</p>
<p>输入命令后会有再次确认的反馈，如果没有反馈，可能是时间错误、域名未验证或者使用了旧版的软件，自行排查。</p>
<p>4.查询进度</p>
<p>命令为： Get-SPOTenantRenameStatus （如果有问题，就打开新的窗口再次登录）</p>
<p>state状态在你设定的时间到之前应该是显示Queued，在处理中是InProgress，成功就是Success。</p>
<p><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/1/4.PNG" alt="img"></p>
<p>5.取消重命名</p>
<p>命令为：Stop-SPOTenantRename （必须在你设定的时间开始之前取消）</p>
<p>6.验证是否成功</p>
<p>从365管理中心登录sharepoint，应该就是zxc-admin.sharepoint.com了</p>
<p>7.重命名不适用于设置了多个地理位置的组织，6个月只能重命名一次，重命名的逻辑是在原来的url上创建重定向，所以也不支持改回原来的域名，也不支持自己添加的个性域名。（经验证，输入原来的sharepoint地址会自动重定向到新的域名）<img src="https://cdn.jsdelivr.net/gh/master-of-forums/master-of-forums/public/images/patch.gif" alt="img"></p>
]]></content>
      <tags>
        <tag>Onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title>目录列表程序AList使用教程</title>
    <url>/posts/25781/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文后续将在<a href="https://alist-doc.nn.ci/">https://alist-doc.nn.ci/</a> 更新。提问请到<a href="https://github.com/Xhofe/alist/discussions">https://github.com/Xhofe/alist/discussions</a><br>AList是一款支持多种存储的目录文件列表程序，后端基于gin，前端使用react。</p>
<blockquote>
<p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md</a></p>
</blockquote>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><ul>
<li><a href="https://github.com/Xhofe/alist">https://github.com/Xhofe/alist</a></li>
<li><a href="https://github.com/Xhofe/alist-web">https://github.com/Xhofe/alist-web</a></li>
</ul>
<h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><ul>
<li><a href="https://alist.nn.ci/">https://alist.nn.ci</a> (稳定版本,即Github Release的最新版本)</li>
<li><a href="https://alist.now.sh/">https://alist.now.sh</a> (开发版本,随着GitHub提交更新)<br><a href="https://store.heytapimage.com/cdo-portal/feedback/202111/03/695ef77854a144e928518efde38db97a.png"><img src="https://store.heytapimage.com/cdo-portal/feedback/202111/03/695ef77854a144e928518efde38db97a.png" alt="alist预览图片"></a></li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>先打开 <a href="https://github.com/Xhofe/alist">https://github.com/Xhofe/alist</a> 点个star😁</p>
<h2 id="手动部署"><a href="#手动部署" class="headerlink" title="手动部署"></a>手动部署</h2><h3 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h3><ol>
<li>打开<a href="https://github.com/Xhofe/alist/releases">AList Release</a>下载要部署的系统对应的文件</li>
<li>解压下载对文件得到可执行文件：<code>tar -zxvf alist-xxxx.tar.gz</code>（Linux）</li>
<li>赋予程序执行权限：<code>chmod +x alist-xxxx</code></li>
<li>运行程序：<code>./alist-xxxx</code></li>
<li>完成，后台默认密码为<code>alist</code></li>
</ol>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p><code>vim /usr/lib/systemd/system/alist.service</code>添加以下内容，其中path_alist为alist所在的路径</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=alist</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"> </span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">WorkingDirectory</span>=path_alist</span><br><span class="line"><span class="attr">ExecStart</span>=path_alist/alist-xxxx -conf data/config.json</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"> </span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>然后<code>systemctl daemon-reload</code>重载配置，现在你就可以使用这些命令来管理程序了：</p>
<ul>
<li>启动: <code>systemctl start alist</code></li>
<li>关闭: <code>systemctl stop alist</code></li>
<li>自启: <code>systemctl enable alist</code></li>
<li>状态: <code>systemctl status alist</code></li>
<li>重启: <code>systemctl restart alist</code></li>
</ul>
<h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><ul>
<li>开发版：<code>docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 --name=&quot;alist&quot; xhofe/alist:v2</code></li>
<li>稳定版：<code>docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 --name=&quot;alist&quot; xhofe/alist:latest</code></li>
<li>指定版本：具体见<a href="https://hub.docker.com/r/xhofe/alist">https://hub.docker.com/r/xhofe/alist</a></li>
</ul>
<h2 id="从源码运行"><a href="#从源码运行" class="headerlink" title="从源码运行"></a>从源码运行</h2><p>首先需要有nodejs、yarn、golang&gt;1.17的环境</p>
<h3 id="构建前端"><a href="#构建前端" class="headerlink" title="构建前端"></a>构建前端</h3><p>clone <a href="https://github.com/Xhofe/alist-web">https://github.com/Xhofe/alist-web</a> 这个项目，执行yarn&amp;&amp; yarn build，得到dist目录下的目标文件</p>
<h3 id="构建后端"><a href="#构建后端" class="headerlink" title="构建后端"></a>构建后端</h3><p>将上一步dist目录下的文件全部拷贝至 <a href="https://github.com/Xhofe/alist">https://github.com/Xhofe/alist</a> 项目下的public目录，然后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appName=<span class="string">&quot;alist&quot;</span></span><br><span class="line">builtAt=<span class="string">&quot;<span class="subst">$(date +&#x27;%F %T %z&#x27;)</span>&quot;</span></span><br><span class="line">goVersion=$(go version | sed <span class="string">&#x27;s/go version //&#x27;</span>)</span><br><span class="line">gitAuthor=$(git show -s --format=<span class="string">&#x27;format:%aN &lt;%ae&gt;&#x27;</span> HEAD)</span><br><span class="line">gitCommit=$(git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h&quot;</span> -1)</span><br><span class="line">gitTag=$(git describe --long --tags --dirty --always)</span><br><span class="line">ldflags=<span class="string">&quot;\</span></span><br><span class="line"><span class="string">-w -s \</span></span><br><span class="line"><span class="string">-X &#x27;github.com/Xhofe/alist/conf.BuiltAt=<span class="variable">$builtAt</span>&#x27; \</span></span><br><span class="line"><span class="string">-X &#x27;github.com/Xhofe/alist/conf.GoVersion=<span class="variable">$goVersion</span>&#x27; \</span></span><br><span class="line"><span class="string">-X &#x27;github.com/Xhofe/alist/conf.GitAuthor=<span class="variable">$gitAuthor</span>&#x27; \</span></span><br><span class="line"><span class="string">-X &#x27;github.com/Xhofe/alist/conf.GitCommit=<span class="variable">$gitCommit</span>&#x27; \</span></span><br><span class="line"><span class="string">-X &#x27;github.com/Xhofe/alist/conf.GitTag=<span class="variable">$gitTag</span>&#x27; \</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">go build -ldflags=<span class="string">&quot;<span class="variable">$ldflags</span>&quot;</span> alist.go</span><br></pre></td></tr></table></figure>

<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>程序默认监听5244端口，要实现https访问，需要使用nginx反向代理，在配置文件中加入</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:5244;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>后台默认密码为<code>alist</code></p>
<h2 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h2><p>所有账号的必填项：</p>
<ul>
<li>name（名称）：唯一标识符，也是当有多个账号时展示的路径</li>
<li>index（索引）：当有多个账号时，用于排序，越小越靠前</li>
<li>proxy（带理）：是否允许服务器中转下载</li>
</ul>
<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>只需填写根目录路径即可，可以是绝对路径，也可以是程序所在的相对路径</p>
<h3 id="阿里云盘"><a href="#阿里云盘" class="headerlink" title="阿里云盘"></a>阿里云盘</h3><ul>
<li>refresh_token（刷新令盘）：如何获取参考这个<a href="https://github.com/Xhofe/alist/issues/88">issue</a>通过手机端抓包/查找日志（<code>/data/media/0/Android/data/com.alicloud.databox/files/logs/trace/</code>）来获取,或使用<a href="https://media.cooluc.com/decode_token/">https://media.cooluc.com/decode_token/</a></li>
<li>根目录file_id：打开阿里云盘官网，点进去你要设置的文件夹时url后面的一串，如<code>https://www.aliyundrive.com/drive/folder/5fe01e1830601baf774e4827a9fb8fb2b5bf7940</code>就是<code>5fe01e1830601baf774e4827a9fb8fb2b5bf7940</code></li>
<li>order_by（排序）：可选值为<code>name</code>，<code>size</code>，<code>updated_at</code>，<code>created_at</code></li>
<li>order_direction（排序方向）：可选<code>ASC</code>（正序），<code>DESC</code>（倒序）</li>
</ul>
<h3 id="Onedrive"><a href="#Onedrive" class="headerlink" title="Onedrive"></a>Onedrive</h3><p>打开<a href="https://tool.nn.ci/onedrive/request">https://tool.nn.ci/onedrive/request</a></p>
<h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><ul>
<li>在打开的页面，选择所在区域，点击创建应用</li>
<li>登陆后选择「注册应用程序」，输入「名称」，选择「任何组织目录中的账户和个人」（注意这里不要看位置选择而是看文字，部分人可能是中间那个选项，不要选成单一租户或者其他选项，否则会导致登陆时出现问题），输入重定向 URL 为 <a href="https://tool.nn.ci/onedrive/callback%EF%BC%8C%E3%80%8C%E6%B3%A8%E5%86%8C%E3%80%8D%E5%8D%B3%E5%8F%AF%EF%BC%8C%E7%84%B6%E5%90%8E%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%60client_id%60">https://tool.nn.ci/onedrive/callback，「注册」即可，然后可以得到`client_id`</a></li>
<li>注册好应用程序之后，选择「证书和密码」，点击「新客户端密码」，输入一串密码，选择时间为最长的那个，点击「添加」<br>（注：在添加之后输入的密码之后会消失，请记录下来 <code>client_secret</code> 的值）</li>
</ul>
<h4 id="获取刷新令牌"><a href="#获取刷新令牌" class="headerlink" title="获取刷新令牌"></a>获取刷新令牌</h4><p>将上一步骤中获得的<code>client_id</code>和<code>client_secret</code>填入<a href="https://tool.nn.ci/onedrive/request">https://tool.nn.ci/onedrive/request</a> 这个页面，点击获取刷新令牌，就可以得到刷新令牌了</p>
<h4 id="获取Sharepoint-site-id（未测试）"><a href="#获取Sharepoint-site-id（未测试）" class="headerlink" title="获取Sharepoint site_id（未测试）"></a>获取Sharepoint site_id（未测试）</h4><p>如果需要挂载Sharepoint，完成上一步后，在显示刷新令牌的界面会出现一个输入站点地址，输入站点地址后点击获取site_id即可。</p>
<h4 id="添加账号-1"><a href="#添加账号-1" class="headerlink" title="添加账号"></a>添加账号</h4><p>将上述过程中获取得到的值依次填入即可。</p>
<h3 id="天翼云盘"><a href="#天翼云盘" class="headerlink" title="天翼云盘"></a>天翼云盘</h3><p>填写账号（手机号），密码即可。可能会触发验证码，可等一段时间再重试。<br>根目录ID：与阿里云盘类似，官网url最后面一串，如：</p>
<ul>
<li><code>https://cloud.189.cn/web/main/file/folder/-11</code> -&gt; <code>-11</code></li>
<li><code>https://cloud.189.cn/web/main/file/folder/71398114617385472</code> -&gt; <code>71398114617385472</code></li>
</ul>
<h3 id="GoogleDrive（支持团队盘）"><a href="#GoogleDrive（支持团队盘）" class="headerlink" title="GoogleDrive（支持团队盘）"></a>GoogleDrive（支持团队盘）</h3><p>参照<a href="https://install.kenci.workers.dev/">https://install.kenci.workers.dev/</a> 获取<code>client_id</code>,<code>client_secret</code>,<code>refresh_token</code>；或：</p>
<ol>
<li>Open <a href="https://console.developers.google.com/apis/api/drive.googleapis.com/overview">Google Drive API</a></li>
<li>Create a <a href="https://console.developers.google.com/apis/credentials/oauthclient">OAuth client ID</a></li>
<li>Install rclone software locally</li>
<li>Get refresh_token with rclone</li>
</ol>
<h3 id="123Pan"><a href="#123Pan" class="headerlink" title="123Pan"></a>123Pan</h3><p>填写账号密码即可。</p>
<h2 id="元信息（meta）设置"><a href="#元信息（meta）设置" class="headerlink" title="元信息（meta）设置"></a>元信息（meta）设置</h2><p>此处的path（路径）是访问alist页面时的pathname，如要设置<code>https://alist.nn.ci/本地存储</code>则路径是<code>/本地存储</code></p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>填写密码字段即可</p>
<h3 id="隐藏文件-文件夹"><a href="#隐藏文件-文件夹" class="headerlink" title="隐藏文件/文件夹"></a>隐藏文件/文件夹</h3><p>填写hide字段，填写要隐藏的文件（夹）名称，以<code>,</code>分隔，比如要隐藏<code>https://alist.nn.ci/本地存储</code>下的<code>README.md</code>和<code>index.tsx</code>文件，则填写<code>README.md,index.tsx</code>即可。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li>向前不兼容版本记录<br>v2.0.0-beta5</li>
<li>阿里云盘视频无法播放，下载显示InvalidArgument？<br>由于referrer的限制，必须使用移动端token</li>
<li>视频播放不了？<br>然后检查一下是不是编码不支持，一般浏览器不支持h.265（hevc）等编码视频，ac3等编码音频，Safari不支持的更多，建议使用软件播放。</li>
<li>获取中转链接？<br>允许中转之后，复制对应文件直链，将/d改成/p即可。</li>
<li>前端文件在哪里？<br>为方便安装，前端文件与程序打包在一起了，如需修改，请按照<code>从源码运行</code>自行修改编译或填写自定义样式/脚本字段。</li>
<li>密码忘了怎么半？<br>命令行 <code>./alist-xxxx -password</code>查看。</li>
<li>自定义样式/脚本不生效？<br>是否前后端分开了？自定义部分为后端处理，只有在不分开时才起作用。</li>
<li>上传的文件不显示/删除的文件还在？<br>程序缓存一小时自动失效，后台右上角可手动清除缓存。</li>
</ul>
]]></content>
      <tags>
        <tag>目录程序</tag>
        <tag>Onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title>分享两个正版免费的Microsoft365企业订阅</title>
    <url>/posts/27817/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先要说明的是，<strong>这里强调的是“正版免费”</strong>，像E5 Dev，甚至E3 MSDN这些特殊订阅，虽然是“免费”，但是仅限于开发用途、教育用途等，<strong>逾越它的使用范围，就不是“正版”</strong>。这样的订阅，个人用用还好，<strong>如果用于商业，可能还会带来麻烦</strong>。而这篇文章所说的“正版免费”是没有用途范围的，可以放心使用。</p>
<p>最近，微软推出了远程协作平台Teams，为了推广这个平台，就设置了很多Teams的免费订阅。但是，<strong>Teams这个平台是融合在Microsoft365（SharePoint）中的，因此所有的Teams订阅都带有Microsoft365授权。</strong></p>
<p>需要注意的是，由于这几个免费订阅的主要目的是配合Teams使用，<strong>因此需要至少每90天登陆一次Teams</strong>（网页版就行，整个全局里只要一人访问即可），否则会撤销订阅。</p>
<h2 id="一、Teams-Free（永久免费）"><a href="#一、Teams-Free（永久免费）" class="headerlink" title="一、Teams Free（永久免费）"></a>一、Teams Free（永久免费）</h2><p>这个订阅理论上可以永久使用，在Admin Center中看到是90天，但实际上只要按上面所说按时登陆Teams，就会像E5 Dev订阅那样自动续期。</p>
<p>订阅没有Exchange Online（Outlook），需要企业邮箱的可以看第二个Exploratory订阅，不过企业邮箱更推荐用Yandex免费企业邮箱。</p>
<p><strong>订阅内容：</strong></p>
<ul>
<li>500000个免费用户</li>
<li>OneDrive 2GB/用户 （这个没啥用，就2GB，比个人版还小，但是相对个人版来说<strong>国内可以网页版在线编辑是一个亮点</strong>）</li>
<li>整个组织还有10GB的Sharepoint空间 （官方说是10GB，实际上是1TB，因为500000个用户每个用户都会增加SharePoint的空间，这个相对来说价值更高一些）</li>
</ul>
<p>注：如果SharePoint域的DNS一直没有配置，请访问Teams&gt;文件&gt;OneDrive并不断刷新直到出现文件列表</p>
<p><strong>注册方法：</strong></p>
<p><a href="https://bbs.1ove.club/gowild.htm?url=https_3A_2F_2Fwww_2emicrosoft_2ecom_2Fzh_2dcn_2Fmicrosoft_2dteams_2Ffree&u=831&fr=https_3A_2F_2Fbbs_2e1ove_2eclub_2Fthread_2d5190_2ehtm">注册地址</a></p>
<p>注册时可能会提示“出现了问题，请重试”。这个问题去问微软客服也不会回答你，一般都会推脱是网络问题。但实际上，这个问题是有原因的，可以很容易地避开。</p>
<ol>
<li>大部分人注册出错，其实是因为使用了不支持的邮箱。注册时使用的邮箱需要满足以下条件：<ul>
<li>企业邮箱，非个人邮箱，outlook.com qq.com之类的不行；</li>
<li>一级域名，*.onaliyun.com之类的不行，但实测freenom免费域名可行；</li>
<li>邮箱后缀未被他人使用过（所以要自己的企业邮）；</li>
<li>邮箱未托管在Microsoft365，因为你要用它来注册Microsoft个人账户（推荐托管在Yandex免费企业邮箱）</li>
</ul>
</li>
<li>注册完个人Microsoft账号后还是会提示一次“出现了问题”，但此时再重试一遍就可以了；</li>
<li>注册时，问你Teams用来干啥，一定要选择第三个(work)。</li>
<li>点击下一步，如果出现一个表格让你填姓名和公司名称，就成功了，填写相关信息即可完成注册。（如果出现“出现了问题，请重试”就是不成功，检查一下邮箱有没有满足上面的条件。）“公司名称”对应的是注册后contoso. onmicrosoft. com中的contoso部分，不要乱填；</li>
<li>使用刚才的个人用户访问aad.portal.azure.com，在左边用户管理里面找到一个admin@contoso(各人不同).onmicrosoft.com格式的用户，使用该用户登录，登录时选择忘记密码，恢复选项是你的个人邮箱。注意：不可以在AAD中直接重置密码。（另外，也可以在AAD中创建新的管理员账号，但原admin账号不可删除。）</li>
</ol>
<h2 id="二、Teams-Exploratory（仅一年免费）"><a href="#二、Teams-Exploratory（仅一年免费）" class="headerlink" title="二、Teams Exploratory（仅一年免费）"></a>二、Teams Exploratory（仅一年免费）</h2><p>这个订阅只有一年时间，但是所含的功能更多，和A1订阅差不多！</p>
<p><strong>订阅内容：</strong></p>
<ul>
<li>100个免费用户</li>
<li>Exchange Online（Outlook） 注：分配许可证的时候默认不分配Exchange Online，需要管理员手动添加</li>
<li>OneDrive 5TB 注：如果SharePoint域的DNS一直没有配置，请访问Teams&gt;文件&gt;OneDrive并不断刷新直到出现文件列表</li>
</ul>
<p><strong>注册方法：</strong></p>
<ul>
<li>访问<a href="https://bbs.1ove.club/gowild.htm?url=https_3A_2F_2Faad_2eportal_2eazure_2ecom_2F&u=831&fr=https_3A_2F_2Fbbs_2e1ove_2eclub_2Fthread_2d5190_2ehtm">https://aad.portal.azure.com</a>，登录微软个人账号，创建租户</li>
<li>切换到创建的新目录，新建一个管理员用户，添加“全局管理员”角色</li>
<li>用隐身模式使用创建的管理员账号登陆<a href="https://bbs.1ove.club/gowild.htm?url=https_3A_2F_2Fteams_2emicrosoft_2ecom_2F&u=831&fr=https_3A_2F_2Fbbs_2e1ove_2eclub_2Fthread_2d5190_2ehtm">https://teams.microsoft.com</a>，等待一段时间，就会自动分配Teams Exploratory订阅</li>
</ul>
]]></content>
      <tags>
        <tag>Onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title>rclone教程 – 用法说明（命令、语法格式）</title>
    <url>/posts/11566/</url>
    <content><![CDATA[<p>本文介绍rclone相关用法的配置、命令、语法等。</p>
<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><p>在使用rclone的初始，首要的是rclone配置。由于对象存储系统的身份验证非常复杂，因此将它们保存在配置文件中。<br>生成配置最容易的方法就是运行rclone的config选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rcone config</span><br></pre></td></tr></table></figure>

<p>下面是rclone支持列表：</p>
<ul>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2ZpY2hpZXIv">1Fichier</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2FsaWFzLw==">Alias</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2FtYXpvbmNsb3VkZHJpdmUv">Amazon Drive</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3MzLw==">Amazon S3</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2IyLw==">Backblaze B2</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2JveC8=">Box</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NhY2hlLw==">Cache</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NodW5rZXIv">Chunker</a> – transparently splits large files for other remotes</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3NoYXJlZmlsZS8=">Citrix ShareFile</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NyeXB0Lw==">Crypt</a> – to encrypt other remotes</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3MzLyNkaWdpdGFsb2NlYW4tc3BhY2Vz">DigitalOcean Spaces</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2Ryb3Bib3gv">Dropbox</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2Z0cC8=">FTP</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2dvb2dsZWNsb3Vkc3RvcmFnZS8=">Google Cloud Storage</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2RyaXZlLw==">Google Drive</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2dvb2dsZXBob3Rvcy8=">Google Photos</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2h0dHAv">HTTP</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2h1YmljLw==">Hubic</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2pvdHRhY2xvdWQv">Jottacloud / GetSky.no</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2tvb2ZyLw==">Koofr</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL21haWxydS8=">Mail.ru Cloud</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL21lZ2Ev">Mega</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL21lbW9yeS8=">Memory</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2F6dXJlYmxvYi8=">Microsoft Azure Blob Storage</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL29uZWRyaXZlLw==">Microsoft OneDrive</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3N3aWZ0Lw==">Openstack Swift / Rackspace Cloudfiles / Memset Memstore</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL29wZW5kcml2ZS8=">OpenDrive</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3BjbG91ZC8=">Pcloud</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3ByZW1pdW1pemVtZS8=">premiumize.me</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3B1dGlvLw==">put.io</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3FpbmdzdG9yLw==">QingStor</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3NmdHAv">SFTP</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3N1Z2Fyc3luYy8=">SugarSync</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3VuaW9uLw==">Union</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3dlYmRhdi8=">WebDAV</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL3lhbmRleC8=">Yandex Disk</a></li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2xvY2FsLw==">The local filesystem</a></li>
</ul>
<h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h2><p>rclone同步一个目录树从一个存储系统到另外一个。<br>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: [options] subcommand &lt;parameters&gt; &lt;parameters...&gt;</span><br></pre></td></tr></table></figure>

<p>源路径和目的路径根据在配置文件中为存储系统指定的名称来指定，然后接上子路径，例如：”drive:myfolder”来查看在Google Drive中的”myfolder”路径。<br>可以在配置文件中定义多个你喜欢的存储路径。</p>
<h2 id="3-子命令（Subcommands）"><a href="#3-子命令（Subcommands）" class="headerlink" title="3. 子命令（Subcommands）"></a>3. 子命令（Subcommands）</h2><p>rclone使用子命令系统，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lists a remote</span><br><span class="line"></span><br><span class="line"># 列出远端文件</span><br><span class="line"></span><br><span class="line">rclone ls remote:path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># copies /local/path to the remote</span><br><span class="line"></span><br><span class="line"># 拷贝本地路径到远端</span><br><span class="line"></span><br><span class="line">rclone copy /local/path remote:path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># syncs /local/path to the remote</span><br><span class="line"></span><br><span class="line"># 同步本地路径到远端</span><br><span class="line"></span><br><span class="line">rclone sync /local/path remote:path</span><br></pre></td></tr></table></figure>

<p>最常用的主要rclone命令：</p>
<ul>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jb25maWcv">rclone config</a> – Enter an interactive configuration session.<br>进入交互式配置会话。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jb3B5Lw==">rclone copy</a> – Copy files from source to dest, skipping already copied.<br>将文件从源复制到目的地，跳过已复制的文件。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9zeW5jLw==">rclone sync</a> – Make source and dest identical, modifying destination only.<br>使源和目的文件一直，仅修改目的。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9tb3ZlLw==">rclone move</a> – Move files from source to dest.<br>将文件从源地址移动到目的地。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9kZWxldGUv">rclone delete</a> – Remove the contents of path.<br>删除路径的指定的内容。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9wdXJnZS8=">rclone purge</a> – Remove the path and all of its contents.<br>删除路径已经路径下的所有内容。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9ta2Rpci8=">rclone mkdir</a> – Make the path if it doesn’t already exist.<br>如果指定路径不存在则创建。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9ybWRpci8=">rclone rmdir</a> – Remove the path.<br>删除指定路径。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9ybWRpcnMv">rclone rmdirs</a> – Remove any empty directories under the path.<br>删除指定路径下的所有空目录。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jaGVjay8=">rclone check</a> – Check if the files in the source and destination match.<br>检查源和目录路径下的文件是否匹配。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9scy8=">rclone ls</a> – List all the objects in the path with size and path.<br>用大小和路径列出指定路径下的所有对象。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9sc2Qv">rclone lsd</a> – List all directories/containers/buckets in the path.<br>列出指定目录下的所有目录（directories）/容器（containers）/存储桶（buckets）。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9sc2wv">rclone lsl</a> – List all the objects in the path with size, modification time and path.<br>以大小、修改时间和路径列出指定路径下的所有对象。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9tZDVzdW0v">rclone md5sum</a> – Produce an md5sum file for all the objects in the path.<br>为指定路径下的所有对象生成一个md5sum文件。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9zaGExc3VtLw==">rclone sha1sum</a> – Produce a sha1sum file for all the objects in the path.<br>为指定路径下的所有对象生成一个sha1sum文件。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9zaXplLw==">rclone size</a> – Return the total size and number of objects in remote:path.<br>返回<code>remote:path</code>路径下对象的总共大小和数量。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV92ZXJzaW9uLw==">rclone version</a> – Show the version number.<br>显示rclone版本号。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jbGVhbnVwLw==">rclone cleanup</a> – Clean up the remote if possible.<br>尽可能清理远端（回收站）。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9kZWR1cGUv">rclone dedupe</a> – Interactively find duplicate files and delete/rename them.<br>交互式查找重复文件并删除/重命名。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9hdXRob3JpemUv">rclone authorize</a> – Remote authorization.<br>远端认证。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jYXQv">rclone cat</a> – Concatenate any files and send them to stdout.<br>连接任意文件并发送到标准输出（stdout）。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jb3B5dG8v">rclone copyto</a> – Copy files from source to dest, skipping already copied.<br>将文件从源复制到目的地，跳过已经复制的。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9nZW5hdXRvY29tcGxldGUv">rclone genautocomplete</a> – Output shell completion scripts for rclone.<br>输出rclone的shell完成脚本。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9nZW5kb2NzLw==">rclone gendocs</a> – Output markdown docs for rclone to the directory supplied.<br>将rclone提供的目录输出为markdown文档。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9saXN0cmVtb3Rlcy8=">rclone listremotes</a> – List all the remotes in the config file.<br>列出配置文件中的所有远端。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9tb3VudC8=">rclone mount</a> – Mount the remote as a mountpoint.<br>将远端挂载为一个挂载点。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9tb3ZldG8v">rclone moveto</a> – Move file or directory from source to dest.<br>将文件或者目录从源移动到目的。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9vYnNjdXJlLw==">rclone obscure</a> – Obscure password for use in the rclone.conf<br>模糊在<code>rclone.conf</code>中使用的密码。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9jcnlwdGNoZWNrLw==">rclone cryptcheck</a> – Check the integrity of a crypted remote.<br>检查加密远端的完整性。</li>
<li><a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzL3JjbG9uZV9hYm91dC8=">rclone about</a> – Get quota information from the remote.<br>从远端获取配额信息。</li>
</ul>
<p>【<a href="https://ikfou.com/?golink=aHR0cHM6Ly9yY2xvbmUub3JnL2NvbW1hbmRzLw==">完整命令索引</a>】</p>
<h2 id="4-复制单个文件"><a href="#4-复制单个文件" class="headerlink" title="4. 复制单个文件"></a>4. 复制单个文件</h2><p>rclone通常会同步或复制目录。如果源指向文件，rclone只会复制该文件。目标必须指向目录，否则rclone将给出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to create file system for &quot;remote:file&quot;: is a file not a directory</span><br></pre></td></tr></table></figure>

<p>举个例子，假如你有一个名为<code>test.jpg</code>的文件，可以通过以下方式拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone copy remote:test.jpg /tmp/download</span><br></pre></td></tr></table></figure>

<p>即，将远端的<code>test.jpg</code>文件拷贝到本地<code>/tmp/download</code>目录下。</p>
<blockquote>
<p>建议在拷贝单个文件时使用<code>copy</code>而不是<code>sync</code>命令。虽然等效，但是<code>copy</code>内存占用更低。</p>
</blockquote>
<h2 id="5-远端（remote）路径语法"><a href="#5-远端（remote）路径语法" class="headerlink" title="5. 远端（remote）路径语法"></a>5. 远端（remote）路径语法</h2><p>这里说明以下给rclone传递的路径格式</p>
<h3 id="5-1-path-to-dir"><a href="#5-1-path-to-dir" class="headerlink" title="5.1 /path/to/dir"></a>5.1 /path/to/dir</h3><p>这种格式指本地文件系统。<br>在windows系统中，本地目录使用<code>\</code>来代替<code>/</code>，而远程目录仍然使用<code>/</code>。</p>
<h3 id="5-2-remote-path-to-dir"><a href="#5-2-remote-path-to-dir" class="headerlink" title="5.2 remote:path/to/dir"></a>5.2 remote:path/to/dir</h3><p>这种就是在<code>remote:</code>上使用的路径格式，这里的<code>remote:</code>就是通过<code>rclone config</code>配置的远端。</p>
<h3 id="5-3-remote-path-to-dir"><a href="#5-3-remote-path-to-dir" class="headerlink" title="5.3 remote:/path/to/dir"></a>5.3 remote:/path/to/dir</h3><p>在大多数后端来讲，<code>remote:path/to/dir</code>和<code>remote:/path/to/dir</code>是等效的，即都指向同一目录。在极少数的远端（FTP，SFTP，Dropbox for business）会指向另外的目录。<br>在这些远端中，不带前导<code>/</code>的路径将引用你的<code>home</code>目录，而带前导<code>/</code>的路径将引用根目录。</p>
<h3 id="5-4-backend-path-to-dir"><a href="#5-4-backend-path-to-dir" class="headerlink" title="5.4 : backend:path/to/dir"></a>5.4 : backend:path/to/dir</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:backend:path/to/dir</span><br></pre></td></tr></table></figure>

<p>这是用于动态创建远端的高级形式。<code>backend</code>是后端的名称或前缀（配置文件中的<code>type</code>参数），并且后端的所有配置都应在命令行中（或在环境变量中）提供。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出https://pub.rclone.org根目录下的所有目录</span><br><span class="line"></span><br><span class="line">rclone lsd --http-url https://pub.rclone.org :http:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 列出https://example.com/path/to/dir目录下的所有文件和目录</span><br><span class="line"></span><br><span class="line">rclone lsf --http-url https://example.com :http:path/to/dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 拷贝https://example.com/path/to/dir下的所有文件和目录到/tmp/dir目录</span><br><span class="line"></span><br><span class="line">rclone copy --http-url https://example.com :http:path/to/dir /tmp/dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用sftp将example.com相对路径path/to/dir下的文件和目录拷贝到/tmp/dir目录</span><br><span class="line"></span><br><span class="line">rclone copy --sftp-host example.com :sftp:path/to/dir /tmp/dir</span><br></pre></td></tr></table></figure>

<h2 id="6-shell引用"><a href="#6-shell引用" class="headerlink" title="6. shell引用"></a>6. shell引用</h2><p>在shell命令行中使用相关命令。</p>
<h3 id="6-1-Linux-OSX"><a href="#6-1-Linux-OSX" class="headerlink" title="6.1 Linux / OSX"></a>6.1 Linux / OSX</h3><p>如果名称包含空格或shell元字符（例如<code>*</code>，<code>?</code>，<code>$</code>，<code>&#39;</code>，<code>&quot;</code>等），则必须用引号引起来。默认情况下，使用单引号<code>&#39;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone copy &#x27;Important files?&#x27; remote:backup</span><br></pre></td></tr></table></figure>

<p>如果说你的名称需要使用单引号<code>&#39;</code>，那么需要使用双引号<code>&quot;</code>包起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone copy &quot;O&#x27;Reilly Reviews&quot; remote:backup</span><br></pre></td></tr></table></figure>

<p>当然还有一些比较复杂的，自行搜索。</p>
<h3 id="6-2-Windows"><a href="#6-2-Windows" class="headerlink" title="6.2 Windows"></a>6.2 Windows</h3><p>名称中存在空格，则需要使用双引号<code>&quot;&quot;</code>，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone copy &quot;E:\folder name\folder name\folder name&quot; remote:backup</span><br></pre></td></tr></table></figure>

<h2 id="7-拷贝名称包含-的文件或目录"><a href="#7-拷贝名称包含-的文件或目录" class="headerlink" title="7. 拷贝名称包含:的文件或目录"></a>7. 拷贝名称包含<code>:</code>的文件或目录</h2><p>rclone使用<code>:</code>来标记一个远程名字。但是，这是非Windows操作系统中的有效文件名组件。远程名称解析器只会搜索<code>:</code>直到第一个<code>/</code>，因此，如果您需要对这样的文件或目录执行操作，请使用以<code>/</code>开头的完整路径，或使用<code>./</code>作为当前目录前缀。</p>
<p>同步一个名称为<code>sync:me</code>的目录到<code>remote:</code>远端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone sync ./sync:me remote:path</span><br><span class="line"></span><br><span class="line">rclone sync /full/path/to/sync:me remote:path</span><br></pre></td></tr></table></figure>

<h2 id="8-服务器端复制（Server-Side-Copy）"><a href="#8-服务器端复制（Server-Side-Copy）" class="headerlink" title="8. 服务器端复制（Server Side Copy）"></a>8. 服务器端复制（Server Side Copy）</h2><p>大多数的远端（不是全部）支持服务器端复制。<br>这个意味着，如果你像拷贝一个目录到另外一个，rclone并不会下载所有文件再重新上传；它将指示服务器将它们复制到位。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone copy s3:oldbucket s3:newbucket</span><br></pre></td></tr></table></figure>

<p>将不会下载并重新上传将<code>oldbucket</code>的内容拷贝到<code>newbucket</code>。在这种情况下，不支持服务器端复制的远端将下载并重新上传。</p>
<p>服务器端拷贝被<code>sync</code>和<code>copy</code>一起使用，使用<code>-v</code>标志时将在日志中进行标识。如果远程服务器不支持服务器端直接移动，那么<code>move命令</code>也可以使用它们。这是通过通知服务器端拷贝然后删除而完成的，比下载和重新上传要快得多。</p>
<p>仅当远端（remote）名称相同时，才尝试服务器端拷贝。<br>下面情况将无法使用服务器端拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone sync remote:current-backup remote:previous-backup</span><br><span class="line"></span><br><span class="line">rclone sync /path/to/files remote:current-backup</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Rclone</tag>
      </tags>
  </entry>
  <entry>
    <title>白嫖Okteto4核26G服务器</title>
    <url>/posts/29839/</url>
    <content><![CDATA[<h1 id="注册Okteto"><a href="#注册Okteto" class="headerlink" title="注册Okteto"></a>注册Okteto</h1><p>打开<a href="https://cloud.okteto.com/#/login,%E7%82%B9%E5%87%BBLog">https://cloud.okteto.com/#/login,点击Log</a> in With GitHub:<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639297256860.png" alt="img"></p>
<h1 id="部署Debain远程桌面"><a href="#部署Debain远程桌面" class="headerlink" title="部署Debain远程桌面"></a>部署Debain远程桌面</h1><p>点击Deploy:<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639297387287.png" alt="img"><br>选择Git URL，输入: <code>https://github.com/gd1214b/okteto-debain-desktop.git</code> ,点击Deploy:<br><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639297703946.png" alt="img"><br>稍等几分钟即可完成部署</p>
<h1 id="登录远程桌面"><a href="#登录远程桌面" class="headerlink" title="登录远程桌面"></a>登录远程桌面</h1><p>部署完成之后，点击这个链接：<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639389420208.png" alt="img"></a><br>打开登陆界面：（如果你没看到下面这个界面请再等几分钟）<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639389458301.png" alt="img"></a><br>点击连接，密码输入<code>uncleluo</code>，完成登陆：<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639389646135.png" alt="img"></a></p>
<h1 id="服务器测评"><a href="#服务器测评" class="headerlink" title="服务器测评"></a>服务器测评</h1><p>操作系统是debian，有root权限：<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639389789625.png" alt="img"></a><br>4核CPU，26G内存，300多G硬盘，算是高配了：<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639390801134.png" alt="img"></a><br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639391025904.png" alt="img"></a><br>服务器IP是谷歌云的：<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639389994696.png" alt="img"></a><br>网速还可以：<br><a href=""><img src="https://tu.oneds.workers.dev/%E4%B8%8A%E4%BC%A0/%E7%99%BD%E5%AB%96Okteto4%E6%A0%B826G%E6%9C%8D%E5%8A%A1%E5%99%A8/1639390254222.png" alt="img"></a></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总的来说，这台云服务器的性能还是可以的，大家可以好好玩一下。<br>如果你在部署过程中遇到任何问题，欢迎在下方的评论区中提出。</p>
]]></content>
      <tags>
        <tag>VPS</tag>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>Pxder：P站(Pixiv)插画批量下载器</title>
    <url>/posts/29095/</url>
    <content><![CDATA[<p>原项目：<a href="https://github.com/Tsuk1ko/pxder">https://github.com/Tsuk1ko/pxder</a></p>
<h1 id="pixiv-downloader"><a href="#pixiv-downloader" class="headerlink" title="pixiv downloader"></a>pixiv downloader</h1><p><a href="https://camo.githubusercontent.com/19dd7254e2e05e5c455dbba3db7b7ae9bfcef91edd95e1d1a7c840aff457631f/68747470733a2f2f692e6c6f6c692e6e65742f323031382f30382f32302f356237616163636662316334612e676966"><img src="https://camo.githubusercontent.com/19dd7254e2e05e5c455dbba3db7b7ae9bfcef91edd95e1d1a7c840aff457631f/68747470733a2f2f692e6c6f6c692e6e65742f323031382f30382f32302f356237616163636662316334612e676966" alt="运行示例"></a></p>
<p>简单写下说明（主要针对 Windows 用户）</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先你需要先安装 Node.js</p>
<h3 id="Windows-Mac"><a href="#Windows-Mac" class="headerlink" title="Windows / Mac"></a>Windows / Mac</h3><p>打开<a href="https://nodejs.org/">官网</a> =&gt; 下载左边的 LTS 版本 =&gt; 安装一路确定</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"># Debian</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | bash -</span><br><span class="line">apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"># Centos</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_12.x | bash -</span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure>

<h2 id="安装-更新-卸载"><a href="#安装-更新-卸载" class="headerlink" title="安装/更新/卸载"></a>安装/更新/卸载</h2><p>Windows 打开“命令提示符”或者“Powershell”，执行下面的命令，即可安装或者更新（注：后续命令皆为在此执行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g pxder</span><br></pre></td></tr></table></figure>

<p>如需卸载，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall -g pxder</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>不同计算机用户的数据是独立储存的，互不影响</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder --login</span><br></pre></td></tr></table></figure>

<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>正常情况下应该会自动弹出浏览器访问一个登录授权页面，如果没有的话请手动打开“Login URL”，操作下去即可</p>
<p>登录成功时浏览器会弹出如下图所示的一个对话框，选择“打开”即可，这时 pxder 应该会显示登录成功</p>
<p><a href="https://camo.githubusercontent.com/99228b98a813a3d3b764efcd815b778de17b43814f296405a084c926bad5e15a/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31332f316e59693856766a6639546b6375502e706e67"><img src="https://camo.githubusercontent.com/99228b98a813a3d3b764efcd815b778de17b43814f296405a084c926bad5e15a/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31332f316e59693856766a6639546b6375502e706e67" alt="打开应用"></a></p>
<p>如果你的体验与上述情况不一致，请使用 <code>pxder --login --no-protocol</code> 命令进行登录，并参考下面的“其他系统”部分进行操作</p>
<h4 id="其他系统"><a href="#其他系统" class="headerlink" title="其他系统"></a>其他系统</h4><p>正常情况下应该会自动弹出浏览器访问一个登录授权页面，如果没有的话请手动打开“Login URL”，不要急着登录或授权，按以下步骤操作：</p>
<ol>
<li>按下 F12 打开“开发者工具”，切换到“Network”选项卡，勾选“Preserve log”</li>
<li>进行登录或授权操作，最终会进入一个空白页面</li>
<li>点击“Doc”进行筛选，找到（一般是）最后一个请求，将 <code>code</code> 参数复制出来，粘贴到程序中并回车</li>
</ol>
<p>以上步骤尽量快速完成，太慢的话验证可能会过期</p>
<p><a href="https://camo.githubusercontent.com/d00a7d104a6fb740c6c8b58e2e4da61d2d0eb0a8f5609d5c0d549ffbc747dc78/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31322f6a4772316e794d5573784b775458682e706e67"><img src="https://camo.githubusercontent.com/d00a7d104a6fb740c6c8b58e2e4da61d2d0eb0a8f5609d5c0d549ffbc747dc78/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30322f31322f6a4772316e794d5573784b775458682e706e67" alt="开发者工具"></a></p>
<h3 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder --logout</span><br></pre></td></tr></table></figure>

<p>仅会删除计算机当前用户储存的 refresh token，在其他计算机或用户上登录的不受影响</p>
<h3 id="登录态复制"><a href="#登录态复制" class="headerlink" title="登录态复制"></a>登录态复制</h3><p>如果你有一个已经登陆了的 pxder，那么你可以通过以下步骤将登录态复制到另一个 pxder 上</p>
<ol>
<li>在已经登录了的设备上执行 <code>pxder --export-token</code>，保存好该 token</li>
<li>在另一个设备上执行 <code>pxder --login TOKEN</code>，将 <code>TOKEN</code> 替换成上一步输出的 token</li>
</ol>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>进入 Pxder 的设置界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder --setting</span><br></pre></td></tr></table></figure>

<p>有六项设置，按下数字键选择一项进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1] Download path           # 下载目录，必须设置</span><br><span class="line">[2] Download thread         # 下载线程数</span><br><span class="line">[3] Download timeout        # 下载超时</span><br><span class="line">[4] Auto rename             # 自动重命名（文件夹）</span><br><span class="line">[5] Proxy                   # 使用代理</span><br><span class="line">[6] Direct mode             # 直连模式</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>下载目录</strong><br>请注意相对路径与绝对路径的区别，不过不用担心，输入完路径后会显示绝对路径以方便你检查<br>目录无需手动建立，下载图片的时候会自动建立</p>
</li>
<li><p><strong>下载线程数</strong><br>即同时下载的图片数，默认为 <code>5</code>，最小为 <code>1</code>，最大为 <code>32</code><br>下载图片时最左侧的一列实际上就是线程编号</p>
</li>
<li><p><strong>下载超时及重试</strong><br>如果这么多秒之后一张图还没被下载完则算作超时，超时后会自动重试，默认值为<code>30</code><br>下载图片时如果线程编号是黄色底的就代表此次是重试<br>重试超过 <code>10</code> 次则视作下载失败</p>
</li>
<li><p><strong>自动重命名</strong><br>开启了以后，例如这个画师原来叫 <code>abc</code>，今天你再次去下载（更新）他的画作，但是他改名叫 <code>def</code> 了，那么程序会自动帮你重命名画师文件夹</p>
</li>
<li><p><strong>使用代理</strong><br>支持使用 HTTP 或 SOCKS 代理，即可以使用小飞机<br>输入格式为 <code>&lt;协议&gt;://[用户名:密码@]&lt;IP&gt;:&lt;端口&gt;</code>，例如：</p>
<ul>
<li><code>http://user:passwd@127.0.0.1:1080</code></li>
<li><code>socks://127.0.0.1:1080</code>（如果你使用小飞机则直接填这个，除非你改过本地端口）</li>
</ul>
<p>如果输入空行则会尝试从环境变量中依次读取 <code>all_proxy</code> <code>https_proxy</code> <code>http_proxy</code>（也包含全大写的环境变量）<br>如果想完全禁止使用代理，请输入 <code>disable</code></p>
</li>
<li><p><strong>直连模式</strong><br>利用域前置（Domain Fronting）绕过 SNI 审查，达到直连使用的目的<br>直连模式不能和代理同时使用</p>
</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>由于历史设计原因，pxder 在大批量下载方面比较无力且容易出错终止（主要受 API 限制），因此不建议使用 pxder 下载数量较大的已收藏作品，比较推荐其他以画师为单位下载的模式</li>
<li>会将同一画师的作品下载在 <code>(UID)画师名</code> 格式的文件夹内，图片命名格式为 <code>(PID)作品名</code><br>并且，画师名会自动删除名字中 <code>@</code>（包含半角&amp;全角）符号及以后的文字（因为这些基本上都是画师的摊位信息之类的与名字无关的信息）</li>
<li>文件（夹）名均会过滤掉所有 Windows 和 Linux 中不能或不推荐做文件名的符号</li>
<li>动图下下来会是所有帧的压缩包，并且会标注 delay 信息<ul>
<li>例如 <code>xxx@30ms.zip</code> 表示该动图的播放速度为 30ms 一帧</li>
<li>由于获取动图信息需要额外调用 API，因此如果动图较多将会使得解析时间较长，可以通过<code>-M</code>参数跳过解析</li>
<li>目前没有自动转 gif / mp4 / webm 的功能，但在计划中，什么时候写看心情</li>
</ul>
</li>
<li>下载时会智能跳过已经下载完成的插画</li>
<li>下载超时或网络错误会自动重试，重试上限为10次<ul>
<li>若状态码为 404 则直接放弃下载，这种大多是P站自身原因导致的图片问题</li>
<li>如果当某一个线程达到重试上限并且此时有不止一个下载线程处于重试状态，程序将视为暂时出现了网络问题，暂停5分钟后会继续重试</li>
<li>如果只有一个下载线程出现错误，视为不明原因错误，程序将会放弃下载该p并继续运行</li>
</ul>
</li>
<li>抗连接重置，解析时连接重置会自动重试</li>
</ul>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>如果需要终止程序，请在命令行中按下 Ctrl C 或者直接关闭命令行窗口</p>
<p>请不要吐槽为什么在 Windows 下 Ctrl C 后提示的 <code>终止批处理操作吗(Y/N)?</code> 不管是 Y 还是 N 都依然会终止，因为 Node 捕捉到 Ctrl C 就自己终止了，Windows 晚了一步（。</p>
<p>欲查看完整命令帮助请执行 <code>pxder -h</code></p>
<h3 id="1-下载或更新某画师的所有插画作品"><a href="#1-下载或更新某画师的所有插画作品" class="headerlink" title="(1) 下载或更新某画师的所有插画作品"></a>(1) 下载或更新某画师的所有插画作品</h3><p>使用 <code>-u</code> 或 <code>--uid</code> 参数，后跟画师的 UID，可单个可多个，如果多个则用英文半角逗号隔开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -u uid1,uid2,uid3,...</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -u 5899479,724607,11597411</span><br></pre></td></tr></table></figure>

<h3 id="2-下载或更新你关注的所有画师的所有插画作品"><a href="#2-下载或更新你关注的所有画师的所有插画作品" class="headerlink" title="(2) 下载或更新你关注的所有画师的所有插画作品"></a>(2) 下载或更新你关注的所有画师的所有插画作品</h3><p>该操作同时也会更新已下载的关注画师的作品，并且效率远高于 (3)，比较推荐使用</p>
<p>会自动排除 pixiv事務局 (uid=<code>11</code>)</p>
<p>由于收集关注信息需时较久，因此特地针对该功能做了信息缓存：如果你在下载中途退出，那么下次使用该功能时并不需要重新收集，而是利用上次的缓存立即继续下载。</p>
<ul>
<li>公开关注与私密关注的缓存是分开的，互不干扰</li>
<li>如果你需要强制重新收集画师信息（忽略上次的缓存），请在运行命令时加入 <code>--force</code> 参数</li>
</ul>
<h4 id="公开关注的画师"><a href="#公开关注的画师" class="headerlink" title="公开关注的画师"></a>公开关注的画师</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -f</span><br><span class="line"># 或</span><br><span class="line">pxder --follow</span><br></pre></td></tr></table></figure>

<h4 id="私密关注的画师"><a href="#私密关注的画师" class="headerlink" title="私密关注的画师"></a>私密关注的画师</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -F</span><br><span class="line"># 或</span><br><span class="line">pxder --follow--private</span><br></pre></td></tr></table></figure>

<h3 id="3-更新已下载的画师的画作"><a href="#3-更新已下载的画师的画作" class="headerlink" title="(3) 更新已下载的画师的画作"></a>(3) 更新已下载的画师的画作</h3><p>会对下载目录中检测到的所有下载过的画师的插画进行增量更新下载</p>
<p>与 (2) 的区别是可以更新你使用 (1) 下载了的但是未关注的画师的插画，但是效率远低于 (2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -U</span><br><span class="line"># 或</span><br><span class="line">pxder --update</span><br></pre></td></tr></table></figure>

<h3 id="4-下载或更新你的收藏中的插画作品"><a href="#4-下载或更新你的收藏中的插画作品" class="headerlink" title="(4) 下载或更新你的收藏中的插画作品"></a>(4) 下载或更新你的收藏中的插画作品</h3><h4 id="公开收藏"><a href="#公开收藏" class="headerlink" title="公开收藏"></a>公开收藏</h4><p>插画会被下载至 <code>[bookmark] Public</code> 文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -b</span><br><span class="line"># 或</span><br><span class="line">pxder --bookmark</span><br></pre></td></tr></table></figure>

<h4 id="私密收藏"><a href="#私密收藏" class="headerlink" title="私密收藏"></a>私密收藏</h4><p>插画会被下载至 <code>[bookmark] Private</code> 文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -B</span><br><span class="line"># 或</span><br><span class="line">pxder --bookmark--private</span><br></pre></td></tr></table></figure>

<h3 id="5-根据指定-PID-下载插画"><a href="#5-根据指定-PID-下载插画" class="headerlink" title="(5) 根据指定 PID 下载插画"></a>(5) 根据指定 PID 下载插画</h3><p>插画会被下载至 <code>PID</code> 文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -p pid1,pid2,pid3,...</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pxder -p 70593670,70594912,70595516</span><br></pre></td></tr></table></figure>

<h3 id="其他参数说明"><a href="#其他参数说明" class="headerlink" title="其他参数说明"></a>其他参数说明</h3><ul>
<li><pre><code>-M
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
--no-ugoira-meta
</code></pre>
<p>下载动图时不请求其元数据，在下列情况下会有帮助</p>
<ol>
<li>对动图的帧间隔信息无所谓，不请求可以节省大量解析时间</li>
<li>画师是专门画动图的，几百张动图解析起来实在是慢，并且动图太多可能导致达到 API 调用速率限制</li>
</ol>
</li>
<li><p><code>--no-cf</code><br>从旧的资源域名 <code>i.pximg.net</code> 下载插画，而不是新的套了 CF 的 <code>i-cf.pximg.net</code></p>
</li>
<li><p><code>--debug</code><br>出错时输出详细的错误信息，如果你发现了 bug 想要提 issue，请尽量附上加了该参数时的错误日志</p>
</li>
<li><p><code>--output-config-dir</code><br>输出 pxder 的配置存放路径</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Pixiv</tag>
      </tags>
  </entry>
  <entry>
    <title>EMBY挂载Google Drive 系统建议Ubuntu 18.04</title>
    <url>/posts/40/</url>
    <content><![CDATA[<p>建议1.7G以上内存，20G以上存储空间 Ubuntu 18.04</p>
<p><strong>1、安装rclone挂载工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | sudo bash</span><br></pre></td></tr></table></figure>

<p><strong>2、配置rclone</strong>，命名：emby</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rclone config</span><br></pre></td></tr></table></figure>

<p><strong>3、挂载到文件夹</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/gdrive</span><br><span class="line">/usr/bin/rclone mount emby: /home/gdrive \</span><br><span class="line"> --umask 0000 \</span><br><span class="line"> --default-permissions \</span><br><span class="line"> --allow-non-empty \</span><br><span class="line"> --allow-other \</span><br><span class="line"> --buffer-size 32M \</span><br><span class="line"> --dir-cache-time 12h \</span><br><span class="line"> --vfs-read-chunk-size 64M \</span><br><span class="line"> --vfs-read-chunk-size-limit 1G &amp;</span><br></pre></td></tr></table></figure>






<p>取消挂载 <code>fusermount -qzu /home/gdrive2/</code> 然后再<code>rclone config</code>里面删除对应的命名<br>安装<code>apt-get install fuse</code>避免下面无法挂载</p>
<p>下面这是我挂载webdav的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/rclone mount teracloud: /home/teracloud \</span><br></pre></td></tr></table></figure>

<p><strong>4、查看挂载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<p><strong>5、自动挂载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/systemd/system/rclone.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Rclone</span><br><span class="line">AssertPathIsDirectory=LocalFolder</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/rclone mount emby: /home/gdrive \</span><br><span class="line"> --umask 0000 \</span><br><span class="line"> --default-permissions \</span><br><span class="line"> --allow-non-empty \</span><br><span class="line"> --allow-other \</span><br><span class="line"> --buffer-size 32M \</span><br><span class="line"> --dir-cache-time 12h \</span><br><span class="line"> --vfs-read-chunk-size 64M \</span><br><span class="line"> --vfs-read-chunk-size-limit 1G</span><br><span class="line">ExecStop=/bin/fusermount -u LocalFolder</span><br><span class="line">Restart=on-abort</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>6、设置启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start rclone</span><br></pre></td></tr></table></figure>

<p><strong>7、开启启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable rclone</span><br></pre></td></tr></table></figure>

<p><strong>8、安装bbrplus</strong> （已安装可以忽略）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure>

<p><strong>9、虚拟内存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.moerats.com/usr/shell/swap.sh &amp;&amp; bash swap.sh</span><br></pre></td></tr></table></figure>

<p>(如果debian9无法创建，请参考CSDN<a href="https://blog.csdn.net/zhangpeterx/article/details/90230063?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">debian 9/ ubuntu 添加swap分区</a>)</p>
<p><strong>10、安装emby</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/MediaBrowser/Emby.Releases/releases/download/4.4.3.0/emby-server-deb_4.4.3.0_amd64.deb</span><br><span class="line">dpkg -i emby-server-deb_4.4.3.0_amd64.deb</span><br></pre></td></tr></table></figure>

<p><em>[解决oracle无法访问的问题]：</em></p>
<p>Oracle云免费机，安装完可能会出现浏览器打开没反应，原因是端口未开放。<br>开放所有端口如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -F</span><br><span class="line">apt-get purge netfilter-persistent</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>安装完毕访问域名+端口号（默认8096）</p>
<p><strong>管理命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service emby-server start|stop|status</span><br></pre></td></tr></table></figure>

<p><strong>彻底卸载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get remove --purge emby-server</span><br></pre></td></tr></table></figure>

<p><strong>备份</strong></p>
<p>将 <code>/var/lib/emby</code> 下的文件打包然后上传到新的地址安装的emby下即可。</p>
<p><strong>查看emby刮削日志</strong><br><code>tail -fn 10 /var/lib/emby/logs/embyserver.txt</code></p>
<p>以上。</p>
]]></content>
      <tags>
        <tag>EMBY</tag>
      </tags>
  </entry>
</search>
